<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>fanzhanxiang&#39; Blog</title>
    <link>https://github.com/fanzhanxiang/fanzhanxiang.github.io/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>2194482952@qq.com</description>
    <pubDate>Fri, 03 Nov 2017 04:48:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JSONP</title>
      <link>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/03/JSONP/</link>
      <guid>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/03/JSONP/</guid>
      <pubDate>Fri, 03 Nov 2017 01:32:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;JSONP和AJAX相同，都是向客户端向服务器发送请求:给服务器传递数据或者从服务器端获取数据的方式。但是他们两种方式之间是有区别的：JSO
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>JSONP和AJAX相同，都是向客户端向服务器发送请求:给服务器传递数据或者从服务器端获取数据的方式。但是他们两种方式之间是有区别的：JSONP属于非同源策略（跨域请求），说明一下，实现跨越的方式有很多种，只不过JSONP是最常用的；而AJAX是属于同源策略。</p><h2 id="同源和非同源的区别"><a href="#同源和非同源的区别" class="headerlink" title="同源和非同源的区别"></a>同源和非同源的区别</h2><p>同源和非同源的区别在于用当前页面的地址于数据请求的接口地址相比较：比如<br>当前页面地址是：<strong><a href="https://www.zhihu.com/people/fanzhanxiang" target="_blank" rel="external">https://www.zhihu.com/people/fanzhanxiang</a></strong>;<br>数据请求接口的地址是：<strong><a href="https://github.com/fanzhanxiang">https://github.com/fanzhanxiang</a></strong>；判断是使用AJAX请求还是JSONP请求我们需要看以下三个方面。</p><blockquote><pre><code>1、协议2、域名3、端口号</code></pre></blockquote><p>上面三个部分完全相同属于同源策略，我们使用AJAX获取数据；只要有一个不一样的，就属于非同源，我们一般使用JSONP来获取数据。就比如上面这两个地址，他们的协议（https和https）、域名（www.zhihu.com和github.com）、端口号（443和443）端口号和域名不一样，因此想要在当前页面中获取这个数据请求的地址需要使用非同源策略。</p><h2 id="JSONP的原理"><a href="#JSONP的原理" class="headerlink" title="JSONP的原理"></a>JSONP的原理</h2><p>JSOPN是利用在JavaScript中的script标签的特性，在script的世界中，没有跨域同源一说，只要你给它的SRC属性中的地址是一个合法的地址，script都可以把对应的内容请求回来。</p><p><strong>JSONP就是利用了这个原理(JSONP请求一定需要对方的服务器做支持才可以)</strong>：</p><blockquote><pre><code>1、我们首先把需要请求数据的那个API数据接口的地址，赋值给script的SRC2、把当前页面中的某一个函数名当做参数值传递给需要跨域请求数据的服务器（URL问号传参一般都是这么写:canllback=fn）3、服务器接到你的请求之后，需要进行特殊的处理：把你传递进来的函数名和他需要给你的数据拼接成一个字符串，例如：我们传递进去的函数名是fn，它准备好的数据是&apos;fn(需要给我们的数据)&apos;；4、最后服务器把准备的数据通过HTTP协议返回给客户端，其实就是让我们的fn执行，而且还给fn传递了一堆数据，那些数据就是我们想要的；</code></pre></blockquote><p>比如下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;  </div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">    function fn(data)&#123;  </div><div class="line">        console.log(data);  </div><div class="line">   &#125;  </div><div class="line">&lt;/script&gt;  </div><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;http://  </div><div class="line">matchweb.sports.qq.com/kbs/calendar?columnId=100000&amp;callback=fn&quot;&gt;    </div><div class="line">&lt;/script&gt;  </div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><p>在谷歌控制台中的输出入下图所示：<img src="http://oyh928sxz.bkt.clouddn.com/JSONP.png" alt="JSONP"></p><h2 id="jQuery的AJAX和JSONP调用"><a href="#jQuery的AJAX和JSONP调用" class="headerlink" title="jQuery的AJAX和JSONP调用"></a>jQuery的AJAX和JSONP调用</h2><p><strong>AJAX请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        $.ajax(&#123;</div><div class="line">            url:&quot;地址&quot;,</div><div class="line">            type:&quot;请求方式&quot;,</div><div class="line">            dataType:&quot;json&quot;,</div><div class="line">            data:null,//-&gt;使用post请求是非服务器传递的内容</div><div class="line">            async:true,//-&gt;同步还是异步，默认是异步</div><div class="line">            cache:false,//设定GET请求的时候不走缓存数据，原理其实就是在URL末尾加随机数，默认值是true</div><div class="line">            timeout:1000,//设置超时时间 一般都设定3000ms，超过时间之后就跑到error</div><div class="line">            success:function(data)&#123;//-&gt;data是请求回来的数据</div><div class="line">                console.log(data);</div><div class="line">            &#125;,</div><div class="line">            error:function()&#123;&#125;,//请求失败的时候执行这个</div><div class="line">        &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p><strong>JSONP请求</strong><br>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，而且jQuery会默认就会给JSONP的请求清除缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">      $.ajax(&#123;</div><div class="line">        url: &quot;请求地址&quot;,</div><div class="line">        dataType: &quot;jsonp&quot;,</div><div class="line">        jsonpCallback: &quot;fn&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的</div><div class="line">        jsonp:&quot;cb&quot;,//-&gt;把传递函数名的那个形参callback变为cb</div><div class="line">        success: function (data) &#123;</div><div class="line">            console.log(data);</div><div class="line">        &#125;</div><div class="line">    &#125;);  </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/03/JSONP/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ajax</title>
      <link>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/31/ajax/</link>
      <guid>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/31/ajax/</guid>
      <pubDate>Tue, 31 Oct 2017 09:32:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;Ajax:async javascript and xml 叫做异步的JS和XML(可扩展标记语言)，它是一种客户端的JS方法，用来向服务器端发送请求(还可以传递给服务器数据)，然后把服务器端返回的内容获取到，它一般运行在客户端的浏览器中的。&lt;/p&gt;
&lt;h2 id=&quot;Ajax的四个步骤&quot;&gt;&lt;a href=&quot;#Ajax的四个步骤&quot; class=&quot;headerlink&quot; title=&quot;Ajax的四个步骤&quot;&gt;&lt;/a&gt;Ajax的四个步骤&lt;/h2&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Ajax:async javascript and xml 叫做异步的JS和XML(可扩展标记语言)，它是一种客户端的JS方法，用来向服务器端发送请求(还可以传递给服务器数据)，然后把服务器端返回的内容获取到，它一般运行在客户端的浏览器中的。</p><h2 id="Ajax的四个步骤"><a href="#Ajax的四个步骤" class="headerlink" title="Ajax的四个步骤"></a>Ajax的四个步骤</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1、var xhr=new XMLHttpRequest;   </div><div class="line">2、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]);  </div><div class="line">3、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text  (xhr.status))&#123;var val=xhr.responseText&#125;  &#125;;  </div><div class="line">4、xhr.send(&quot;要传递给服务器的内容&quot;);</div></pre></td></tr></table></figure><h2 id="1、第一步"><a href="#1、第一步" class="headerlink" title="1、第一步"></a>1、第一步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1、var xhr=new XMLHttpRequest;</div></pre></td></tr></table></figure><p>创建一个AJAX对象（在IE6及更低版本的浏览器中不兼容）</p><h2 id="2、第二步"><a href="#2、第二步" class="headerlink" title="2、第二步"></a>2、第二步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]);</div></pre></td></tr></table></figure><p>发送前的基本信息配置：配置请求方式，请求方式有GET、POST、PUT、DELETE、HEAD，上面是几种方式不管是哪一种都可以向服务器传递数据，也可以从服务器获取到数据，而且从本质意义上来讲上面几种请求方式是没有什么区别的，例如用POST做的事情用GET也能做。以下区别都是开发者约定俗成的规范；</p><blockquote><pre><code>1、GET：一般应用于从服务器获取数据（给服务器的少，从服务器拿的数据多），使用GET请求给服务器传递内容，我们一般都使用&quot;URL问号传参的方式&quot;；例如：xhr.open(&quot;get&quot;,&quot;/getList?num=2&quot;),但是这种方式传递的内容存在大小限制；因为GET通过URL传参给服务器，而每个浏览器对于URL的长度存在限制，谷歌8kb、火狐7kb、IE2kb的长度限制，如果URL的长度超过限制，浏览器会把超出的部分的截取。并且这个请求会出现缓存（这个缓存不一定304）。在项目中我们的GET请求一般不会让其出现缓存，因此要清除缓存，清除GET请求缓存的方法是在URL的末尾加一个随机数xhr.open(&quot;get&quot;,&quot;/getList?num =2&amp;_=&quot;+Math.random());在用get请求的时候与post相比，是不安全的2、POST：一般应用于向服务器推送数据（给服务器的多，从服务器上拿的少），我们一般使用&quot;请求主体的方式&quot;传递给服务器，例如：xhr.open(&quot;post&quot;,&quot;/getList&quot;);xhr.send(&apos;{&quot;name&quot;:&quot;zhufeng&quot;,&quot;age&quot;:7&apos;)，这种传递方式理论上是没有大小限制的，并且这个请求是没有缓存的。3、PUT：一般应用于给服务器上传资源文件（我们上传图片功能）4、DELETE：一般应用于从服务器上删除资源文件5、HEAD：一般应用于只获取服务器的响应头信息</code></pre></blockquote><p>第三个参数默认是异步；username:向服务器提供的用户名,userpass:向服务器提供的用户密码，这两个值一般都不写，只有服务器做了安全限制，只允许特定的用户访问，我们才传递过去。</p><h2 id="3、第三步"><a href="#3、第三步" class="headerlink" title="3、第三步"></a>3、第三步</h2><p>这一步不是必须的，如果自己不要拿回数据的话，就可以不需要执行这步，那么ajax只需要三步就可以完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text(xhr.status))&#123;var val=xhr.responseText&#125;&#125;;</div></pre></td></tr></table></figure></p><p>给<strong>onreadyStatechange</strong>这个事件绑定一个方法，监听状态的改变(只要状态改变，就会触发这个事件绑定的相应方法执行)；</p><p><strong>xhr.readyState</strong>：AJAX状态码其中有5个值（0,1,2,3,4），可以代表当前AJAX处理的进度。</p><blockquote><pre><code>0：&quot;unset&quot;，表示当前的请求还没有发送；1：&quot;opened&quot;,表示URL地址已经打开(发送前的参数配置已经完成)；2：&quot;headers_received&quot;,表示响应头信息已经接收；3：&quot;loading&quot;,主要返回的内容正在服务器端进行准备处理；4：&quot;done&quot;:响应主体的内容已经成功返回客户端。</code></pre></blockquote><p><strong>xhr.status</strong>:HTTP网络状态码，描述了服务器响应内容的状态，HTTP网络状态码有如下几种：</p><blockquote><pre><code>200 OR ^2\d{2}： (200或者以2开头的)都代表响应主体的内容已经成功返回了301：永久重定向/永久转移302：临时重定向/临时转移,服务器的负载均衡304：本次获取的内容是读取缓存中的数据400:客户端传递给服务器端的参数出现错误，客户端传递的参数有问题401：无权限访问404：访问的地址不存在500：未知的服务器错误503：服务器已经超负荷了，比如能承受10000人，那么第10001个人访问，如果没有做服务器的负载均衡（302），那么这个人的状态码就是503;</code></pre></blockquote><h2 id="4、第四步"><a href="#4、第四步" class="headerlink" title="4、第四步"></a>4、第四步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4、xhr.send(&quot;要传递给服务器的内容&quot;);</div></pre></td></tr></table></figure><p>发送请求：参数是请求主体中给传递给服务器的内容；只有执行完第四步之后才开始一个AJAX请求。</p><h2 id="补充：AJAX中的同步和异步"><a href="#补充：AJAX中的同步和异步" class="headerlink" title="补充：AJAX中的同步和异步"></a>补充：AJAX中的同步和异步</h2><p><strong>AJAX中的同步</strong>：当AJAX任务开始的时候(XHR.SEND),一直需要到READYSTATE===4的时候任务才结束，此时才可以处理其它的事情。并且只有当其它的任务完成后，我们再看是否到4，到4之后做一些相关的操作。</p><p><strong>AJAX中的异步</strong>：当AJAX任务开始的时候(XHR.SEND),不需要到READYSTATE===4，我依然可以处理其它的事情。</p><p><strong>下面是几个同步编程和异步编程的几个编程题</strong></p><p>1、问：下面的会在控制台输出几次，输出的分别是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var xhr=new XMLHttpRequest;   </div><div class="line">xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true);  </div><div class="line">xhr.onreadyStatechange=function()&#123;</div><div class="line">console.log(xhr.readyState);  </div><div class="line">&#125;;  </div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure><p>答案：会输出三次，分别是2、3、4<br>原因：因为第三个参数是true，所以这里是异步编程，所以绑定了xhr.onreadyStatechange这个事件一个方法，只要AJAX状态码发生改变，就会执行对应的这个事件绑定的对应方法。因为在open之后AJAX状态码已经变为了，所以当由1变到2的过程中，就会触发这个事件，对应后面从2到3,3到4也是这个原理，所以最终会输出三次，值分别：2、3、4</p><p>2、问：下面的会在控制台输出几次，输出的分别是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var xhr=new XMLHttpRequest;   </div><div class="line">xhr.onreadyStatechange=function()&#123;</div><div class="line">console.log(xhr.readyState);  </div><div class="line">&#125;;  </div><div class="line">xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true);  </div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure><p>答案：会输出四次，分别是1、2、3、4。<br>原因：因为这里open之前就已经绑定了这个方法，所以AJAX状态码从0变到了的过程中就会触发这个方法，所以会输出1；</p><p>3、问：下面的会在控制台输出几次，输出的分别是什么？</p><pre><code>var xhr=new XMLHttpRequest;    xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.onreadyStatechange=function(){  console.log(xhr.readyState);  };  xhr.send(null);</code></pre><p>答案：会输出一次，是4。<br>原因：代码上到下执行，当AJAX状态码为1的时候为onreadyStatechange这个事件绑定了一个方法，然后当任务执行完成之后，AJAX状态码变为4，触发这个事件，输出4。</p><p>4、问：下面的会在控制台输出几次，输出的分别是什么？</p><pre><code>var xhr=new XMLHttpRequest;    xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null);  xhr.onreadyStatechange=function(){  console.log(xhr.readyState);  };</code></pre><p>答案：会输出3次，分别是2、3、4</p><p>5、问：下面的会在控制台输出几次，输出的分别是什么？</p><pre><code>var xhr=new XMLHttpRequest;    xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.send(null);  xhr.onreadyStatechange=function(){  console.log(xhr.readyState);  };</code></pre><p>答案：0次，什么都不输出<br>原因：采用同步编程，在AJAX状态码变为4之前，什么都不做，而且在这之前也没有绑定xhr.onreadyStatechange事件，所以在这之前什么都不会做。也没有记录对应的AJAX状态码状态码值，在AJAX状态码变为4之后，绑定了一个事件，但是后面AJAX状态码不会变了，因此永远不会触发事件。</p>]]></content:encoded>
      
      <comments>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/31/ajax/#disqus_thread</comments>
    </item>
    
    <item>
      <title>DOM0级事件绑定和DOM2级事件及其扩展</title>
      <link>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/27/DOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6/</link>
      <guid>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/27/DOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6/</guid>
      <pubDate>Fri, 27 Oct 2017 08:06:22 GMT</pubDate>
      <description>
      
        &lt;p&gt; 在页面上写一个id为box的一个div，然后设置一些它的宽度和高度，然后在后面在做事件绑定的时使用。先是使用DOM0级事件绑定。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;box.onclick=function()&amp;#123;console.log(1)&amp;#125;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;box.onclick=function()&amp;#123;console.log(2)&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 后面这个事件会把前一个事件给覆盖掉，最后在控制台中只会输出一个2.因为在使用DOM0级事件绑定的时候，&lt;strong&gt;只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉&lt;/strong&gt;（这里主要是某一个行为绑定一次方法，不同的行为是可以绑定同一个方法的，比如这里是&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;box.onclick=function()&amp;#123;console.log(2)&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里是可以输出2的）；所以最后在控制台只能输出一次2。DOM0级事件绑定和DOM2级事件绑定最大的区别也是在这里，但是DOM2级事件中也有一些其他特别的地方。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p> 在页面上写一个id为box的一个div，然后设置一些它的宽度和高度，然后在后面在做事件绑定的时使用。先是使用DOM0级事件绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">box.onclick=function()&#123;console.log(1)&#125;;  </div><div class="line">box.onclick=function()&#123;console.log(2)&#125;;</div></pre></td></tr></table></figure><p> 后面这个事件会把前一个事件给覆盖掉，最后在控制台中只会输出一个2.因为在使用DOM0级事件绑定的时候，<strong>只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉</strong>（这里主要是某一个行为绑定一次方法，不同的行为是可以绑定同一个方法的，比如这里是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box.onclick=function()&#123;console.log(2)&#125;;</div></pre></td></tr></table></figure></p><p>这里是可以输出2的）；所以最后在控制台只能输出一次2。DOM0级事件绑定和DOM2级事件绑定最大的区别也是在这里，但是DOM2级事件中也有一些其他特别的地方。<br><a id="more"></a></p><h2 id="1、基础；"><a href="#1、基础；" class="headerlink" title="1、基础；"></a>1、基础；</h2><p>当我们使用DOM2级事件绑定，它的原理是让box通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现的。DOM2级事件绑定解决了DOM0级事件绑定中“只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉”这个问题，比如下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false);         </div><div class="line">box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false);</div></pre></td></tr></table></figure><p>点击box的时候，控制台上输出了1和2，方法中的第三个参数false表示的是该事件在冒泡阶段触发。总结出DOM2级事件可以给某一个元素的同一个行为绑定多个不同的方法。</p><h2 id="2、DOM2；"><a href="#2、DOM2；" class="headerlink" title="2、DOM2；"></a>2、DOM2；</h2><p> DOMO中行为类型，我们用DOM2一样可以绑定；而且DOM2中还提供了DOM0中没有的行为类型，比如DOM2中有一个行为<strong>DOMContentLoaded</strong>（当页面中的DOM结构或者是叫HTML结构加载完成触发的行为）这个行为是DOM0中没有的。像这个事件的绑定是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;&#125;,false) ;  </div><div class="line">window.onload=function()&#123;&#125;;</div></pre></td></tr></table></figure><p>上面的两个事件绑定是有区别的，这个代表的意思是当页面中所有的资源都加载完成（图片、HTML结构、音视频…）才会执行后面的函数；并且在一个页面中只能使用一次，后面再写会把前面的覆盖掉，因为它是DOM0事件绑定，所以只能绑定一次。<br>并且在jQuery中也提供了类似的方法 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(document).ready(function()&#123;&#125;)---&gt;$(function()&#123;&#125;);</div></pre></td></tr></table></figure><p>只要也拿中的HTML结构加载完成就会执行对应的函数；并且在一个页面中可以出现多次，因为jQuery在写这个方法的时候是使用DOM2级事件绑定来写的，并且绑定的行为是DOM2中的“DOMContentLoaded”这个行为来绑定的。</p><h2 id="3、移除DOM2事件绑定："><a href="#3、移除DOM2事件绑定：" class="headerlink" title="3、移除DOM2事件绑定："></a>3、移除DOM2事件绑定：</h2><p>前面两行代码中，里面的this是box，这里并不能移除事件绑定，因为两个匿名函数是两个不同的堆内存，因此不能移除事件绑定；把匿名函数换成实名函数就可以了，比如后面两行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">box.addEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false);                                                         </div><div class="line">box.removeEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false)； </div><div class="line">function fn1()&#123;console.log(this)&#125;；  </div><div class="line">box.removeEventListener(&quot;click&quot;,fn1,false)；</div></pre></td></tr></table></figure><p>这里就可以实现移除了，并且在控制台中不会输出任何东西，因为在刚绑定的时候就已经移除了。<br>移除的时候需要保证三个参数：行为、方法、那个阶段发生，一个都不能差，因为在使用DOM2事件绑定的时候，我们一般绑定的都是实名函数，如果这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box.removeEventListener(&quot;click&quot;,fn1,true)；</div></pre></td></tr></table></figure></p><p>   就移除掉了，还会输出this；</p><h2 id="4、注意点"><a href="#4、注意点" class="headerlink" title="4、注意点"></a>4、注意点</h2><p>只能给某个元素的同一个行为绑定多个“<strong>不同</strong>”的方法（如果方法相同了，只能留一个），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function fn1()&#123;console.log(1)&#125;；  </div><div class="line">box.removeEventListener (&quot;click&quot;,fn1,false)；  </div><div class="line">box.removeEventListener(&quot;click&quot;,fn1,false)；</div></pre></td></tr></table></figure><p>在点击的时候只会输出一个1。当行为触发，会按照绑定的先后顺序依次把绑定的方法执行；执行的方法中的this是当前被绑定事件的本身。并且在绑定方法的时候，浏览器天生自带的一个东西叫事件池（也有叫程序池的），用来存储绑定的事件的。</p><p>  但是在IE6~8浏览器中不支持addEventListener/removeEventListener,如果想要实现DOM2级事件绑定只能用attachEvent,移除是使用detachEvent。  box.attachEvent(“onclick”,fn1);<br>  并且它只有两个参数，不能向addEventListener那样控制在那个阶段发生，只能在冒泡阶段发生，行为需要添加”on”,和DOM0特别类似</p>]]></content:encoded>
      
      <comments>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/27/DOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>搭建个人博客的感受</title>
      <link>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/15/%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%80%BB%E7%BB%93/</link>
      <guid>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/15/%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sun, 15 Oct 2017 11:00:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天注册了一个hexo+GitHub的一个博客。下面的是一些自己一些的感受。改天有时间写一个详细版的教程关于建立个人博客的。虽然网上已经有很多了，但是自己还是有不少想要分享的地方，下面的是最简单的几点，也是自己写的第一篇博客。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今天注册了一个hexo+GitHub的一个博客。下面的是一些自己一些的感受。改天有时间写一个详细版的教程关于建立个人博客的。虽然网上已经有很多了，但是自己还是有不少想要分享的地方，下面的是最简单的几点，也是自己写的第一篇博客。</p><a id="more"></a><ul><li><p>1、<strong>_config</strong>的语法非常严谨、当你要用里面的语法的时候首先需要做的一件事情把对应地方的#去掉，如果不把你想要设置的对应的地方的#去掉，当你在执行hexo g的时候会报或者是 你设置的这个地方对应的效果没有效果。</p></li><li><p>2、<strong>_config</strong>在设置的时候，”：“后面必须一个空格，这也是因为_config的语法比较严谨的原因</p></li><li><p>3、<strong>GitHub</strong>有缓存时间，这是一个比较令人头疼的问题，自己在_config设置完所有的参数之后，然后执行hexo g、hexo d.然后是过了几分钟之后自己打开了自己博客，发现竟然返回了404页面，当时也是比较懵逼的，然后就一直谷歌上面各种找原因。看到一个人回答说是GitHub的缓存原因。这才放心，后面等了一会儿之后设置的东西相应的显示出来了。</p></li></ul><p>总结：总的来说大体常见的问题就是这些。在打扮博客的过程中肯定会碰到各种各样的问题，抽时间来一个大总结。</p>]]></content:encoded>
      
      <comments>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/15/%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/11/hello-world/</link>
      <guid>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/11/hello-world/</guid>
      <pubDate>Wed, 11 Oct 2017 06:05:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content:encoded>
      
      <comments>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/11/hello-world/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
