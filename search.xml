<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[五种页面布局的方法]]></title>
    <url>%2F2018%2F04%2F06%2F%E4%BA%94%E7%A7%8D%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面是五中页面布局的方式，代码和效果图：常用的三栏布局的五种方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style media=&quot;screen&quot;&gt; html *&#123; padding:0; margin:0; &#125; .layout&#123; margin-top: 20px; &#125; .layout article div&#123; height:100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1.浮动解决方案--&gt;&lt;section class=&quot;layout float&quot;&gt; &lt;style media=&quot;screen&quot;&gt; .layout.float .left&#123; float:left; width:300px; background:red; &#125; .layout.float .right&#123; float:right; width:300px; background: blue; &#125; .layout.float .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;浮动解决方案&lt;/h1&gt; 1.这是三栏布局的中间部分 2.这是三栏布局的中间部分 &lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;!--2.绝对定位解决方案--&gt;&lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute .left-center-right&gt;div&#123; position:absolute; &#125; .layout.absolute .left&#123; left:0; width:300px; background: red; &#125; .layout.absolute .center&#123; /*离左侧300右侧300就达到了一个自适应的原理*/ left:300px; right:300px; background: yellow; &#125; .layout.absolute .right&#123; right:0; width:300px; background: blue; &#125; &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.三栏布局绝对定位中间部分 2.三栏布局绝对定位中间部分 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;!--3.flexbox解决方案--&gt;&lt;section class=&quot;layout flexbox&quot;&gt; &lt;style&gt; .layout.flexbox&#123; margin-top: 140px; &#125; .layout.flexbox .left-center-right&#123; display: flex; &#125; .layout.flexbox .left&#123; width:300px; background: red; &#125; .layout.flexbox .center&#123; flex: 1; background: yellow; &#125; .layout.flexbox .right&#123; width:300px; background: blue; &#125; &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.三栏布局flexbox中间部分 2.三栏布局flexbox中间部分 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;!--4.表格布局解决方案--&gt;&lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table .left-center-right&#123; width:100%; display: table; height:100px; &#125; .layout.table .left-center-right&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width:300px; background: red; &#125; .layout.table .right&#123; width:300px; background: blue; &#125; .layout.table .center&#123; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.三栏布局表格中间部分 2.三栏布局表格中间部分 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;!--5.网格布局解决方案--&gt;&lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .left-center-right&#123; display: grid; width:100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left&#123; background: red; &#125; .layout.grid .center&#123; background: yellow; &#125; .layout.grid .right&#123; background: blue; &#125; &lt;/style&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.三栏布局网格中间部分 2.三栏布局网格中间部分 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 浏览器中打开效果如图所示 五种方案的优缺点对比 1.对于浮动：缺点:当元素浮动之后，就脱离文档流了，会影响后面的元素;优点:兼容性比较好 2.对于绝对定位：缺点:定位之后，脱离文档流，会影响后面元素；优点:方便快捷 3.flex布局:解决了上述两个方式的不足，也比较灵活 4.表格布局:和flex布局差不多 5.网格布局:代码量比较简化。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.assign()的简单用法]]></title>
    <url>%2F2018%2F03%2F18%2FObject.assign()%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[语法 1Object.assign(target, ...sources) 复制一个对象1234var obj = &#123; a: 1 &#125;; var copy = Object.assign(&#123;&#125;, obj); console.log(copy); // &#123; a: 1 &#125; 深拷贝问题 针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性 值是一个指向对象的引用，它也只拷贝那个引用值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function test() &#123; &apos;use strict&apos;; let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj2 = Object.assign(&#123;&#125;, obj1); console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj1.a = 1; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj2.a = 2; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125; obj2.b.c = 3; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; //-&gt;注意这时候源对象自身也发生了改变 // Deep Clone obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125; ; let obj3 = JSON.parse(JSON.stringify(obj1)); obj1.a = 4; obj1.b.c = 4; console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; //-&gt;这种情况下改变原对象的时候目标对象本身并没有发生改变 ，和上面的形成对比 &#125; test(); 合并对象12345678910var o1 = &#123; a: 1 &#125;; var o2 = &#123; b: 2 &#125;; var o3 = &#123; c: 3 &#125;; var obj = Object.assign(o1, o2, o3); console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125; console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。 合并具有相同属性的对象1234567var o1 = &#123; a: 1, b: 1, c: 1 &#125;; var o2 = &#123; b: 2, c: 2 &#125;; var o3 = &#123; c: 3 &#125;; var obj = Object.assign(&#123;&#125;, o1, o2, o3); console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fs模块基础知识]]></title>
    <url>%2F2018%2F03%2F16%2Ffs%E6%A8%A1%E5%9D%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[fs模块是操作文件的模块，里面有很多种方法 readFile和readFileSync readFile是异步读取文件，会在readFileSync之后执行 readFileSync同步读取文件 12345var fs=require(&apos;fs&apos;); //注:index.txt里面存放的是123 fs.readFile(&apos;index.txt&apos;,&apos;utf8&apos;,function(err,data)&#123;console.log(data)&#125;);//-&gt;123 var data=fs.readFileSync(&apos;index.txt&apos;);//-&gt;（不给编码的话返回的是一个buffer） console.log(data);&lt;Buffer 31 32 33&gt; console.log(fs.readFileSync(&apos;index.txt&apos;));//-&gt;&lt;Buffer 31 32 33&gt; 控制台中依次输出的是&quot;&lt;Buffer 31 32 33&gt;&quot;,&quot;&lt;Buffer 31 32 33&gt;&quot;, &quot;123&quot; 证明了readFileSync同步读取文件会先执行，readFile异步读取文件会后执行 writeFileSync和writeFile是把内容写在文件里，用法如下 123fs.writeFile(&apos;line.txt&apos;,&apos;第一行&apos;,&#123;flag:&apos;w&apos;,encoding:&apos;utf8&apos;&#125;,function (err) &#123; console.error(err); &#125;); 第一个参数是写入文件路径，第个参数是写入文件的内容，第三个是可选参数，最后一个是写入之后的回调 appendFile appendFile是往文件夹中加内容，用法和上面的类似 123fs.appendFile(&apos;line.txt&apos;,&apos;第一行&apos;,&#123;flag:&apos;w&apos;,encoding:&apos;utf8&apos;&#125;,function (err) &#123; console.error(err); &#125;); //这时候文件中就有&quot;line.txt&quot;中就有&quot;第一行第二行&quot;这个内容了 writeFile和writeFileSync同时执行的时候只有writeFile起作用 12345fs.writeFileSync(&apos;line.txt&apos;,&apos;第一行&apos;,&#123;flag:&apos;w&apos;,encoding:&apos;utf8&apos;&#125;); fs.writeFile(&apos;line.txt&apos;,&apos;第三行&apos;,&#123;flag:&apos;w&apos;,encoding:&apos;utf8&apos;&#125;,function (err) &#123; console.error(err); console.log(&quot;异步&quot;) &#125;); //最后在line.text中只能找到&quot;第三行&quot; openSync和readSync，这是同步的，也有异步的open和read fs.readSync(fd,buffer,offset,length,position) fd:文件描述符，每打开一个文件的时候都会给它分配一个文件描述符 buffer: 存放buffer的容器 offset: 在buffer里面的偏移量 length: 长度 position: 文件的当前读取位置 1234567var fd=fs.openSync(&apos;line.txt&apos;, &apos;r&apos;); // var fd=fs.open(&apos;line.txt&apos;, &apos;r&apos;,function(err,fd)&#123; // console.log(fd);//-&gt;3 打开一个文件系统会给它分配一个索引; // &#125;);&quot; var buffer=new Buffer(3); fs.readSync(fd,buffer,0,3,0); console.log(buffer.toString()); //-&gt;&quot;第&quot;，因为一个汉字是三个字节 read 使用read方法可将文件里面的内容分块读取 123456789101112131415161718192021var fs=require(&apos;fs&apos;); var list=[]; var buffer=new Buffer(12); fs.open(&apos;line.txt&apos;,&apos;r&apos;,function(err,fd)&#123; var pos=0; function read()&#123; var buffer=new Buffer(3); fs.read(fd,buffer,0,3,pos,function(err,bytesRead,buffer)&#123; pos+=bytesRead; console.log(bytesRead);//-&gt;依次输出了3,3,3,0,说明读取了四次 list.push(buffer.slice(0,bytesRead)); if(bytesRead&gt;0) read();else&#123; var result=Buffer.concat(list); console.log(result.toString());//第三行 &#125; &#125;); &#125; read(); &#125;); //这个方法就实现了每次读三个字节 fs.write write方法实现了往文件中分块写入内容,用法和read方法一样，只是加了一个要写入的内容 123456789101112131415var buffer=new Buffer(&quot;你好世界&quot;); var fs=require(&apos;fs&apos;); fs.open(&apos;line.txt&apos;,&apos;w&apos;,function(err,fd)&#123; console.log(&quot;first&quot;,fd); //first 3 fs.write(fd,buffer,6,6,6,function(err,bytesWritten)&#123; //console.log(bytesWritten); fs.write(fd,buffer,0,6,0,function(err,bytesWritten)&#123; //console.log(bytesWritten); fs.close(fd); fs.open(&apos;line.txt&apos;,&apos;w&apos;,function(err,fd)&#123; console.log(&quot;second&quot;,fd); //second 3 &#125;); &#125;); &#125;);&#125;); console 通过下面的代码看 12345678910console.log(process.stdin.fd);//0 console.log(process.stdout.fd);//1 console.log(process.stderr.fd); //2 var fs=require(&apos;fs&apos;); setTimeout(function()&#123; var buffer=new Buffer(1); fs.read(0,buffer,0,1,0,function(err)&#123; console.log(buffer.toString());//当往控制台中输入1的时候，就会触发这个方法，就会再输出一个1 &#125;); &#125;,3000);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6(ES6)基础知识]]></title>
    <url>%2F2018%2F03%2F13%2FECMAScript6(ES6)%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[ES6中的let和const1、let不存在变量提升机制 123456789101112131415161718192021console.log(str);//=&gt;undefined console.log(fn);//=&gt;fn本身 console.log(avg);//=&gt;undefinedconsole.log(sum);//=&gt;Uncaught ReferenceError: sum is not definedconsole.log(num);//=&gt;Uncaught ReferenceError: num is not definedvar str = &apos;123&apos;; let num = 12; function fn() &#123;&#125; var avg = function () &#123;&#125;; let sum = function () &#123;&#125;; //=&gt;ES6中只提供了创建变量的新语法标准（let），创建函数还是沿用ES5中的function（还会存在变量提升），如果想让函数也不存在变量提升，都使用函数表达式赋值的方式操作：let FN=function()&#123;&#125;//=&gt;创建函数 let xxx=xxx;//=&gt;创建变量 (function()&#123; &#125;)();//=&gt;自执行函数; //=&gt;好处：此时代码中就不要在考虑变量提升了，只要这样处理，没有所谓的变量提升 2、使用let定义的变量不允许在同一个作用域中重复声明 123456789101112131415161718192021222324252627var num2 = 12; var num2 = 13; console.log(num2);//=&gt;13 let str = &apos;你好&apos;; let str = &apos;世界&apos;; console.log(str);//=&gt;Uncaught SyntaxError: Identifier &apos;str&apos; has already been declared 当前报错,上面代码也不会执行(在JS代码执行之前就已经知道有重复声明的了，也就是浏览器依然存在类似于变量提升的机制：在JS代码之前先把所有LET声明的变量过一遍，发现有重复的直接报错) let num = 12; num = 13; console.log(num);//=&gt;13 LET不允许重复被声明，但是允许重新赋值 var att=200; let att=100;//=&gt;Uncaught SyntaxError: Identifier &apos;att&apos; has already been declared 不管你之前使用什么方式在当前作用域中声明的变量，再使用let声明的时候都会报错 let num = 12, fn = function () &#123; let num = 13; &#125;; console.log(num);//=&gt;12 当前作用域下别重复声明即可(不同作用域中的变量是自己私有的,名字重复没有关系) let att = 13, sum = function () &#123; att = 14; &#125;; sum(); console.log(att); //=&gt;let也存在私有变量和作用域链的概念，和ES5中基本上差不多 =&gt;14 3、关于暂时性死区：使用typeof检测一个未被声明过的变量 ES5中返回的结果是undefined但是不报错 ES6中直接报错 1234567&quot;use strict&quot;;console.log(typeof num);//=&gt;undefined 当前变量不存在,但是使用typeof检测的时候,不会提示错误,而是返回undefinedconsole.log(typeof num);//=&gt;Uncaught ReferenceError: num is not defined ES6中检测一个没有被声明过的变量直接报错,不像之前ES5中的值是UNDEFINED一样了let num;console.log(typeof num);//=&gt;undefined 只声明没有定义(赋值),默认值是UNDEFINED 4、ES6语法创建的变量(let)存在块级作用域，ES5语法创建变量(var/function)没有块级作用域 [ES5]window全局作用域，函数执行形成的私有作用域 [ES6]除了有ES5中的两个作用域，ES6中新增加块级作用域（我们可以把块级作用域理解为之前学习的私有作用域：存在私有变量和作用域链的一些机制） ES6语法中把大部分用大括号包起来都称之为块级作用域 12345678910111213let num = 12, str = &apos;&apos;; let fn = function (str) &#123; str = &apos;HELLO&apos;; //console.log(arguments[0]); //=&gt;&quot;HELLO&quot; 当前JS并没有开启严格模式,所以形参变量和ARG存在映射机制(但是我们以后尽量不要这样处理:因为把ES6编译为ES5之后,会默认的开启严格模式,映射机制会中断,此处的值依然是&apos;你好&apos;,这样导致我们的ES6结果和ES5结果不一致) // console.log(num); //=&gt;Uncaught ReferenceError: num is not defined let num = 13; console.log(num, str);//=&gt;13 &quot;HELLO&quot; &#125;; fn(&apos;你好&apos;); console.log(num, str);//=&gt;12 &apos;&apos; 大部分我们遇到的大括号操作都是块级作用域 12345678910111213let num = 12, str = &apos;&apos;; let fn = function (str) &#123; str = &apos;HELLO&apos;; //console.log(arguments[0]); //=&gt;&quot;HELLO&quot; 当前JS并没有开启严格模式,所以形参变量和ARG存在映射机制(但是我们以后尽量不要这样处理:因为把ES6编译为ES5之后,会默认的开启严格模式,映射机制会中断,此处的值依然是&apos;你好&apos;,这样导致我们的ES6结果和ES5结果不一致) // console.log(num); //=&gt;Uncaught ReferenceError: num is not defined let num = 13; console.log(num, str);//=&gt;13 &quot;HELLO&quot; &#125;; fn(&apos;你好&apos;); console.log(num, str);//=&gt;12 &apos;&apos; 块级作用域的增加有什么用？ 12345678910let tempList = document.getElementsByName(&apos;TEMP&apos;); // for (var i = 0; i &lt; tempList.length; i++) &#123; // tempList[i].onclick = function () &#123; //console.log(i);//=&gt;5 怎么点击都是5 异步操作以及作用域链的查找,找到的都是全局下最后一次循环的结束值// &#125;// &#125;//=&gt;自定义属性解决// for (var i = 0; i &lt; tempList.length; i++) &#123;// tempList[i].index = i;// tempList[i].onclick = function () &#123;// console.log(this.index);// &#125;// &#125;//=&gt;闭包解决// for (var i = 0; i &lt; tempList.length; i++) &#123;// ~function (i) &#123;// tempList[i].onclick = function () &#123;// console.log(i);// &#125;// &#125;(i);// &#125;//=&gt;使用ES6的块级作用域for (let i = 0; i &lt; tempList.length; i++) &#123; tempList[i].onclick = function () &#123; console.log(i); &#125; &#125; const的基础语法 const的细节知识点和let一样，和let的主要区别在于：let是创建变量，const是创建常量 变量：值是可以修改的 常量：值不能被修改 12345678let num = 12; num = 13; console.log(num);//=&gt;13 const str = &apos;你好&apos;; str = &apos;世界&apos;; //=&gt;而且使用BABEL如果遇到了CONST设置的常量在进行修改，就无法进行编译了 console.log(str); //=&gt;Uncaught TypeError: Assignment to constant variable. ES6中的解构赋值 结构赋值本身是ES6的语法规范，使用什么关键字来声明这些变量是无所谓的 12345678let [a,b,c] = [12,23,34]; //=&gt;a:12 b:23 c:34 var [d,e,f] = [12,23,34]; //=&gt;d:12 e:23 f:34 [g,h,i] = [12,23,34]; //=&gt;此处相当于给window增加的全局属性 //g:12 h:23 i:34 //=&gt;但是这个操作在JS的严格模式下是不允许的，因为严格模式下不允许出现非使用var/let等声明的变量 多维数组的结构赋值，可以让我们快速获取到需要的结果 123let [,[,A],[,B,[,C]]] = [12, [23, 34], [45, 56, [67, 78]]]; console.log(A, B, C); //=&gt;34 56 78 在解构赋值中，我们可以给某一项设置默认值 1234let [,,,A]=[12, 23, 34]; console.log(A);//=&gt;undefined let [,,,B = 0]=[12, 23, 34]; console.log(B);//=&gt;0 在解构赋值中，支持...xxx的拓展运算符 123456789let [A,...B]=[12, 23, 34, 45, 56]; console.log(A, B);//=&gt;12 [23,34...] let [...C]=[12, 23, 34, 45, 56]; console.log(C);//=&gt;[12,23...] 数组克隆 let [D,...E,F]=[12, 23, 34, 45, 56]; console.log(D, E, F); //=&gt;Uncaught SyntaxError: Rest element must be last element 拓展运算符只能出现在解构赋值中的结构末尾的位置 let [G,,,...H]=[12, 23, 34, 45, 56]; console.log(G, H);//=&gt;12 [45,56] 对象的解构赋值 1234567891011121314151617181920212223242526272829let &#123;name, age&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;; console.log(name, age);//=&gt;&apos;你好&apos; 9 let &#123;A, B&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;; console.log(A, B);//=&gt;在对象的解构赋值中需要注意的是:赋值的变量需要和对象中的属性名吻合,否则无法获取对应的属性值 undefined*2 let &#123;C = 0&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;; console.log(C);//=&gt;0 可以给当前的变量设置默认值 let &#123;name&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;; console.log(name);//=&gt;&apos;你好&apos; 和数组的解构赋值一样,我们可以把后面不需要获取的结构省略掉 let &#123;,age&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;;//=&gt;Uncaught SyntaxError: Unexpected token , 和数组的解构赋值不一样的地方在于,对象前面不允许出现空来占位(因为对象获取需要通过具体的属性名获取,写成空的话,浏览器不知道怎么识别) let &#123;age&#125;=&#123;name:&apos;xxx&apos;,age:&apos;xxx&apos;&#125;;//=&gt;但是我们可以把逗号去掉,这样就是只获取其中一个 let &#123;name, ...arg&#125;=&#123;name: &apos;你好&apos;, age: 9, teacher: &apos;周老师&apos;&#125;; console.log(name, arg); //=&gt;&apos;你好&apos; &#123;age:9...&#125; 支持拓展运算符的 //=&gt;把对象进行浅克隆(只把第一级克隆了) let obj = &#123;name: &apos;xxx&apos;, age: 10, score: [100, 90, 80]&#125;; let &#123;...arg&#125;=obj;console.log(arg, obj); console.log(arg === obj);//=&gt;false console.log(arg.score === obj.score);//=&gt;true let &#123;name:A, age:B&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;; console.log(A, B); //=&gt;&apos;你好&apos; 9 在对象的结构赋值中,我们可以把对象的属性名起一个小名(A和B相当于小名或者叫做别名) 解构赋值的作用 快速交换两个变量的值 123let a = 12;let b = 13; [a, b] = [b, a]; console.log(a, b);//=&gt;13 12 接收函数返回的多个值 12345678let fn = function () &#123; let a = 12, b = 13, c = 14; return [a, b, c]; &#125;; let [a,b,c] = fn(); console.log(a, b, c);//=&gt;12 13 14 在ES6中支持给函数设置默认值 123456789let fn = function (x) &#123; console.log(x);//=&gt;undefined x = x || 0; console.log(x);//=&gt;0&#125;; fn(); let fn2 = function (x = 0) &#123; console.log(x);//=&gt;0 &#125;; fn2(); ES6中的箭头函数箭头函数的基础语法 123456let fn = function (x, y) &#123; return x + y; &#125;; console.log(fn(10, 20)); //=&gt;30//=&gt;改写成箭头函数 let fn = (x, y)=&gt; x + y; 1234567891011let fn = function (n = 0) &#123; let x = 10, y = 20; return x + y + n; &#125;; //=&gt;改写成箭头函数 let arrowFn = (n = 0)=&gt; &#123; let x = 10, y = 20; return x + y + n; &#125;; 箭头函数中不支持arguments 12345678910111213//=&gt;传统函数支持ARGUMENTS// let fn = function () &#123; // let arg = Array.prototype.slice.call(arguments);// return eval(arg.join(&apos;+&apos;));// &#125;; let fn = (...arg)=&gt; &#123; //console.log(arguments); //=&gt;Uncaught ReferenceError: arguments is not defined //=&gt;不支持ARGUMENTS没事,我们使用ES6中的剩余运算符...来获取传递的进来的所有参数值（优势:使用剩余运算符接收到的结果本身就是一个数组，不需要再转换了） //console.log(arg instanceof Array);//=&gt;true return eval(arg.join(&apos;+&apos;)); &#125;; //=&gt;也可以把FN简写成以下方式 //let fn = (...arg)=&gt; eval(arg.join(&apos;+&apos;)); console.log(fn(10, 20, 30, 40)); 箭头函数中的this问题 普通函数中this指向的问题 1234567891011121314151617let obj = &#123; name: &apos;obj&apos;, fn()&#123; //=&gt;这样处理和下面SUM的处理是一样的 console.log(this); &#125;, sum: function () &#123; &#125; &#125;; obj.fn(); //=&gt;this:obj 普通函数执行THIS的指向:看函数执行前面是否有点,有点,点前面是谁THIS就是谁,没有点THIS指向WINDOW或者UNDEFINED(严格模式下) document.body.onclick = obj.fn; //=&gt;this:body setTimeout(obj.fn, 1000); //=&gt;this:window obj.fn.call(12);//=&gt;this:12 箭头函数中没有自己的THIS指向,用到的THIS都是所在宿主环境(它的上级作用域)中的THIS 1234567891011121314151617181920212223let obj = &#123; name: &apos;obj&apos;, fn()&#123; //=&gt;this:obj // setTimeout(function () &#123; // //=&gt;this:window // &#125;, 1000); // setTimeout(function () &#123; // //=&gt;this:obj // &#125;.bind(this), 1000); // var _this = this; // setTimeout(function () &#123; // //=&gt;_this:obj // &#125;, 1000); setTimeout(()=&gt; &#123; //=&gt;this:obj &#125;, 1000); &#125; &#125;;obj.fn(); 宿主环境：不是执行的环境而是定义的环境 12345678910111213let fn = ()=&gt; &#123; console.log(this); &#125;; let obj = &#123; name: &apos;obj&apos;, sum: function () &#123; //=&gt;this:obj fn(); //=&gt;this:window //宿主环境：不是执行的环境而是定义的环境，FN虽然是在这执行的，但是它是在WINDOW下定义的，所以它的宿主环境还是WINDOW &#125; &#125;; obj.sum(); 层级嵌套的箭头函数 1234567// let fn = function (i) &#123; // return function (n) &#123; // return n + (++i); // &#125; // &#125;; let fn = (i)=&gt; (n)=&gt; n + (++i); ES6中的类和继承 ES5中创建类和实例，以及如何禁止用户把类当做普通函数执行：new.target 123456789101112131415161718192021function Person(name, age) &#123; //console.log(new.target);//=&gt;ES6新增加的语法,如果是通过NEW执行的,返回的结果是当前创建的类,如果是当做普通函数执行的,返回的是UNDEFINED if (typeof new.target === &apos;undefined&apos;) &#123; throw new SyntaxError(`当前Person不能作为一个普通函数执行，请使用new Person来执行~~`); &#125; //=&gt;NEW执行的时候,THIS是当前类的实例,THIS.XXX=XXX是给当前实例增加的私有属性 this.name = name; this.age = age; &#125;//=&gt;原型上存放的是公有的属性和方法:给创建的实例使用 Person.prototype = &#123; constructor: Person, say: function () &#123; console.log(`my name is $&#123;this.name&#125;,i am $&#123;this.age&#125; years old~`); &#125; &#125;; //=&gt;把PERSON当做一个普通的对象,给对象设置的私有属性 Person.study = function () &#123; console.log(`good good study,day day up~`); &#125;;var p1 = new Person(&apos;王雪超&apos;, &apos;80&apos;); //不会抛出&quot;当前Person不能作为一个普通函数执行，请使用new Person来执行~~&quot; Person(&apos;王雪超&apos;, &apos;80&apos;); //会抛出错误&quot;当前Person不能作为一个普通函数执行，请使用new Person来执行~~&quot; ES6中创建类 1234567891011121314151617181920//console.log(Person);//=&gt;Uncaught ReferenceError: Person is not defined 不存在变量提升 class Person &#123; constructor(name = &apos;你好&apos;, age = 9) &#123; //=&gt;给实例设置的私有属性 this.name = name; this.age = age; &#125; //=&gt;直接在大括号中编写的方法都设置在类的原型上：ES6默认把CONSTRUCTOR的问题解决了,此时原型上的CONSTRUCTOR指向的就是PERSON say() &#123; console.log(`my name is $&#123;this.name&#125;,i am $&#123;this.age&#125; years old~`); &#125; //=&gt;把PERSON当做普通对象设置属性和方法,只需要在设置的方法前面加STATIC即可 static study() &#123; console.log(`good good study,day day up~`); &#125; &#125;let p1 = new Person(&apos;王雪超&apos;); p1.say() //my name is 王雪超,i am 9 years old~ Person.study() // good good study,day day up~ //Person();//=&gt;Uncaught TypeError: Class constructor Person cannot be invoked without &apos;new&apos; =&gt;ES6中使用CLASS创建的类,天生自带NEW.TARGET的验证,不允许把创建的类当做普通函数执行 ES6中的继承 12345678910111213141516171819202122232425262728293031323334class Person &#123; constructor(...ARG) &#123; let [x = 0,y = 0]=ARG; this.x = x; this.y = y; &#125; sum() &#123; return this.x + this.y; &#125; &#125; class Child extends Person &#123; //=&gt;创建CHILD类,并且让CHILD类继承了PERSON类: //1、把PERSON中的私有属性继承过来设置给了子类实例的私有属性 //2、让子类实例的原型链上能够找到PERSON父类的原型(这样子类的实例就可以调用父类原型上的方法了) //=&gt;我们可以不写CONSTRUCTOR,浏览器默认会创建它,而且默认就把父类私有的属性继承过来了(而且把传给子类的参数值也传递给父类了) // constructor(...arg) &#123; // //=&gt;ARG:传递给子类的参数(数组) [剩余运算符 // super(...arg);//=&gt;[展开运算符] 把ARG中每一项值展开,分别传递给父类方法 SUPER(10,20,30) // &#125; //=&gt;很多时候我们不仅要继承父类私有的,还需要给子类增加一些而外私有的,此时就必须写 CONSTRUCTOR,但是一定要在CONSTRUCTOR中的第一行写上SUPPER,否则会报错 // constructor(...arg) &#123; // super(...arg); // // let [,,z]=arg; // this.z = z; // &#125; constructor(x, y, z) &#123; super();//&lt;=&gt;Person.prototype.constructor.call(this) this.z = z; &#125; fn() &#123; &#125; &#125; let c = new Child(10, 20, 30);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose的简单总结]]></title>
    <url>%2F2017%2F12%2F09%2Fmongoose%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简介Mongoose是MongoDB的一个对象模型工具是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行同时他也是针对MongoDB操作的对象模型库，封装了MongoDB对文档一些增删改等常用方法，让nodeJS操作MongoDB数据库变得更加灵活简。Mongoose,因为封装了MongoDB对文档操作常用的处理方法，让NodeJS操作MongoDB数据库变得更加容易。 安装使用1、 安装mongoose 1npm install mongoose 2、 引用mongoose1var mongoose=require(&quot;mongoose&quot;) 3、使用mongoose连接数据库12345678var mongoose=require(&quot;mongoose&quot;); var db=mongoose.connect(&apos;mongodb://192.168.1.101:27017/test&apos;,&#123;useMongoClient:true&#125;, function (err) &#123; if(err)&#123; console.log(&quot;数据库连接失败！&quot;); &#125;else&#123; console.log(&quot;数据库连接成功！&quot;); &#125; &#125;); 192.168.1.101是本机的IP地址，test是自己建的数据库名称 集合 MongoDB—是一个对象数据库，没有表行等概念，也没有固定的模式和结构，所有的数据以Document(以下简称文档)的形式存储(Document,就是一个关联数组的对象，它的内部由属性组成，它的内部由属性组成，一个属性对应的值可能是一个数，字符串，日期、数组、日期、组成、甚至是一个嵌套的文档。)，后面我们会学习如何创建并插入内容。在MongoDB中，多个Document可以组成Collection（以下简称集合），多个集合可以组成数据。 文档–是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象，同时他也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。集合–由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么集合相当于一张表。如果我们通过MongoDB去创建一个集合并对其进行增删改查，该怎么实现呢，到这里我们就先了解Schema(数据属性模型)Model、Entity。 Schema简述 Schema——一种以文件的形式存储的数据模型架构，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅是数据库模型在程序片段的一种表现，可以说是数据属性模型(传统意义的表结构)，又或者是”集合”的模型骨架。代码如下: 123456var PersonSchema=new mongoose.Schema(&#123; name:&#123;type:String&#125;, age:&#123;type:Number,default:0&#125;, time:&#123;type:Date,default:Date.now&#125;, email:&#123;type:String,default:&quot;&quot;&#125; &#125;); 基本属性类型有:字符串、日期型、数值型、布尔型(Boolean)、null、数组、内嵌文档等。 Model简述 Model–由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库的属性，行为的类。 如何通过Schema来创建Mode呢，如下实例 1var db=mongoose.connect(&quot;mongodb://192.168.1.103:27017/test&quot;); 创建Model 1var PersonModel=db.model(&quot;person&quot;,PersonSchema); person:数据库中集合的名称，当我们对其添加数据时如果person已经存在，则会保存到其目录下，如果未存在，则会创建person集合，然后保存数据。拥有了Model,我们也就拥有了操作数据库的能力如果你想对某个集合有所作为，那就交给Model来处理吧，创建一个Model模型，我们需要指定:&emsp;1、集合名称&emsp;2、集合的Schema结构对象，满足这两个条件，我们就可以操作数据库了 、 Entity简述 Entity—由Model创建的实体，使用save方法保存数据，Model和Entity都能影响数据库的操作，但Model比Entity更具操作性。 使用Model创建Entity,如下实例： 1234567var PersonEntity=new PersonModel(&#123; name:&quot;zhangsan&quot;, age:6, email:&quot;zhangsan.com&quot; &#125;); console.log(PersonEntity.name);//zhangsan console.log(PersonEntity.age);//6 创建成功之后，Schema的属性就变成了Model和Entity的公有属性了 基础操作查询查询分为很多种类型，入条件查询，过滤查询等等，今天只学习最基本的，现在先来看最基本的find查询 1、find查询:obj.find(查询条件，callback); 1234567891011PersonModel.find(&#123;&#125;,function(error,docs)&#123; //没有向find传递参数，默认的是显示所有文档 &#125;); PersonModel.find(&#123;&quot;age&quot;:6&#125;,function(error,docs)&#123; if(error)&#123; console.log(&quot;error:&quot;+error); &#125;else&#123; console.log(docs);//docs:age为6的所有文档 &#125; &#125;); Model保存方法 Model提供了一个create方法来对数据进行保存，下面我们来看一下实例: Model.create(文档数据,callback); 1234567PersonModel.create(&#123;name:&quot;test&quot;,age:7&#125;,function(error,doc)&#123; if(error)&#123; console.log(error); &#125;else&#123; console.log(doc); &#125; &#125;); entity保存方法 entity也提供的对数据的保存方法和Model提供保存方法类似 Entity.save(文档数据,callback); 12345678var PersonEntity=new PersonModel(&#123;name:&quot;test&quot;,age:9&#125;); PersonEntity.save(function(error,doc)&#123; if(error)&#123; console.log(error); &#125;else&#123; console.log(doc); &#125; &#125;); model调用的是create方法，entity调用的是save方法 数据更新实例:Model.update(查询条件，更新对象，callback); 123456789var condition=&#123;name:&quot;Zhangsan&quot;&#125;; var update=&#123;$set:&#123;age:100&#125;&#125;; PersonModel.update(condition,update,function(error)&#123; if(error)&#123; console.log(error); &#125;else&#123; console.log(&apos;Update success&apos;); &#125; &#125;)； 更新后find()一下，此时数据已经修改成功 了!请注意如果匹配到多条记录，默认只更新一条， 如果要更新匹配到所有记录的话需要加一个参数{multi:true}。 123456789var condition=&#123;name:&quot;Zhangsan&quot;&#125;; var update=&#123;$set:&#123;age:100&#125;&#125;; PersonModel.update(condition,update,&#123;multi:true&#125;,function(error)&#123; if(error)&#123; console.log(error); &#125;else&#123; console.log(&apos;Update success&apos;); &#125; &#125;); 删除数据实例：Model.remove(查询条件，callback); 12345678var condition=&#123;name:&quot;Zhangsan&quot;&#125;; PersonModel.remove(conditions,function(error)&#123; if(error)&#123; console.log(error); &#125;else&#123; console.log(&quot;Delete success&quot;); &#125;; &#125;); 和update类似吧，有了remove方法我们就可以呀进行删除操作了。 简单查询简介查询就是返回一个集合中的文档的子集，Mongoose模型提供了find、findOne、和findById方法用于文档查询我们这里先添加一些数据; 123456789101112131415161718PersonModel.create([ &#123;name:&apos;name1&apos;,age:1&#125;, &#123;name:&apos;name2&apos;,age:2&#125;, &#123;name:&apos;name3&apos;,age:3&#125;, &#123;name:&apos;name4&apos;,age:4&#125;, &#123;name:&apos;name5&apos;,age:5&#125;, &#123;name:&apos;name6&apos;,age:6&#125;, &#123;name:&apos;name7&apos;,age:7&#125;, &#123;name:&apos;name8&apos;,age:8&#125;, &#123;name:&apos;name9&apos;,age:9&#125;, &#123;name:&apos;name10&apos;,age:10&#125;],function(error,docs)&#123; if(error)&#123; console.log(error); &#125;else&#123; console.log(&quot;save ok&quot;); &#125;&#125;); 属性过滤find(Condition,field,callback);field省略或为Null,则返回所有属性 1234//返回只包好name,age两个键的所有记录 PersonModel.find(&#123;&#125;,&#123;name:1,age:1,_id:0&#125;,function(err,docs)&#123; //docs 查询结果集 &#125;); 说明:我们只需要把显示属性设置为大于零的数就可以了，当然1是最好理解的，_id是默认返回，如 果不要显示加上(&quot;_id&quot;:0),但是，对其他不需要显示的属性且不是_id,如果设置为0的话将会抛出 异常或查询无果。 findOne查询单条 返回查询结果1、单条数据 findOne(Conditions,callback); 1234PersonModel.findOne(&#123;age:6&#125;,function(err,doc)&#123; //查询符合age等于6的第一条数据 //doc是查询结果 &#125;); findById(按ID单条数据)，与findOne相同，但它只接收文档的_id作为参数，返回单个文档。1、按ID单条数据findById(_id,callback); 123PersonModel.findById(person._id,function(err,doc)&#123; //doc 查询结果文档 &#125;); 高级查询$gt(大于)、$lt(小于)查询时我们经常会碰到要根据，某些字段进行条件筛选查询，比如说Number类型，怎么办了，我们可以使用$gt、$lte(&lt;=),$gte(&gt;=)操作进行排除性查询，如下示例： 123456789Model.find(&#123;&quot;age&quot;&#125;:&#123;&quot;$gt&quot;:6&#125;,function(error,docs)&#123; //查询所有age大于6的数据 &#125;); Model.find(&#123;&quot;age&quot;:&#123;&quot;$lt&quot;:6&#125;&#125;,function(error,docs)&#123; //查询所有age小于6的数据 &#125;); Model.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:6,&quot;lt&quot;:9&#125;&#125;,function(error,docs)&#123; //查询所有age大于6小于9的数据 &#125;); $ne(不等于) $ne(!=)操作符的含义相当于不等于、不包含，查询时我们可通过它进行条件判定: 123Model.find(&#123;&quot;age&quot;:&#123;&quot;$ne&quot;:6&#125;&#125;,function(error,docs)&#123; //查询所有age不等于6的数据 &#125;); $ne可以匹配单个值，也可以匹配不同类型的值 $in(包含) 和$ne操作符相反，$in相当于包含、等于、查询时查找包含于指定字段条件的数据，具体使用方法如下: 1234567Model.find(&#123;&quot;age&quot;:&#123;&quot;$in&quot;:6&#125;&#125;,function(error,docs)&#123; //查询所有age等于6的数据 &#125;); Model.find(&#123;&quot;age&quot;:&#123;&quot;$ne&quot;:[6,7]&#125;&#125;,function(error,docs)&#123; //可以把多个值组织成一个数组 &#125;); $or(或者)$or操作符，可以查询多个键值的任意给定值，只要满足其中一个就可返回，用于存在多个条件判定的情况下使用，如下示例: 123Model.find(&#123;&quot;$or&quot;:[&#123;&quot;name&quot;:&quot;name1&quot;&#125;,&#123;&quot;age&quot;:6&#125;]&#125;,function(error,docs)&#123; //查询name为name1或age为6的全部文档 &#125;); $exists(是否存在)$exists操作符，用于判断某些关键字是否存在来进行条件查询，如下示例: 1234567Model.find(&#123;name:&#123;$exists:true&#125;&#125;,function(error,docs)&#123; //查询所有存在name的文档 &#125;); Model.find(&#123;email:&#123;$exists:false&#125;&#125;,function(error,docs)&#123; //查询所有不存在email的文档 &#125;); 游标操作简介数据库用游标返回find的执行结果，客户端对游标的实现通常能够对最终的结果进行有效的控制，可以限制结果的数量，略过部门结果，根据任意键任意顺序的组合对结果进行各种排序，或者是执行其他操作 最常用的选项查询就是限制返回结果的数量(limit函数)、忽略一点数量的结果(skip函数)以及排序(sort函数)，通过它来限制结果数量 limit函数的基本用法在查询操作中，有时数据量会很大，这时我们就需要对返回结果的数量进行限制，那时我们就可以使用limit函数，通过它来限制结果数量1、限制数量:find(Condition,fields,options,callback); 123Model.find(&#123;&#125;,null,&#123;limit:20&#125;,function(err,docs)&#123; console.log(docs) &#125;); 如果匹配到的结果不到20个，则返回匹配数量的结果，也就是说limit函数指定的是上限而非下限 skip函数的基本用法skip和limit类似，都是对返回结果的数量进行操作，不同的是skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果，如下实例:1、跳过数量:find(Conditions,fields,options,callback); 123Model.find(&#123;&#125;,null,&#123;skip:4&#125;,function(err,docs)&#123;console.log(docs)&#125;); 如果查询结果数量中少于4个的话，则不会返回任何结果。 sort函数基本用法sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键值对，键代表排序键名，值代表排序的方向1是升序，-1是降序。1、结果排序:find(Conditions,fields,options,callback); 123Model.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;,function(err,docs)&#123; //查询所有的数据，并按照降序顺序返回数据docs &#125;); sort函数可以根据用户自定义条件有选择性的来进行排序显示数据结果 扩展方法ObjectId简述 存储的mongodb集合的中的每个文档(document)都有一个默认的主键，这个主键的名称是固定的，他可以是mongodb支持的任何数据类型，默认是ObjectId,该类型的值由系统自己生成，从某种意义上集合不会重复： MySQL等关系数据可的主键都是自增的，但在分布式的环境下，这种方法就不可行了，会产生冲突，为此，MongoDB采用了一个称之为Objectid的类型做主键，Objectid是一个12字节的BSON类型的字符串，按照字节排序，依次代表 4字节：UNIX时间戳 3字节：运行mongoDB的机器 2字节:表示生成此_id的进程 3字节:由一个随机开始的计数器生成的值 12var mongoose=require(&quot;mongoose&quot;); var personSchema=new mongoose.Schema(&#123;&#125;);//默认_id:ObjectId类型 每一个文档都有一个特殊的键”_id”,这个键在文档所属的集合中是唯一的。Shema添加属性值:前面我们已经讲述了如何如何定义了一个Schema并赋予某些属性值，那能不能先定义后添加属性了，答案是可以的，如下所示： 123var mongoose=require=require(&quot;mongoose&quot;); var PersonSchema=new mongoose.Schema; PersonSchema.add(&#123;name:&quot;String&quot;,email:&quot;String&quot;,age:&quot;Number&quot;&#125;); 实例方法:有的时候，我们需要创造的Schema不仅要为后面的Model和Entity提供公共属性，还要提供公共方法，那怎么在Schema下创建一个实例方法了，请看实例: 12345678var mongoose=require(&quot;mongoose&quot;); var PersonSchema=new mongoose.Schema(&#123;name:String&#125;); PersonSchema.method(&apos;greet&apos;,function()&#123; console.log(&quot;how are you&quot;); &#125;); var Person=mongoose.model(&apos;person&apos;,PersonSchema); var person=new Person(); person.greet();//how are you Schema静态方法如下实例； 123456789101112131415var mongoose=require(&quot;mongoose&quot;); var db=mongoose.connect(&quot;mongodb://192.168.1.103:27017/test&quot;); var PersonSchema=new mongoose.Schema(&#123; name:&#123;type:String&#125;, age:&#123;type:Number,default:0&#125;, &#125; ); PersonSchema.static(&quot;findByName&quot;,function(name,callback)&#123; return this.find(&#123;name:name&#125;,callback) &#125;); var PersonModel=db.model(&quot;person&quot;,PersonSchema); PersonSchema.findName(&quot;zfpx&quot;,function(err,docs)&#123; //docs所有名字叫zfpx的结果集 &#125;);]]></content>
      <categories>
        <category>Node.js</category>
        <category>mongoDB</category>
        <category>Mongose</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>mongoDB</tag>
        <tag>Mongose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码解读和常用方法]]></title>
    <url>%2F2017%2F11%2F25%2FjQuery%2F</url>
    <content type="text"><![CDATA[JQ的版本和下载jQuery (JQ) 的版本1.x：兼容IE6~8浏览器，是目前PC端开发常用的类库2.x / 3.x：不支持IE6~8的兼容了，目前市场上应用的特别少 (移动端开发一般我们都用zepto.js) jquery-1.9.1.min.js jquery-1.11.3.min.js jquery.min.js … 下载JQ 官网下载：http://jquery.com/GitHub：https://github.com/jquery/jquery 下载JQ的源码进行学习和分析百度搜索或者在 http://code.jquery.com/jquery-1.11.1.min.js （地址后面放入的是对应的JQ的版本号） 基于NODE的NPM包管理器也可以下载JQ：1npm view jquery &gt; jquery.version.json 1npm install jquery //下载最新版本JQ 1npm install jquery@1.11.3 //下载指定版本JQ JQ的核心原理解读JQ是一个常用方法类库（常用的DOM库），提供了很多真实项目开发中需要使用的属性和方法（这些方法JQ已经帮我们完善了浏览器兼容处理以及一些细节的优化）,jQuery本身是一个类JQ是基于构造函数模式构建的类库. JQ的选择器 var jQuery=function(selector,context){ return new jQuery.fn.init(selector, context); }; jQuery.fn=jQuery.prototype={ jquery:version, constructor:jQuery, ... }; ... init=jQuery.fn.init=function(selector, context){ if(typeof selector==&quot;string&quot;){ ... }else if(selector.nodeType){ ... }else if(jQuery.isFunction(selector)){ ... } return jQuery.makeArray(selector,this ); //=&gt;返回的是一个类数组 } init.prototype=jQuery.fn; ... window.jQuery=window.$=jQuery; 当我们在JS中执行：$()或jQuery()，都是在创建一个JQ类的实例（$===jQuery），这些实例都是一个类数组（我们把这个类数组称之为JQ对象），JQ的实例可以使用JQ原型上提供的公有的属性和方法。我们之所以把$()称之为JQ的选择器，因为执行这个方法可以传递一个selector参数进去，通过selector我们可以获取到需要操作的DOM元素集合（JQ类数组集合）；传递的第二个参数context它是当前获取元素的上下文（不传递默认是document，如果传递，我们传递一个JS元素对象即可）但是把它叫做JQ选择器有点笼统，因为传递的selector支持三种格式： 传递的是个字符串，就是我们所谓的选择器，能够通过选择器获取到元素 传递的是个元素对象，它的意思是把JS原生对象转换为JQ对象 传递的是个函数，它代表等DOM结构加载完成在执行对应的JS代码（类似于window.onload $===jQuery //=&gt;true $()===jQuery() //=&gt;false 不同实例 $() instanceof jQuery //=&gt;true var $example=$(); //=&gt;我们用JQ选择器获取的值，一般都是用以$开头的变量名来存储（以后看见变量名是以$开头的，我们就知道是JQ获取的实例[JQ对象]） 第一个参数[selector]传递的是一个字符串，就是通过选择器获取需要的元素集合（获取的结果怎么着都是类数组集合：获取多个元素也就是索引多点，获取一个元素也就是只有索引0，一个都没获取到就是一个空的类数组集合[而不是null]）,一般CSS或者CSS3中支持的选择器，JQ都支持。 //=&gt;基本选择器 $(&apos;#xxx&apos;) $(&apos;.xxx&apos;) $(&apos;xxx&apos;) $(&apos;*&apos;) $(&apos;.xxx,#xxx&apos;) //=&gt;后代选择器 $(&apos;.box a&apos;) $(&apos;.box&gt;a&apos;) //$(&apos;.box~a&apos;) //$(&apos;.box+a&apos;) 不常用 //=&gt;伪类选择器 $(&apos;.box:contains(xxx)&apos;) 包含某某某内容的 $(&apos;a:first&apos;) $(&apos;a:last&apos;) $(&apos;a:eq(1)&apos;) 索引为1的 $(&apos;a:gt(1)&apos;) 索引大于1的 $(&apos;a:lt(10)&apos;) 索引小于10的 $(&apos;a:not()&apos;) 不包含什么的 $(&apos;a:not(:gt(5))&apos;) 获取所有的a，但是不包含索引大于5的（前六个） ... JQ对象和原生JS对象转换 JQ对象：通过$()获取的JQ实例(类数组) 原生JS对象：通过ES中提供的属性或者方法获取的JS元素对象(nodeType===1) 把JQ对象转换为原生JS对象: var oBox=document.getElementById(&apos;box&apos;); //=&gt;原生JS对象//oBox.addClass(); //=&gt;报错：oBox不是JQ对象，不能使用JQ原型上的方法 var $box=$(oBox); //=&gt;把原生JS对象转换为JQ对象 $box.addClass(&apos;bg&apos;); 把JQ对象转换为原生JS对象 var $body=$(&apos;body&apos;); //$body.className //=&gt;undefined，因为className是JS原生内置的属性，JQ对象不能直接的用 //$body[索引]：在集合中获取指定索引的内容（获取的内容就是原生JS对象） //$body.get(索引)：等价于 $body[索引]，获取指定索引位置的元素（原生JS对象）//$body.eq(索引)：获取指定索引位置的元素对象（获取的结果还是一个新的JQ对象） selector是一个方法 $(function(){ //=&gt;当页面中的DOM结构加载完成，就会执行回调函数中的JS代码 //=&gt;类似于window.onload：等到页面中的DOM结构以及资源文件都加载完成才会执行对应的JS代码 }); $(document).ready(function(){ //=&gt;这种写法和上面的写法一模一样 }); 和window.onload不太一样 $(function(){}) 可一在同一个页面中使用多次，多次都生效（所以在使用JQ完成代码的时候，我们一般都会把代码放在回调函数中：首先不仅是等到结构加载完在执行，而且还形成了一个闭包）原理：利用了DOM二级事件绑定(可以执行多次)，监听的是DOMContentLoaded事件(DOM结构加载完成就会触发执行) window.onload本身就是资源都加载完成才会执行，使用的是DOM零级事件绑定，在同一个页面中只能使用一次window.onload=function()…window.onload=function()…只能留最后一个，最后一次赋值替换了原有赋值 JQ即是一个类也是一个对象 jQuery.prototype上设置了很多的属性和方法，这些是供JQ实例（DOM集合或者DOM元素）使用 的属性和方法: addClass css removeClass attr … jQuery也是一个普通的对象，在对象上也有一些自己的属性和方法（和实例没有任何的关系）, 这些都是工具类的方法: ajax isFunction unique … jQuery.prototype $(&apos;#box&apos;).index()：获取当前元素的索引（是在自己兄弟元素中的索引，它有几个哥哥，索引 就是几） $(&apos;body&apos;).data(key,value) 只传递key是获取 如果传递了value是设置 我们通过这个方法可以获取到在HTML结构上设置的data-xxx的自定义属性值 //&lt;body data-index=&apos;12&apos;&gt;&lt;/body&gt; //$(&apos;body&apos;).data(&apos;index&apos;) =&gt;12 $(&apos;#box&apos;).attr()：设置或者批量设置或者获取当前元素的自定义属性(内置属性也可以) 叫做removeAttr $(&apos;#box&apos;).prop()：和attr一样也是操作元素属性的，但是prop一般都操作表单元素的内置或 者自定义属性 removeProp addClass：增加样式类 removeClass：移除样式类 toggleClass：当前样式类有就是移除，没有就是增加 hasClass：验证是否存在某个样式类名 $(&apos;#box&apos;).html([val])：不传val就是获取内容，传递val就是设置内容，等价于原生的 innerHTML。 $(&apos;input&apos;).val([val])：表单元素value值的操作(设置或者获取) css：设置或者批量设置或者获取元素的样式（获取的结果没有去单位） offset()：获取距离BODY的偏移 position()：获取距离父级参照物的偏移 scrollTop/scrollLeft([val])：获取或者设置当前元素卷去的高度或者宽度 height/width([val]) innerWidth/innerHeight()：等价于clientWidth/clientHeight outerWidth/outerHeight()：等价于offsetWidth/offsetHeight $(&apos;#box&apos;).on(&apos;click&apos;,function...)：JQ中的事件绑定 ... $(&apos;#box&apos;).remove()：把当前盒子在容器中移除 $(&apos;#box&apos;).clone(true)：把当前盒子深度克隆一份 filter children find ... 写在对象上的方法 var j=$.noConflict()：如果当前项目中引入了两个类库，都是使用$操作的，为了防止$使用权的冲突，JQ做了一个处理，可以让我们转让$的使用权；此处返回的值j就是代表原始$的变量，以后可以使用j()执行（使用jQuery()执行也可以）var j=$.noConflict(true)：深度转让，把jQuery和$的使用权都转让了，此时只能使用j()执行了$.ajax()：帮助我们发送ajax请求… 筛选方法 var $links=$(&apos;a&apos;); $links.filter(&apos;.bg&apos;); //=&gt;首先获取所有的A，在所有的A中把具备样式类为bg的获取到（二次筛选） $(&apos;#box&apos;).children(&apos;a&apos;); //=&gt;首先获取#box所有的子元素，在所有子元素中筛选出标签名为a的元素集合 &lt;=&gt; $(&apos;#box&gt;a&apos;) $(&apos;#box&apos;).find(&apos;.bg&apos;); //=&gt;首先获取#box后代中所有的元素，在所有的元素中筛选出样式类名中具备bg的元素集合 &lt;=&gt; $(&apos;#box .bg&apos;) //prev：获取上一个哥哥 $(&apos;#box&apos;).prev(&apos;a&apos;) //prevAll：所有的哥哥 //next：下一个弟弟 //nextAll：所有的弟弟 //siblings：所有的兄弟 //parent：父亲元素 //parents：所有的祖先元素（一直到html为止） ... each JQ中的each有三种: 写在原型上的each：遍历JQ对象中的每一项 写在对象上的each：工具方法，可以用来遍历数组、类数组、对象等 内置的each其实也是调用原型上的each处理的，只不过JQ在处理的时候会内部自己调用 //=&gt;内置EACH$(&apos;a&apos;).addClass(&apos;select&apos;); //=&gt;我们获取的A可能有很多个，执行一次addClass，相当于给每个获取的A都增加了一个叫做select的样式类（JQ中大部分方法在执行的时候，都会把获取的JQ集合中的每一项调用each进行遍历，把需要操作的任务对每一个遍历的元素进行操作） $(&apos;a&apos;).css(&apos;width&apos;); //=&gt;获取的时候只返回第一个元素的样式（设置走内置EACH批量处理，获取只处理第一个） //=&gt;原型上的EACH$(&apos;a&apos;).each(function(index,item){ //=&gt;传递参数的顺序和数组内置的forEach顺序相反：ary.forEach(function(item,index) {...}); //=&gt;获取的A有多少个，回调函数被触发执行多少次：index当前遍历这一项的索引 item是当前遍历这一项的内容 //=&gt;this -&gt; item (原生JS对象) 方法中的this是当前遍历的这一项 //=&gt;$(this) 也是当前遍历这一项，但是属于JQ对象}); //=&gt;JQ对象上提供的工具方法：each$.each([数组/类数组], function(index,item) { //=&gt;this:item}); $.each([对象],function(key,value){ //=&gt;this:value //=&gt;JQ也是采用for in循环用来遍历对象的，这样的话就存在可能把公有属性和方法遍历到的问题 if([对象].hasOwnProperty(key)){ } }); extend $.extend()：把方法扩展到JQ对象上，这个操作一般是用来完善类库的 $.fn.extend()：把方法扩展到JQ的原型上，供JQ的实例（DOM集合）使用，这个操作一般是用来写JQ插件的 //=&gt;扩展工具方法，用来完善类库 $.extend({ aa:function(){} }); $.aa(); //=&gt;扩展到原型上供实例调用的 $.fn.extend({ bb:function(){ //=&gt;this:操作当前这个方法的JQ实例（JQ对像），此处不需要再$(this)转换为JQ对像 } }); $(&apos;xxx&apos;).bb(); animate JQ中提供了元素运动的动画库: stop：结束当前元素正在运行的动画，继续执行下一个新动画（一般我们实现动画,stop方法基 本上必然执行） finish：和stop类似，finish需要让元素立即运动到上一个动画的目标位置，从目标位置执行 下一个动画，而stop是从上一个动画停止的位置执行下一个动画 animate([target],[duration],[effect],[callBack])： [target] 对象 [duration] MS [effect] linear、ease、ease-in、ease-out、ease-in-out [callBack] 回调函数，动画结束做的事情 show(1000/‘fast’/‘slow’) hide toggle fadeIn fadeOut fadeToggle slideUp slideDown slideToggle …]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[buffer基础知识]]></title>
    <url>%2F2017%2F11%2F19%2Fbuffer%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Buffer 类是一个全局变量类型，用来直接处理2进制数据的，JS语言自身只有字符串数据类型，没有二进制数据类型，而在处理TCP和文件流的时候，必须要处理二进制数据，NodeJS提供Buffer对象来对二进制数据的操作。 创建Buffer实例使用Buffer.from(), Buffer.alloc(), Buffer.allocUnsafe()等方法来创建一个Buffer实例，6.0版本以前直接使用构造函数创建的方法new Buffer()已被丢弃，不推荐使用，因为有可能会造成内存泄漏。 Buffer.from(value,[…]) Buffer.from(value,[…])在转换到时候分为四种情况：1、第一，value为16进制数组，将数组转化为buffer，如果不是16进制，则会进行转换，代码如下： 12var buf = Buffer.from([2,9,7,8,17]); console.log(buf);//&lt;Buffer 02 09 07 08 11&gt; 2、value为字符串，则转换字符串为buffer，该方法会使用buffer池，代码如下: 12var buf = Buffer.from(&apos;hello&apos;); console.log(buf);//&lt;Buffer 68 65 6c 6c 6f&gt; 3、value为buffer实例，则将value拷贝至新的buffer中，这里只是值的拷贝，不会共享内存，代码如下； 1234567var buf1 = Buffer.from(&apos;hello&apos;); var buf2= Buffer.from(buf1); console.log(buf1);//&lt;Buffer 68 65 6c 6c 6f&gt; console.log(buf2);//&lt;Buffer 68 65 6c 6c 6f&gt; buf2[0]=0x56; console.log(buf1);//&lt;Buffer 68 65 6c 6c 6f&gt; console.log(buf2);//&lt;Buffer 56 65 6c 6c 6f&gt; 4、value为arrayBuffer时，还有两个可选参数（value,byteOffset，length），byteOffset指定从arrayBuffer开始复制的位置，length复制的长度，代码如下； 12345var arr = new Uint8Array(2); arr[0] = 69; arr[1] = 67; var buf = Buffer.from(arr.buffer,0,2); console.log(buf);//&lt;Buffer 45 43&gt; 注意:如果引用的是arr.buffer，则新创建的buffer， buf与arr共享内存,任意改变buf和arr另一个随之改变，代码验证如下： 123456789101112var arr = new Uint8Array(2); arr[0] = 69; arr[1] = 67; var buf = Buffer.from(arr.buffer); console.log(buf);//&lt;Buffer 45 43&gt; console.log(arr);//Uint8Array [ 69, 67 ] buf[0]=123; console.log(buf);//&lt;Buffer 7b 43&gt; console.log(arr);//Uint8Array [ 123, 67 ] arr[0]=88; console.log(buf);//&lt;Buffer 58 43&gt; console.log(arr);//Uint8Array [ 88, 67 ] Buffer.alloc(size, fill, encoding) Buffer.alloc(size, fill, encoding)，参数含义如下： size，指定buffer的长度，但不能超过buffer.kMaxLength，若不是数字则报错 fill，指定初始化buffer的值，默认为0 encoding，如果fill是字符串，则该参数指定fill的编码 代码如下所示： 12345678var buf1=Buffer.alloc(5); console.log(buf1);//-&gt;&lt;Buffer 00 00 00 00 00&gt; var buf2=Buffer.alloc(5,&apos;hello&apos;,&apos;base64&apos;); console.log(buf2);//-&gt;&lt;Buffer 85 e9 65 85 e9&gt; var buf3=Buffer.alloc(5,&apos;hello&apos;).toString(); console.log(buf3);//-&gt;hello var buf4=Buffer.alloc(5,&apos;hello&apos;); console.log(buf4);//-&gt;&lt;Buffer 68 65 6c 6c 6f&gt; Buffer.allocUnsafe(size)Buffer.allocUnsafe(size),size参数指定buffer的大小，该方法返回一个没有初始化的buffer，因此可能还保留有敏感的数据，造成信息的泄漏，建议使用buffer.fill(0)函数初始化buffer，该方法与Buffer.alloc(size, fill)是不一样的，有可能使用8KB池。代码如下： 1234var buf1=Buffer.allocUnsafe(5); console.log(buf1);//-&gt;&lt;Buffer 02 00 00 00 bf&gt; buf1.fill(0); console.log(buf1);//-&gt;&lt;Buffer 00 00 00 00 00&gt; Buffer.allocUnsafeSlow(size)Buffer.allocUnsafeSlow(size)，参数含义同上，该方法不会使用Buffer池，容易造成内存的浪费；代码如下： 1234var buf1=Buffer.allocUnsafeSlow(5); console.log(buf1);//-&gt;&lt;Buffer 48 37 4b 64 bc&gt; buf1.fill(0); console.log(buf1);//-&gt;&lt;Buffer 00 00 00 00 00&gt; buffer解码使用buf.toString([encoding[, start[, end]]])方法将buffer转换成字符串，encoding指定字符编码，默认为’utf8’，start开始位置，end结束位置（不包括），目前encoding只支持’ascii,utf8,utf16le,ucs2,base64,latin1,binary,hex’，使用如下所示： 12345var buf = Buffer.from(&apos;hello&apos;); console.log(buf.toString(&apos;base64&apos;));//aGVsbG8= console.log(buf.toString(&apos;utf8&apos;));//hello console.log(buf.toString(&apos;utf8&apos;,2,6));//llo console.log(buf.toString(&apos;hex&apos;));//68656c6c6f buffer拼接、复制、填充、分割‘填充’ 方法buf.fill(value[, offset[, end]][, encoding])使用指定的值填充buffer，参数offset指定填充的起始位置，end为结束位置，使用如下所示： 1234console.log(Buffer.allocUnsafe(5).fill(&apos;a&apos;,0,5,&apos;base64&apos;));//&lt;Buffer 78 d3 d0 75 68&gt; console.log(Buffer.allocUnsafe(5).fill(&apos;a&apos;,0,5,&apos;utf8&apos;));//&lt;Buffer 61 61 61 61 61&gt; console.log(Buffer.allocUnsafe(5).fill(&apos;a&apos;).toString(&apos;utf8&apos;));//aaaaa console.log(Buffer.allocUnsafe(5).fill(&apos;a&apos;,2,5).toString(&apos;utf8&apos;));// aaa 拼接 方法Buffer.concat(list[, totalLength])将多个buffer合并在一起，并返回一个新的buffer实例，参数totalLength为指定的buffers的长度总和，如果不提供该值，函数内部会循环去获取每一个buffer的长度，然后进行拼接，因此为了速度，最好指定一个总长度，使用如下： 123456789101112function bufferInjoin(buffArr)&#123; var len = 0; buffArr.forEach(function(buff,index,arr)&#123; len+=buff.length; &#125;); var buffer = Buffer.concat(buffArr,len); return buffer; &#125; var buff = bufferInjoin([Buffer.from(&apos;hehe&apos;),Buffer.allocUnsafe(5).fill(&apos;a&apos;)]); console.log(buff);//&lt;Buffer 68 65 68 65 61 61 61 61 61&gt; console.log(buff.length);//9 console.log(buff.toString());//heheaaaaa 复制方法buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])可以实现buf到target的复制，参数含义如下： target，复制目标 targetStart，复制目标开始被覆盖的位置 sourceStart，复制源开始复制的位置 sourceEnd，复制源复制结束的位置 使用如下所示：1234const buf1 = Buffer.from(&apos;hello world!&apos;); const buf2 = Buffer.allocUnsafe(5).fill(&apos;x&apos;); buf1.copy(buf2,0,0,5); console.log(buf2.toString());//hello 分割方法buf.slice([start[, end]])可以分割buffer，返回一个新的buffer，但是仍然是引用原buffer，因此改变原buffer数据，该新buffer也会跟着改变，如果参数start，end为负数，则先要加上buffer的长度再进行计算，如下所示： 1234567const buf1 = Buffer.from(&apos;hello world.&apos;); const buf2 = buf1.slice(0); console.log(buf2);//&lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64 2e&gt; buf2[0] = 88; console.log(buf1);//&lt;Buffer 58 65 6c 6c 6f 20 77 6f 72 6c 64 2e&gt; const buf3 = buf1.slice(-6,-1); console.log(buf3.toString());//world buffer读写 buf.write(string[, offset[, length]][, encoding])，向buffer写入字符串 1234var buf=Buffer.alloc(10); buf.write(&quot;hello&quot;,2,7,&apos;utf8&apos;); console.log(buf);//-&gt;&lt;Buffer 00 00 68 65 6c 6c 6f 00 00 00&gt; console.log(buf.read());//-&gt;&lt;Buffer 00 00 68 65 6c 6c 6f 00 00 00&gt; buffer写操作通过write开头的写api来完成，主要有以下这些： 12345678910111213141516171819buf.write(string[, offset[, length]][, encoding])，向buffer写入字符串 buf.writeDoubleBE(value, offset[, noAssert])写入64位浮点型数字，大端对齐 buf.writeDoubleLE(value, offset[, noAssert])，写入64位浮点型数字，小端对齐 buf.writeFloatBE(value, offset[, noAssert])，写入32位浮点型数字，大端对齐 buf.writeFloatLE(value, offset[, noAssert])，写入32位浮点型数字，小端对齐 buf.writeInt8(value, offset[, noAssert])，写入有符号8位整型数字 buf.writeInt16BE(value, offset[, noAssert])，写入有符号16位整型数字，大端对齐 buf.writeInt16LE(value, offset[, noAssert])，写入有符号16位整型数字，小端对齐 buf.writeInt32BE(value, offset[, noAssert])，写入有符号32位整型数字，大端对齐 buf.writeInt32LE(value, offset[, noAssert])，写入有符号32位整型数字，小端对齐 buf.writeIntBE(value, offset, byteLength[, noAssert])，以下便不再累述 buf.writeIntLE(value, offset, byteLength[, noAssert]) buf.writeUInt8(value, offset[, noAssert]) buf.writeUInt16BE(value, offset[, noAssert]) buf.writeUInt16LE(value, offset[, noAssert]) buf.writeUInt32BE(value, offset[, noAssert]) buf.writeUInt32LE(value, offset[, noAssert]) buf.writeUIntBE(value, offset, byteLength[, noAssert]) buf.writeUIntLE(value, offset, byteLength[, noAssert]) buffer写操作通过read开头的写api来完成，主要有以下这些： 123456789101112131415161718buf.readDoubleBE(offset[, noAssert]) buf.readDoubleLE(offset[, noAssert]) buf.readFloatBE(offset[, noAssert]) buf.readFloatLE(offset[, noAssert]) buf.readInt8(offset[, noAssert]) buf.readInt16BE(offset[, noAssert]) buf.readInt16LE(offset[, noAssert]) buf.readInt32BE(offset[, noAssert]) buf.readInt32LE(offset[, noAssert]) buf.readIntBE(offset, byteLength[, noAssert]) buf.readIntLE(offset, byteLength[, noAssert]) buf.readUInt8(offset[, noAssert]) buf.readUInt16BE(offset[, noAssert]) buf.readUInt16LE(offset[, noAssert]) buf.readUInt32BE(offset[, noAssert]) buf.readUInt32LE(offset[, noAssert]) buf.readUIntBE(offset, byteLength[, noAssert]) buf.readUIntLE(offset, byteLength[, noAssert]) 使用如下所示,以32无符号整型为例： 12345const buf = Buffer.allocUnsafe(8); buf.writeUInt32BE(0x12345678,0); console.log(buf);//-&gt;&lt;Buffer 12 34 56 78 51 00 00 00&gt; const data = buf.readUInt32BE(0); console.log(data.toString(16));//-&gt;12345678]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[events模块]]></title>
    <url>%2F2017%2F11%2F19%2Fevents%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Nodejs的大部分核心API都是基于异步事件驱动设计的，所有可以分发事件的对象都是EventEmitter类的实例。 监听和执行EventEmitter实例可以使用on或addListener监听事件，当触发事件的时候，用emit()方法来执行on或addListener里面绑定的方法。看下面代码； 12345678910111213141516var EventEmitter=require(&apos;events&apos;); var util=require(&apos;util&apos;); function Bell(name)&#123; this.name=name; &#125; util.inherits(Bell,EventEmitter); //-&gt;Bell继承EventEmitter类 var jingleBell=new Bell(&apos;jingle&apos;); jingleBell.on(&apos;ring&apos;,function()&#123; console.log(&apos;你好世界&apos;); &#125;); jingleBell.addListener(&apos;drop&apos;,drop); function drop() &#123; console.log(&apos;你上天吧&apos;); &#125; jingleBell.emit(&apos;ring&apos;);//-&gt;你好世界 jingleBell.emit(&apos;drop&apos;);//-&gt;你上天吧 通过emit向监听函数里面传递参数看下面这段代码； 12345678910111213141516var EventEmitter=require(&apos;events&apos;); var util=require(&apos;util&apos;); function Bell(name)&#123; this.name=name; &#125; util.inherits(Bell,EventEmitter); var jingleBell=new Bell(&apos;jingle&apos;); jingleBell.on(&apos;ring&apos;,function(who,position)&#123; console.log(who+&apos;你好世界&apos;+position); &#125;); jingleBell.addListener(&apos;drop&apos;,drop); function drop(who) &#123; console.log(who+&apos;你上天吧&apos;); &#125; jingleBell.emit(&apos;ring&apos;,&quot;哈哈&quot;,&quot;中国&quot;);//-&gt;哈哈你好世界中国 jingleBell.emit(&apos;drop&apos;,&apos;小明&apos;);//-&gt;小明你上天吧 通过上面代码可以看出，emit后面可以向监听函数里面传递参数； 一次性事件监听EventEmiter可以使用once监听某个事件，则该事件处理程序只会触发一次，之后emit该事件都会被忽略，因为监听程序被注销了，用代码验证如下； 1234567891011121314151617var EventEmitter=require(&apos;events&apos;); var util=require(&apos;util&apos;); this.name=name; &#125; util.inherits(Bell,EventEmitter); var jingleBell=new Bell(&apos;jingle&apos;); jingleBell.once(&apos;ring&apos;,function(who,position)&#123; console.log(who+&apos;你好世界&apos;+position); &#125;); jingleBell.addListener(&apos;drop&apos;,drop); function drop(who) &#123; console.log(who+&apos;你上天吧&apos;); &#125; jingleBell.emit(&apos;ring&apos;,&quot;哈哈&quot;,&quot;中国&quot;); jingleBell.emit(&apos;ring&apos;,&quot;哈哈&quot;,&quot;美国&quot;); jingleBell.emit(&apos;drop&apos;,&apos;校长&apos;); jingleBell.emit(&apos;drop&apos;,&quot;同学&quot;); 最后输出结果如图所示； 移除事件绑定类似DOM事件监听，EventEmiter也可以移除事件绑定，利用removeListener(eventName,listener)方法解除某个事件的绑定，因此回调函数listener必须是实名函数，不能是匿名函数，要不然找不到该函数，就不能移除，因为函数是引用型类型，就算函数体是一样，也不是同一个函数；用代码验证； 1234567891011121314151617181920ar EventEmitter=require(&apos;events&apos;); var util=require(&apos;util&apos;); function Bell(name)&#123; this.name=name; &#125; util.inherits(Bell,EventEmitter); var jingleBell=new Bell(&apos;jingle&apos;); jingleBell.on(&apos;ring&apos;,function(who,position)&#123; console.log(who+&apos;你好世界&apos;+position); &#125;); jingleBell.removeListener(&apos;ring&apos;,function(who,position)&#123; console.log(who+&apos;你好世界&apos;+position); &#125;); jingleBell.addListener(&apos;drop&apos;,drop); jingleBell.removeListener(&apos;drop&apos;,drop); function drop(who) &#123; console.log(who+&apos;你上天吧&apos;); &#125; jingleBell.emit(&apos;ring&apos;,&quot;哈哈&quot;,&quot;中国&quot;);//-&gt;控制台输出&quot;哈哈你好世界中国&quot; jingleBell.emit(&apos;drop&apos;,&apos;校长&apos;);//-&gt;控制台什么都没有输出 通过上面的代码可以得出结论在移除事件绑定的时候必须要是实名函数； 获取事件监听数量和监听函数 用listenerCount（事件类型）方法可以得出某种事件类型所监听函数的数量，用 listeners（事件类型）方法可以得到该事件类型监听的所有函数。 1234567891011121314var EventEmitter=require(&apos;events&apos;); var util=require(&apos;util&apos;); function Bell(name)&#123; this.name=name; &#125; util.inherits(Bell,EventEmitter); var jingleBell=new Bell(&apos;jingle&apos;); jingleBell.on(&apos;ring&apos;,function(who,position)&#123; console.log(who+&apos;你好世界&apos;+position); &#125;); jingleBell.on(&apos;ring&apos;,fly); function fly()&#123;&#125; console.log(&quot;EventEmitter实例的ring事件绑定了%d个回调函数&quot;,jingleBell.listenerCount(&apos;ring&apos;)); console.log(&quot;他们是：&quot;+jingleBell.listeners(&apos;ring&apos;)); 执行结果如图所示： 获取和设置最大监听数量nodejs对同一事件的监听数量建议不宜超过10个，这个可以查看EventEmitter.defaultMaxListeners属性便可得知，如下所示： 12var EventEmitter=require(&apos;events&apos;); console.log(EventEmitter.defaultMaxListeners); //-&gt;10 通过getMaxListeners()方法获取最大监听数量以及setMaxListeners(n)方法设置最大监听数量,代码如下所示 1234var EventEmitter=require(&apos;events&apos;); var eve=new EventEmitter(); eve.setMaxListeners(5); console.log(eve.getMaxListeners());//-&gt;5 注意:getMaxListeners()和setMaxListeners(n)是扩展在EventEmitter类的原型上的， &gt;因此需要创建一个他的实例之后才能调用它。 下面的是setMaxListeners的源码的一部份： 123456EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) &#123; if (typeof n !== &apos;number&apos; || n &lt; 0 || isNaN(n)) throw new TypeError(&apos;&quot;n&quot; argument must be a positive number&apos;); this._maxListeners = n; return this; &#125;;]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[process.nextTick、setTimeout、setImmediate、异步ID的优先级问题]]></title>
    <url>%2F2017%2F11%2F18%2Fprocess.nextTick%E3%80%81setTimeout%E3%80%81setImmediate%E3%80%81%E5%BC%82%E6%AD%A5ID%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[上述的几种方法里面传递的函数都是异步执行的，但是他们执行的时候是有顺序的。 process.nextTick(callback)功能：在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(interval, 0) 函数的功能类似，但它的效率高多了。 通过下面的代码来比较它们的上述几种情况的优先级； 12345678910111213141516var fs=require(&apos;fs&apos;); fs.readFile(&apos;1.js&apos;,function(err,data)&#123; console.log(&quot;a: readFile&quot;) &#125;); console.log(&apos;a客人&apos;); setTimeout(function () &#123; console.log(&apos;a: setTimeout&apos;); &#125;,0); process.nextTick(function () &#123; console.log(&apos;a: nextTick1&apos;); &#125;); setImmediate(function () &#123; console.log(&apos;a: setImmediate&apos;); &#125;); console.log(&apos;b厨师&apos;); console.log(&apos;c厨师&apos;); 最后在控制台中输出结果如图所示： 得出简单的结论:他们的优先级顺序是nexttick&gt;setTimeout&gt;setImmediate&gt;异步IO 但是这里还是不能够得出看出直接比较出nexttick和setTimeout的优先级顺序，于是看下面的代码： 12345678910111213141516171819202122var fs=require(&apos;fs&apos;); fs.readFile(&apos;1.js&apos;,function(err,data)&#123; console.log(&quot;a: readFile&quot;) &#125;); console.log(&apos;a客人&apos;); setTimeout(function () &#123; console.log(&apos;a: setTimeout&apos;); &#125;,0); process.nextTick(function () &#123; console.log(&apos;a: nextTick1&apos;); process.nextTick(function () &#123; console.log(&apos;a: nextTick2&apos;); &#125;); process.nextTick(function () &#123; console.log(&apos;a: nextTick3&apos;); &#125;); &#125;); setImmediate(function () &#123; console.log(&apos;a: setImmediate&apos;); &#125;); console.log(&apos;b厨师&apos;); console.log(&apos;c厨师&apos;); 最后输出的结果如图所示： 得出结论:他们的优先级顺序是nexttick&gt;setTimeout&gt;setImmediate&gt;异步IO 注意：nexttick相当于是放在当前队列的最后一个执行，而setTimeout、setImmediate、异步IO都是在另一个队列中执行，因此nexttick永远比他们先执行。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中this]]></title>
    <url>%2F2017%2F11%2F18%2Fnode%E4%B8%ADthis%2F</url>
    <content type="text"><![CDATA[nodejs中的this和在浏览器中javascript中的this是不一样的。在全局中的this1234console.log(this); //-&gt;&#123;&#125; this.num =1; console.log(this.num); //-&gt;1 console.log(global.num); //-&gt;undefined 全局中的this默认是一个空对象。并且在全局中this与global对象没有任何的关系。那么全局中的this到底是什么了。看下面这段代码： 123var name=&quot;aba&quot;; exports.name=name; console.log(this);//-&gt;this-&gt;&#123; name: &apos;aba&apos; &#125; 全局中this会指向module.exports。 在函数中的this 1234567function fn()&#123; this.num = 1;&#125; fn(); console.log(this); /-&gt;&#123;&#125; console.log(this.num); //-&gt;undefined console.log(global.num); //-&gt;1 总结:在函数中this指向的是global对象，和全局中的this不是同一个对象，简单来说，你在函 数中通过this定义的变量就是相当于给global添加了一个属性，此时与全局中的this已经没有 关系了。但是可以用call、apply、bind方法改变this指向。 如果还对这个结论表示怀疑，那么下面这段代码足以证明: 12345678910function fn()&#123; function fn2()&#123; this.age = 18; &#125; fn2(); console.log(this); //-&gt;global console.log(this.age); //-&gt;18 console.log(global.age); //-&gt;18 &#125;fn(); 所以总结出:函数中this指向就是global 构造函数中的this 看下面这段代码： 123456function Fn()&#123; this.num = 100; &#125; var fn = new Fn(); console.log(fn.num); //-&gt;100 console.log(global.num); //-&gt;undefined 在构造函数中this指向的是它的实例，而不是global。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式从基础到实战]]></title>
    <url>%2F2017%2F11%2F12%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[什么是正则？ 正则就是一个规则，用来处理字符串的规则 1、正则匹配编写一个规则，验证某个字符串是否符合这个规则，正则匹配使用的是 test 方法2、正则捕获编写一个规则，在一个字符串中把符合规则的内容都获取到，正则捕获使用的方法：正则的exec方法、字符串中的split、replace、match等方法都支持正则 正则的元字符和修饰符 修饰符` g(global)：全局匹配 i(ignoreCase)：忽略大小写匹配 m(multiline)：多行匹配 `元字符` [量词元字符] +：让前面的元字符出现一到多次 ?：出现零到一次 *：出现零到多次 {n}：出现n次 {n,}：出现n到多次 {n,m}：出现n到m次 [特殊意义的元字符] \：转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义字符转换为普通的字符） .：除了\n（换行符）以外的任意字符 \d：匹配一个0~9之间的数字 \D：匹配任意一个非0~9之间的数字（大写字母和小写字母的组合正好是反向的） \w：匹配一个 `0~9或字母或_` 之间的字符 \s：匹配一个任意空白字符 \b：匹配一个边界符 x|y：匹配x或者y中的一个 [a-z]：匹配a-z中的任意一个字符 [^a-z]：和上面的相反，匹配任意一个非a-z的字符 [xyz]：匹配x或者y或者z中的一个字符 [^xyz]：匹配除了xyz以外的任意字符 ()：正则的小分组，匹配一个小分组（小分组可以理解为大正则中的一个小正则） ^：以某一个元字符开始 $：以某一个元字符结束 ?:：只匹配不捕获 ?=：正向预查 ?!：负向预查 元字符详细解读^ $ var reg = /\d+/; //=&gt;包含某某某即可，这里说明包含1到多个数字即可 var str = &apos;珠峰2017培训2018&apos;; reg.test(str) =&gt;truereg=/^\d+/; reg.test(str) =&gt;falsereg=/^\d+$/; //=&gt;只能是某某某的,这里说明只能是1到多个数字 reg.test(&apos;2017&apos;); =&gt;truereg.test(&apos;2017珠峰2018&apos;); =&gt;falsereg.test(&apos;2&apos;); =&gt;true ^或者$只是一个修饰或者声明，不会占据字符串的位置 \ var reg = /^2.3$/; reg.test(&apos;2.3&apos;); =&gt;truereg.test(&apos;2+3&apos;); =&gt;true 点在正则中的意思：匹配除了\n以外的任意字符，而不是单纯的小数点 reg = /^2\.3$/; reg.test(&apos;2.3&apos;); =&gt;truereg.test(&apos;2+3&apos;); =&gt;false 使用转义字符把点转换为本身小数点的意思 x|y var reg = /^18|19$/; //=&gt;18 19 189 119 819 181 1819 ... 很多都符合这个规则/* * 18或者19 * 以1开头 以9结尾 中间是8或者1 * 以18开头或者以19结尾即可 =&gt;&apos;18珠峰&apos; &apos;珠峰19&apos;... */ var reg = /^(18|19)$/; //=&gt;此时只有18或者19符合我们的规则了 ( ) 正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体）；在正则中 我们可以使用小括号改变一些默认的优先级； 小分组还有第二个作用：分组引用 小分组的第三个作用：分组捕获 //=&gt;分组引用：\1 或者 \2 ...出现和第N个分组一模一样的内容 var reg = /^([a-z])([a-z])\2([a-z])$/; //=&gt; 符合的字符串：foot、book、week、attr、http... [ ] [xyz] [^xyz] [a-z] [^a-z] //=&gt;\w：数组字母下划线中的任意一个字符 1234567 var reg = /^[a-zA-Z0-9_]$/; //=&gt;等价于\w var reg = /^[.?+&amp;]+$/; //=&gt;里面的四个元字符都是本身含义，例如：点就是小数点了 不是所谓的任意字符… //=&gt;需求：描述样式类名的规则（数字、字母、下划线、-），并且不能以-开头 //var reg = /^[\w-]+ //=&gt;没有处理以-开头的情况 var reg = /^\w[\w-]*$/; 例子 //=&gt;需求：验证18~65之间的年龄 //var reg = /^[18-65]$/; //=&gt;1或者8~6或者5中的任意一个字符,中括号中出现的18不是数字18，而是1或者8，当前正则 是非法的：因为不能设置8~6这种范围// =&gt;分三个阶段处理： // 18 或者 19 /(18|19)/ // 20 ~ 59 /([2-5]\d)/ // 60 ~ 65 /(6[0-5])/ var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/; 常用的正则表达式编写验证是否为有效数字 可能是正数，可能是负数 12 -12 整数或者小数 0 12 0.2 12.5 -12.3 只要出现小数点，后面至少要跟一位数字 小数点前面必须有数字 -? 负号可有可无 (\d|([1-9]\d+)) \d 一位数可以是任何值 ([1-9]\d+) 多位数不能以零开头 (.\d+)? 小数部分可有可无，有的话点后面必须跟一位数字 var reg = /^-?(\d|([1-9]\d+))(\.\d+)?$/; 手机号码 11位数字 1开头 var reg = /^1\d{10}$/; 用户名：真实姓名 //=&gt;/^[\u4E00-\u9FA5]$/ 中文汉字的正则 var reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10})?$/; 邮箱 var reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/; 以数字字母下划线开头 @前面可以是 数字、字母、下划线、-、. 这些符号 不能把 -和. 连续出现，出现一次后面必须跟数字字母下划线 @后面的部分支持 企业邮箱 .com.cn 多域名情况 /// [A-Za-z0-9]+// ((.|-)[A-Za-z0-9]+)*// .[A-Za-z0-9]+// @163.com.cn// @zhu-feng-pei-xun.com.cn 身份证号码 18位 前17位必须是数字 最后一位可以是数字或者X(X代表数字10) 130828199012040617 前六位：省市县 130828 接下来八位 出生年+月+日 倒数第二位数字 奇数代表男 偶数代表女 //=&gt;这样写不仅可以匹配，而且以后捕获的时候，不仅可以把大正则匹配的结果捕获到，里面每一个小分组(小正则)匹配的结果也可以单独的捕获到 “分组捕获”//=&gt;年 1950~2017//=&gt;第一段 1950~1999//=&gt;第二段 2000~2017//==&gt; 00~09//==&gt; 10~17// /^((19[5-9]\d)|(20((0\d)|(1[0-7]))))$/ var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/; 正则捕获 把当前字符串中符合正则的字符捕获到RegExp.prototype：exec 实现正则捕获的方法 var str = &apos;珠峰培训2017扬帆起航2018&apos;; var reg = /\d+/; reg.exec(str); 当正则捕获的时候： 1、先去验证当前字符串和正则是否匹配，如果不匹配返回的结果是null（没有捕获到任何的内容） 2、如果匹配，从字符串最左边开始，向右查找到匹配的内容，并且把匹配的内容返回 exec捕获到结果的格式： -&gt; 获取的结果是一个数组 -&gt; 数组中的第一项是当前本次大正则在字符串中匹配到的结果 -&gt; index：记录了当前本次捕获到结果的起始索引 -&gt; input：当前正则操作的原始字符串 -&gt; 如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组，本次匹配到的结果（通过exec可以把分组中的内容捕获到） 执行一次exec只能把符合正则规则条件中的一个内容捕获都，如果还有其它符合规则的，需要在次执行exec才有可能捕获到 正则捕获存在懒惰性 执行一次exec捕获到第一个符合规则的内容，第二次执行exec，捕获到的依然是第一个匹配的内容，后面匹配的内容不管执行多少次exec都无法捕获到 解决正则捕获的懒惰性：在正则的末尾加修饰符g（全局匹配） //=&gt;正则为什么会存在懒惰性?/* 正则本身有一个属性：lastIndex（下一次正则在字符串中匹配查找的开始索引） 默认值：0，从字符串第一个字符开始查找匹配的内容 默认不管指定多少遍exec方法,正则的lastIndex值都不会变（也就是第二次以后查找的时候还是从第一个字符找，所以找到的结果永远都是第一个匹配的内容） 而且当我们手动把 lastIndex 进行修改的时候，不会起到任何的作用 ///=&gt;为什么加修饰符g就解决了懒惰性?/* 加了修饰符g，每一次exec结束后，浏览器默认会把lastIndex值进行修改，下一次从上一次结束的位置开始查找，所以可以得到后面匹配的内容了 12345678910var reg = /\d+/g; var str = &apos;珠峰培训2017杨帆起航2018&apos;; console.log(reg.lastIndex);//=&gt;0 console.log(reg.exec(str)[0]);//=&gt;&apos;2017&apos; console.log(reg.lastIndex);//=&gt;8 console.log(reg.exec(str)[0]);//=&gt;&apos;2018&apos; console.log(reg.lastIndex);//=&gt;16 console.log(reg.exec(str));//=&gt;null console.log(reg.lastIndex);//=&gt;0 console.log(reg.exec(str)[0]);//=&gt;&apos;2017&apos; 1234567891011121314151617181920exec有自己的局限性：执行一次exec只能捕获到一个和正则匹配的结果（即使加了修饰符g），如果需要都捕获到，我们需要执行N次exec方法才可以下面封装的myExecAll方法，目的是执行一次这个方法，可以把当前正则匹配到的全部内容都捕获到```javascript RegExp.prototype.myExecAll = function myExecAll() &#123; var str = arguments[0] || ‘’, result = []; //=&gt;首先判断THIS是否加了全局修饰符G,如果没有加,为了防止下面执行出现死循环,我们只让其执行一次EXEC即可,把执行一次的结果直接的返回 if (!this.global) &#123; return this.exec(str); &#125; var ary = this.exec(str); while (ary) &#123; result.push(ary[0]); ary = this.exec(str); &#125; return result; &#125;; var reg = /\d+/g; console.log(reg.myExecAll(‘珠峰2017培训2018杨帆2019起航2020’)); 使用字符串方法match实现捕获123var reg = /\d+/g; var str = &apos;珠峰2017培训2018杨帆2019起航2020&apos;; str.match(reg); //=&gt;[&quot;2017&quot;, &quot;2018&quot;, &quot;2019&quot;, &quot;2020&quot;] 使用字符串match捕获：1、如果正则加了修饰符g，执行一次match会把所有正则匹配的内容捕获到2、如果没有加修饰符g，执行一次match只能把第一个匹配的结果捕获到局限性：在加了修饰符g的情况下，执行match方法只能把大正则匹配的内容捕获到，对于小分组捕获的内容方法给其自动忽略了 1234567891011121314var str = ‘my name is &#123;0&#125;,i am &#123;1&#125; years old~，2017’; //=&gt;需求：把&#123;n&#125;整体捕获到，而且还要把括号中的数字也获取到 var reg = /&#123;(\d+)&#125;/g; // str.match(reg);//=&gt;[“&#123;0&#125;”, “&#123;1&#125;”] //=&gt;想要获取小分组中的内容，我们只能使用EXEC处理了 function fn(reg,str)&#123; var ary=reg.exec(str), result=[]; while(ary)&#123; result.push(ary); ary=reg.exec(str); &#125; return result; &#125; 使用test也可以实现正则的捕获不管是正则的匹配还是正则的捕获，在处理时候的原理是没区别的：从字符串的第一个字符向后查找，找到符合正则规则的字符，如果可以找到，说明正则和字符串匹配（test检测返回true、exec捕获返回捕获的内容），如果找到末尾都没有匹配的，说明正则和字符串不匹配（test检测返回false、exec捕获返回null）。 12345678910111213141516//=&gt;如果当前字符串和正则是匹配的，我们进行捕获 var reg = /&#123;(\d+)&#125;/g; var str = ‘my name is &#123;0&#125;~~’; if (reg.test(str)) &#123; //=&gt;reg.test(str) : true console.log(reg.lastIndex);//=&gt;14 console.log(reg.exec(str));//=&gt;null &#125; var reg = /&#123;(\d+)&#125;/; var str = ‘my name is &#123;0&#125;~~’; if (reg.test(str)) &#123; //=&gt;reg.test(str) : true console.log(reg.lastIndex);//=&gt;0 console.log(reg.exec(str));//=&gt;[‘&#123;0&#125;’,’0’…] &#125; 使用test不仅可以找到匹配的内容，也能像exec一样把找到的内容获取到test返回结果是 true/false，所以靠返回结果肯定不行。 1234567var reg = /&#123;(\d+)&#125;/g; var str = ‘my name is &#123;0&#125;,i am &#123;1&#125; years old‘; reg.test(str);//=&gt;true console.log(RegExp.$1);//=&gt;0 获取到当前本次匹配内容中第一个小分组捕获的内容 reg.test(str);//=&gt;true console.log(RegExp.$1);//=&gt;1 TEST可以实现捕获,但是每一次只能获取到当前本次匹配结果中,第N个分组捕获的内容 $1第一个分组 $2第二个分组 … 所有支持正则的方法都可以实现正则的捕获（一般都是字符串方法）字符串中常用的支持正则的方法：match、split、replace； split 12345678910111213var str = ‘name=珠峰&amp;age=8&amp;lx=teacher’; str.split(/&amp;|=/); //=&gt;[“name”, “珠峰”, “age”, “8”, “lx”, “teacher”] str.split(/(&amp;|=)/); //=&gt;[“name”, “=”, “珠峰”, “&amp;”, “age”, “=”, “8”, “&amp;”, “lx”, “=”, “teacher”] //=&gt;在使用split进行字符串拆分的时候，如果正则中包含小分组，会把小分组中的内容都捕获到，放在最后的数组中 //=&gt;本案例中的小括号仅仅是为了实现 改变默认的优先级 问题，但是我们不想把分组中的内容捕获到 =&gt; “只想匹配不想捕获” 我们可以使用 (?:) str.split(/(?:&amp;|=)/); //=&gt;[“name”, “珠峰”, “age”, “8”, “lx”, “teacher”] //=&gt;只匹配不捕获： //在当前一个分组中加了 ?: ，在正则检测匹配的时候，小分组可以起到自己应有的作用（例如：改变优先级…），但是在捕获的时候，遇到带?:的小分组，浏览器不会把当前这个分组中匹配的内容，单独去捕获了 var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d)(\d|X)$/; reg.exec(‘130828199012040617’); //=&gt;[“130828199012040617”, “130828”, “1990”, “12”, “04”, “06”, “1”, “7”…] var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(?:\d&#123;2&#125;)(\d)(?:\d|X)$/; reg.exec(‘130828199012040617’);//=&gt; [“130828199012040617”, “130828”, “1990”, “12”, “04”, “1”…] var reg = /^-?(\d|([1-9]\d+))(.\d+)?$/;//=&gt;计算是第几个分组的时候，我们从左向右找 ( 即可） replace replace：字符串中原有字符的替换；str.replace(old,new) 123456var str = ‘珠峰2017珠峰2018’; str = str.replace(‘珠峰’,’珠峰培训’); str = str.replace(‘珠峰’,’珠峰培训’); //=&gt;’珠峰培训培训2017珠峰2018’ 没有实现我们希望的效果 //=&gt;在不使用正则的情况下，执行一次replace只能替换一个原有字符，第二次执行replace，还是从字符串的开始位置查找，把最新找到的字符替换为新字符（类似于正则捕获时候的懒惰性：每一次执行都是从字符串最开始的位置查找）真实项目中，replace一般都是和正则搭配在一起使用的 12var str = &apos;珠峰2017珠峰2018&apos;; str = str.replace(/珠峰/g,&apos;珠峰培训&apos;);//=&gt;&quot;珠峰培训2017珠峰培训2018&quot; replace原理： 1、当replace方法执行，第一项传递一个正则正则不加g：把当前字符串中第一个和正则匹配的结果捕获到，替换成新的字符正则加g：把当前字符串中所有和正则匹配的内容都分别的捕获到，而且每一次捕获，都会把当前捕获的内容替换为新字符 2、当replace方法执行，第二个参数传递的是一个函数（回调函数）首先用正则到字符串中进行查找匹配，匹配到一个符合规则的，就把传递的函数执行一次不仅执行这个函数，而且还把正则本次捕获的结果（和执行exec捕获的结果一样：数组、大正则匹配、小分组匹配 都有）当做实参传递给这个函数（这样就可以在函数中获取这些值：而这些值就是正则每一次捕获的结果 ） 1234567891011121314151617var str = &apos;my name is &#123;0&#125;,i am &#123;1&#125; years old,i can &#123;2&#125;!&apos;; var reg = /\&#123;(\d+)\&#125;/g; str.replace(reg, function () &#123; //=&gt;传递的函数一共被执行三次 //=&gt;console.log(arguments) 每一次匹配捕获到结果,不仅把这个方法执行了,而且还会把当前捕获的结果当做实参传递给这个函数(ARG) /* * 第一次执行函数，获取的是ARG类数组 * 0:&apos;&#123;0&#125;&apos; 本次大正则匹配的结果 * 1:&apos;0&apos; 本次第一个小分组匹配的结果 * 2:11 本次大正则匹配结果在字符串中的索引 index * 3:&apos;my nam...&apos; 原始字符串 input * * 和每一次执行exec实现捕获的结果非常类似 */ //return xxx; //=&gt;每一次执行函数，函数中RETURN的结果，都相当于把本次大正则匹配的内容替换掉（原始字符串不变） &#125;);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串String的常用方法]]></title>
    <url>%2F2017%2F11%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2String%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[charAt(索引)获取指定索引位置的字符charCodeAt（索引）获取指定索引位置的字符串对应的ASCII值123var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.charAt(8));//-&gt;h console.log(str.charCodeAt(8));//-&gt;104 字符串截取1、substrsubstr(n,m) 从索引n开始截取m个字符 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.substr(0,5));//-&gt;www.f 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.substr(5,2));//-&gt;an 2、substringsubstring(n,m) 从索引n开始，找到索引m处(不包含m),将找到的字符返回。 12var str=&apos;www.fanzhanxiang.cn&apos;;console.log(str.substring(0,5));//-&gt;www.f 3、sliceslice(n,m) 从索引n开始，找到索引m处(不包含m),将找到的字符返回。并且slice支持以负数作为索引，原理是str.length+负数索引。 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.slice(0,5));//-&gt;www.f 12var str=&apos;www.fanzhanxiang.cn&apos;;console.log(str.slice(-5,-1));//-&gt;ng.c 上面的这三个方法都是如果只写了一个n,没有m:代表截取到末尾位置 查找字符的索引indexOf/lastIndexOf indexOf(字符)：获取指定字符在字符串中第一次出现的位置 lastIndexOf(字符)：获取指定字符在字符串中最后一次出现的索引位置 这两个方法都是如果没有这个字符，返回的是-1，基于这个理念我们经常用这个两个方法判断字 符串中是否包含某个字符,里面还可以放多个字符，必须连着包含才会输出对应索引、否则返回-1 123456var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.indexOf(&quot;.&quot;));//-&gt;3 console.log(str.lastIndexOf(&quot;.&quot;));//-&gt;16 console.log(str.indexOf(&quot;。&quot;));//-&gt;-1 console.log(str.lastIndexOf(&quot;。&quot;));//-&gt;-1 console.log(str.lastIndexOf(&quot;www。&quot;));//-&gt;-1 大小写转换 toUpperCase:将所有字母转换为大写 toLowerCase：将字母转换为小写 123var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.toUpperCase());//-&gt;WWW.FANZHANXIANG.CN console.log(str.toLowerCase());//-&gt;www.fanzhanxiang.cn 替换replace(要替换的老字符，替换的新字符)；在不使用正则的情况下，每一次调用方法只能替换一次。一般情况下替换我们都是使用正则处理的。 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.replace(&quot;.cn&quot;,&quot;.com&quot;));//-&gt;www.fanzhanxiang.com 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.replace(&quot;w&quot;,&quot;W&quot;));//-&gt;Www.fanzhanxiang.cn，只替换了一次 将字符串按照指定的分隔符拆分成数组split(分隔符)：将字符串按照指定的分隔符拆分成数组 1234var str=&apos;1+2+3+4+5+5&apos;; console.log(str.split(&quot;+&quot;));//-&gt;[ &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;5&apos; ] console.log(str.split(&quot;&quot;));//-&gt;[ &apos;1&apos;, &apos;+&apos;, &apos;2&apos;, &apos;+&apos;, &apos;3&apos;, &apos;+&apos;, &apos;4&apos;, &apos;+&apos;, &apos;5&apos;, &apos;+&apos;, &apos;5&apos; ] console.log(str.split(&quot; &quot;));//-&gt;[ &apos;1+2+3+4+5+5&apos; ] matchmatch()方法用于从字符串中查找指定的值，本方法类似于indexOf()和lastindexOf()，不同的是它返回的是指定的值，而不是指定值在字符串中的位置。是一个数组，并且只能查找一次，索引为0的这项是查找到的值，index是这项值的索引，input是原字符串。indexOf()和lastindexOf()方法返回位置数字 如果找不到返回-1。注意区分大小写 。 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.match(&quot;w&quot;));//-&gt;[ &apos;w&apos;, index: 0, input: &apos;www.fanzhanxiang.cn&apos; ]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的常用方法]]></title>
    <url>%2F2017%2F11%2F12%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面的数组的方法中都是按照下面的四个维度去详细解读： 1、这个数组方法的作用 2、需要传那些参数 3、是否有返回值、返回值是什么 4、通过这个方法是否对原来的数组产生了影响。 关于数组的增加、修改、删除1、push 作用：向数组的末尾增加新的内容 传递的参数:想要向原来数组增加的内容,而且可以传递多个值，统一向末尾增加多项 返回值是:新增加后数组的长度 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45]; var res=ary.push(100,200,300);console.log(res,ary);//-&gt;7 [ 12, 23, 34, 45, 100, 200, 300 ] 2、pop 作用：删除数组最后一项内容 传递的参数:不需要传递参数 返回值是:被删除的那一项内容 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45]; var res=ary.pop(); console.log(res,ary);//-&gt;45 [ 12, 23, 34 ] 3、shift 作用：删除数组第一项内容 传递的参数:不需要传递参数 返回值是:被删除的那一项内容 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45];var res=ary.shift();console.log(res,ary);//-&gt;12 [ 23, 34, 45 ] 4、unshift 作用：向数组开头增加一项 传递的参数:需要向数组开头增加的内容，可传递多个参数 返回值是:数组的长度 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45]; var res=ary.unshift(100,100,200); console.log(res,ary);//-&gt;7 [ 100, 100, 200, 12, 23, 34, 45 ] 5、spilce 能实现删除、修改、增加，下面依次写一下这三个方法 删除 作用：ary.splice(n,m),从索引n开始删除，删除m个元素，里面不传递参数则是一项都没有删 除，返回空数组 传递的参数:n,m 返回值是:把删除的内容以一个新的数组返回 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45,23,34]; var res=ary.splice(2,3); console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 34 ] 注意:ary.splice(n);//表示从索引n开始删除到末尾 修改 作用：ary.splice(n,m，x),从索引n开始删除，删除m个元素,用x替换删除的部分 传递的参数:n,m,x 返回值是:把删除的内容以一个新的数组返回 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45,23,34];var res=ary.splice(2,3,1000);console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 1000, 34 ] 增加 作用：ary.splice(n,0，x),从索引n开始删除，一个都不删除,用x增加到索引n是前面 传递的参数:n,m,x 返回值是:空数组 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45,23,34]; var res=ary.splice(2,0,1000); console.log(res,ary);//-&gt;[] [ 12, 23, 1000, 34, 45, 23, 34 ] 关于数组的截取和拼接1、slice 作用：实现数组的截取，在原来的数组中截取某一部分 传递的参数:slice(n,m) 从索引n开始，找到索引为m处（不包含m） 返回值是:截取到的数组 对原来数组的影响:原来的数组不变 123var ary=[12,23,34,45,23,34]; var res=ary.slice(2,5); console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 34, 45, 23, 34 ] 注意ary.slice(n),表示从索引n开始一直找到数组的末尾，返回截取到的数组 2、concat 作用：把两个数组拼接到一起，原来的数组不改变 传递的参数:要拼接的数组，可传递的多个数组 返回值是:拼接后的新数组 对原来数组的影响:原来的数组不变 1234var ary1=[12,23,34,45,23,34]; var ary2=[100,200]; var res=ary1.concat(ary2,ary2); console.log(res,ary1,ary2);//-&gt;[ 12, 23, 34, 45, 23, 34, 100, 200, 100, 200 ] [ 12, 23, 34, 45, 23, 34 ] [ 100, 200 ] 注意ary1.concat（）,相当于把ary1克隆一份一模一样的数组. 把数组转化为字符串1、toString 作用：把数组转化为字符串 传递的参数:没有参数 返回值是:转化后的字符串 对原来数组的影响:原来的数组不变 123var ary=[12,23,34,45,23,34]; var res=ary.toString(); console.log(res,ary);//-&gt;12,23,34,45,23,34 [ 12, 23, 34, 45, 23, 34 ] 2、join 作用：按照每一个分隔符把数组中的每一项拼接成一个字符串 传递的参数:要分隔的分隔符 返回值是:分隔后的结果 对原来数组的影响:原来的数组不变 123var ary=[12,23,34,45,23,34]; var res=ary.join(&quot;@&quot;); console.log(res,ary);//-&gt;12@23@34@45@23@34 [ 12, 23, 34, 45, 23, 34 ] 扩展：eval-&gt;JS中把字符串变为JS表达式执行的一个方法 1console.log(eval(&apos;12+12+34&apos;));//-&gt;58 数组的排序和排列1、reverse 作用：把数组倒过来排列 传递的参数:不需要传递参数 返回值是:倒过来排序后的数组 对原来数组的影响:原来的数组也倒过来排列 123var ary=[12,23,34,45,23,34]; var res=ary.reverse(); console.log(res,ary);//-&gt;[ 34, 23, 45, 34, 23, 12 ] [ 34, 23, 45, 34, 23, 12 ] 2、sort 作用：给数组进行排序 传递的参数:直接写ary.sort()只能处理10以内的数字进行排序 返回值是:排序后的数组 对原来数组的影响:原数组改变 直接写ary.sort()只能处理10以内的数组，比如下面这个数组。原因：因为它是按照UNICODE编码的值进行排序的。 123var ary=[12,23,340,45,23,34]; var res=ary.sort(); console.log(res,ary);//-&gt;[ 12, 23, 23, 34, 340, 45 ] [ 12, 23, 23, 34, 340, 45 ] sort（）里面传递相应参数可以对所有的进行排序，里面函数返回的值是（a-b）时是有小到大，返回”b-a”时是由大到小 12345var ary=[12,23,340,45,23,34]; var res=ary.sort(function (a,b) &#123; return a-b; &#125;); console.log(res,ary);//-&gt;[ 12, 23, 23, 34, 45, 340 ] [ 12, 23, 23, 34, 45, 340 ] 12345var ary=[12,23,340,45,23,34]; var res=ary.sort(function (a,b) &#123; return b-a; &#125;); console.log(res,ary);//-&gt;[ 340, 45, 34, 23, 23, 12 ] [ 340, 45, 34, 23, 23, 12 ] 只有在标准浏览器中兼容的方法，在IE6-8下不兼容的注意:字符串中也有两个方法是兼容所有浏览器的，而数组这两个方法是不兼容的。 1、indexOf/lastIndexOf 作用：当前内容在数组中第一次/最后一次出现的索引，如果数组中没有这一项，返回结果&gt; 是-1，如果有这一项，索引是几就返回几 传递的参数:要查找的数字 返回值是:0或-1 对原来数组的影响:不变 123var ary=[12,23,340,45,23,34]; var res=ary.indexOf(12); console.log(res,ary);//-&gt;0 [ 12, 23, 340, 45, 23, 34 ] 123var ary=[12,23,340,45,23,34]; var res=ary.indexOf(1000); console.log(res,ary);//-&gt;-1 [ 12, 23, 340, 45, 23, 34 ] 应用:可以用它的返回值来验证当前内容在数组中是否存在，看它的返回值是不是-1； 2、forEach/map 参考这篇文章:http://www.fanzhanxiang.cn/2017/11/05/forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB/ 作用：都是用来遍历数组中的每一项的 传递的参数:看例子 返回值是:前面的博文中有写这两个方法 对原来数组的影响:参考前面的一篇博文 用法:数组中有几项我们的函数就执行几次； 12345var ary=[12,23,340,45,23,34]; var res=ary.forEach(function(item,index)&#123; console.log(item,index);//依次输出：12 0 、 23 1、 340 2 、 45 3 、 23 4 、 34 5 &#125;); console.log(res,ary);//-&gt;undefined [ 12, 23, 340, 45, 23, 34 ]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm ERR publish 403,nodejs发布包流程]]></title>
    <url>%2F2017%2F11%2F08%2Fnpm%20ERR%20publish%20403%2Cnodejs%E5%8F%91%E5%B8%83%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[nodejs学习体验之发布包，发布环境如下：1:win10系统,2:已安装nodejs.具体操作步骤如下：编写模块 1）新建文件夹，比如：node 2) 该文件夹下新建js文件，比如：index.js,js里面的内容可以随便写 初始化包描述文件 进入node文件夹之后按住shift的同时按住鼠标右键，选择在此处打开命令窗口有的电脑也可以是在”此处打开Powershell窗口，然后进入”执行下列命令、 1npm init 之后连续点击enter键，帮助你生成package.json文件。这是我的文件的内容.name这个属性在按enter键的时候需要注意是要自己填的，也可以在生成package.json之后再改。12345678910&#123; &quot;name&quot;: &quot;fanzhanxiang&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; &#125; 注册包仓库账号执行这个命令 1npm adduser 输入这个命令会有提示输入用户名，密码，邮箱等资料 这和去官方源仓库https://www.npmjs.com/注册是一样的 上传包 1npm publish 如果上传成功会提示 +fanzhanxiang@1.0.0 否则上传失败 这个时候去https://www.npmjs.com/登陆仓库账号就可以看到自己的包啦。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply、bind的区别]]></title>
    <url>%2F2017%2F11%2F07%2Fcall%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[apply和call的作用是一模一样的，都是用来改变方法下的this关键字并且把方法执行，并且在”严格模式”下和非严格模式下对于第一个参数书null和undefined这种情况也是一样的。当在JS开始的时候在最前面加一句代码叫:”use strict“表示告诉当前当前浏览器，接下来的JS代码将按照严格模式编写严格模式 在非严格模式下，函数定义的形参和arguments是存在映射关系的，一个变另一个也跟着变, 但是在严格模式下这个是没有映射关系的。并且在严格模式下禁止我们使用arguments.callee 和arguments.callee.caller; call代码如下: 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; &apos;use strict&apos;;//告诉当前当前浏览器，接下来的JS代码将按照严格模式编写 var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2); console.log(this); &#125; //fn(100,200);//this是Window num1=100，num2=200 //fn.call(100,200);//this-&gt;100 num1=200 num2=undefined //fn.call(obj,100,200);//this-&gt;obj num1=100 num2=200 /*fn.call();//this-&gt;window 在严格模式下 this-&gt;undefined fn.call(null);//this-&gt;window 在严格模式下this-&gt;null fn.call(undefined);//this-&gt;window 在严格模式下this-undefined */&lt;/script&gt; 我们发现严格模式下的this相对于非严格模式的this主要区别在于：对于JS代码没有写执行 主体去情况下，非严格模式默认是在Window执行的，所以this指向的是Window;但是在严格 模式下没有写执行主体，this指向是undefined. apply123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2); console.log(this); &#125; //fn.call(obj,100,200);//-&gt;这行代码和下面这行代码的作用相同 fn.apply(obj,[100,200]);&lt;/script&gt; 和call的区别 call在给fn传递参数的时候是一个一个传递的，而apply不是一个个传，而是要把fn传递的参数值统一放在一个数组中进行操作，但是也相当于一个个的给fn的形参赋值. bind这个方法在IE6-8上不兼容-&gt;和call和apply方法类似，都是用来改变this关键字的。但是这个方法是一个预处理的效果，事先把this变为我们想要的结果，并且把函数中的参数值也准备好。以后用到了直接执行即可。 用代码表示为: 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2,this); &#125; //fn.call(obj,100,200);//-&gt;已经执行了，会输出值&quot;300,&#123;name:&quot;ABC&quot;&#125;&quot;; fn.bind(obj,100,200);//仅仅是改变了fn中的this为obj,传递参数值，并没有执行fn这个方法 var tempFn=fn.bind(obj,1,2)//-&gt;&quot;3,&#123;name:&quot;ABC&quot;&#125;&quot;;这时候fn就执行了,这就是bind的作用&lt;/script&gt; bind的还有一个作用是事先固定值的功能，比如： 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function fn(num1,num2) &#123; console.log(num1+num2，this); &#125; fn.bind(this,100);//-&gt;这里bind的作用不是改变this问题，this还是Window，但是这里是先 在函数里面固定的传入第一个参数值num1,第二个参数值在执行的时候可以在后面再传递进去。比如下 面这行代码 var tempFn=fn.bind(this,100); tempFn(2);//-&gt;这里相当于传递进来了第二个参数num2，输出值为&quot;3,window&quot;,这里的作用并没有改变this值。如果不传递第二个参数的话第二个参数默认是undefined tenpFn();//-&gt;&quot;NaN,window&quot;&lt;/script&gt; bind体现了JS中的预处理思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要是用到了，直接的执行即可。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 部署到 Github Pages 文件夹大小写问题]]></title>
    <url>%2F2017%2F11%2F06%2FHexo%20%E9%83%A8%E7%BD%B2%E5%88%B0Github%20Pages%20%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题简介使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404问题。 譬如 Hexo 生成了一个 javascript js文件夹，但是我后来把它改成了 javascript Js，即 j 的首字母大写了。Hexo会生成正确，但部署到 Github 上却老是不正确。 原因git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。 解决办法 进入到博客项目中 .deploy_git文件夹，这个文件夹在 “博客目录-&gt;.deploy_git-&gt;git”下，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false，如图所示，这是我已经修改过的，原来是true。 删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步是清空你的 github.io 项目中所有文件。在博客项目中，执行下面命令。 1234cd .deploy_git it rm -rf * git commit -m &apos;clean all file&apos; git push 使用 Hexo 再次生成及部署，在上面命令执行完之后执行下面命令,问题解决。 123cd .. hexo clean hexo deploy -generate]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储]]></title>
    <url>%2F2017%2F11%2F05%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[JS中的本地存储: 使用JS向浏览器向浏览器某一个位置中存储一些内容，浏览器即使关闭了，存储了信息也不会销毁，当在重新打开浏览器的时候我们依然可以获取到上一次存储的信息。 一、本地存储的方案传统: 1、cookie:把信息存储到客户端的浏览器中（但是项目服务器端也是可以获取COOKIE的） 2、session:把信息存储到服务器上的（服务器存储） HTML5:webStorage 1、localStorage:永久存储到客户端本地 2、sessionStorage:信息会话存储，回话窗口存在信息也存在，会话窗口关闭信息也消失了 打开谷歌控制台，按F12可以Application中可以看到这些相应的窗口:如图所示 COOKIE localStorage sessionStorage三者之间的用法以及区别webStorage localStorage和sessionStorage的用法是一样的：setItem([key],[value]):向客户端的本地存储一条记录，存储的[value]值需要使字符串格式的，如果编写的不是字符串，浏览器也会默认转化为字符串然后进行存储;存储的[key]是不会重复的，如果之前有的话，把存储的信息值重新进行修改； 1、getItem([key]):获取之前存储的值 2、removeItem([key]):移除key对应的那条记录 3、clear():把当前源下所有的存储记录都移除掉 4、localStorage.length:获取存储的记录条数 5、localStorage.key(0):获取索引为0这一项的key是什么 用代码表示为: 1234567console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;7&quot; localStorage.setItem(&apos;age&apos;,JSON.stringify(&#123;name:&apos;abc&apos;&#125;)); console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;&#123;&quot;name&quot;:&quot;abc&quot;&#125;&quot; localStorage.removeItem(&apos;age&apos;); localStorage.clear(); console.log(localStorage.length);//-&gt;0 console.log(localStorage.key(0));//-&gt;&apos;null&apos; 下面是执行下面这段代码之后存储在控制台里面看到的效果: 1console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;7&quot; localStorage和sessionStorage的区别: 1、localStorage属于永久存储到本地，不管是刷新页面还是关掉页面或者关掉浏览器，存储的内 容都不会消失，只有我们手动删除才会消失（不管是杀毒软件还是浏览器自带的清除历史记录 的功能都不能把localStorage存储的内容移除掉）; 2、sessionStorage属于临时会话存储，只要当前的页面不关闭，信息就可以存储下来，但是页 面一旦关闭,存储的信息就会自动关闭（F5刷新只是把当前的DOM机构等进行重新渲染，会话并 没有关闭） cookie cookie和locaStorage的区别: 1、cookie兼容所有浏览器，但是localStorage不兼容IE6-8 2、cookie存储内容的大小是有限制的，一般同源下只能存储4KB内容;localStorage存储的内 容大小也有限制，一般同源下只能存储5MB; 3、cookie存储的内容是有过期时间的，而localStorage是永久存储到本地，使用杀毒软件或者 清除垃圾的功能都可能把存储的cookie给删除掉 4、用户可能出于安全的角度禁用cookie(无痕浏览)，但是不能禁用localStorage.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的forEach和map方法解读]]></title>
    <url>%2F2017%2F11%2F05%2FforEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[forEach和map方法都是用来遍历数组中的每一项的; forEach 1、数组中有几项，那我们传递进去的匿名函数就需要执行几次 2、每一次执行匿名函数的时候，还给其浏览器给其默认传递了三个参数值：数组中的当前项 item，当前项的索引index，原始数组input。 3、理论上我们的方法是没有返回值的，仅仅遍历数组中的每一项不对原来的数据进行修改，但是 我们可以通过数组的索引来修改原来的数组。 执行下面代码：123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var ary=[12,23,34,45,43]; var res=ary.forEach(function (item,index,input) &#123; console.log(arguments); input[index]=item*10; &#125;); console.log(res);//-&gt;undefined console.log(ary);&lt;/script&gt; 控制台中返回结果如图所示: 原因：执行了5函数，输出了5次arguments,并且函数在遍历的时候是从索引0开始依次遍历的。 mapmap的回调函数中支持return返回值，return的后面是啥，相当于把数组中的这这一项改变为啥(但是并不影响原来的数组，只是相当于把原来的数组克隆一份，把克隆的这一份数组中的对应项改变了)。 用代码表示为: 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var ary=[12,23,34,45,43]; var res=ary.map(function (item, index, input) &#123; return item*10; &#125;); console.log(res);//-&gt; [120, 230, 340, 450, 430] console.log(ary);//-&gt;[12, 23, 34, 45, 43]&lt;/script&gt; 注意不管是forEach还是map都支持第二个参数，第二个参数的意识是把匿名函数中的this进行修改为第二个参数值。 代码表示: 1234567891011&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;abc&quot;&#125;; var ary=[12,23,34,45,43]; ary.forEach(function (item, index) &#123; console.log(this); &#125;); ary.forEach(function (item, index) &#123; console.log(this); &#125;,obj);&lt;/script&gt; 在控制台中输出的结果如图所示: 证实了上面的结论。 不管是forEach还是map在IE6-8下都不兼容]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的同步和异步编程]]></title>
    <url>%2F2017%2F11%2F05%2FJS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JS中的两种编程思想：同步、异步。 同步同步编程:上一件事情没有完成，继续做上一件事情，只有上一件事情完成了，才会做下一件事情(JS大部分都是同步编程的)。如下面代码：（1）、（2）分别代表第一次和第二次输出。 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; for(var i=0;i&lt;100000;i++)&#123; if(i===99999)&#123; console.log(&quot;循环结束了~~&quot;)//-&gt;(1) &#125; &#125; console.log(&quot;ok&quot;);//-&gt;(2)&lt;/script&gt; 原因:for循环就是同步编程的，只有循环结束后，才会执行下面的代码,因此会先输出前面的，再输出后面的。 再比如下面这段代码: 123456&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; while (1)&#123; &#125; console.log(&quot;ok&quot;);//-&gt;不会有结果输出，并且浏览器还会崩溃&lt;/script&gt; 原因:因为上面的循环是死循环，循环永远不会结束,JS不会跳过上面那段循环来执行下面的循环。 异步解读：首先规划要做一件事情，但是不是立马去执行这件事情，需要等一定的时间，这样的话我们不会继续等着它执行，而是继续执行下面的操作，”只有下面的事情都处理完成了”.只有当下面的事情都处理完成了，才会返回头处理之前的事情；如果下面的事情没有处理完成，不管之前的事情有没有处理完成，都踏踏实实的给我等着。在JS中异步编程只有四种情况：定时器都是异步编程的、所有事件绑定都是异步编程的、AJAX读取数据的时候，我们一般设定为异步编程、回调函数也是异步编程的。 比如下面这段代码: 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;1(2) &#125;,1000); console.log(n);//-&gt;0(1)&lt;/script&gt; 原因:定时器是异步编程的，在1000ms之后再执行定时器中的方法，因此会先输出0，再输出1。 关于浏览器的最小等待事件问题 比如下面的这段代码： 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;1(2) &#125;,0); console.log(n);//-&gt;0(1)&lt;/script&gt; 原因:每一个浏览器对于定时器的等待时间都有一个最小值：谷歌大概:5~6ms,IE大概:13~14ms,如果设置的等待时间小于这个值，不起作用，还是需要等到最小时间才执行；尤其是写0也不是立即执行； 定时器设置的等待时间不一定就是最后执行的时间 看下面的这段代码： 12345678910111213&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;不执行 &#125;,0); console.log(n);//-&gt;0(1) while (1)&#123; n++;//-&gt;死循环 &#125; console.log(n);//-&gt;不执行&lt;/script&gt; 原因:执行到while的时候出现了死循环，因此定时器里面的方法永远不会执行。 定时器是谁先到先执行谁 如下面这段代码： 12345678910111213141516&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n+=2; console.log(n);//-&gt;7(4) &#125;,20); window.setTimeout(function()&#123; n+=5; console.log(n);//-&gt;5(3) &#125;,5); console.log(n);//-&gt;0(1) for(var i=0;i&lt;10000000;i++)&#123; &#125; console.log(n);//-&gt;0(2)&lt;/script&gt; 原因：JS在执行的时候会有一个类似于设置闹钟的那种机制的任务队列，不是之前设置的闹钟就之前叫，而是不管是什么时候设置的，谁的时间先到了就谁先叫。如图所示。 上面仅仅是讲了定时器这一种异步编程思想，所有事件绑定、AJAX读取数据的时候、回调函数这几 种的原理也和定时器的一样]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据类型检测的四种方式]]></title>
    <url>%2F2017%2F11%2F04%2FJavaScript%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%98%AF%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、typeof 用来检测数据类型的运算符使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串包含了对应的数据类型，例如:’number’、’string’、’boolean’、’undefined’、’function’、’object’。局限性： 1typeof null-&gt;&quot;object&quot; 不能具体细分是数组还是正则，还是对象中其他的值，因为使用typeof检测数据类型，对于对象数据类型中的左右的值，最后返回的结果都是”object” 二、instanceof 检测某一个实例是否属于这个类优点：它可以用来检测是数组还是正则了。局限性：对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定的区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这类的实例，对于字面量创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散型，导致了可以使用JS原型上的方法。如下面的代码。 12345678910console.log(1 instanceof Number);//-&gt;控制台输出false console.log(new Number(1) instanceof Number);//-&gt;控制台输出true var ary=[]; function fn() &#123; &#125; console.log(ary instanceof Array)//-&gt;控制台输出true console.log(ary instanceof Object)//-&gt;控制台输出true console.log(fn instanceof Function)//-&gt;控制台输出true console.log(ary instanceof Object)//-&gt;控制台输出true 因此，它会产生以下影响： 1、不能用来检测和处理字面量方式创建出来的基本数据类型值。 2、instanceof的特性：只要在当前实例的原型链上，我们用其检测出来的结果都是true。 3、在类的原型继承中，我们最后检测出来的结果未必准确。只要它的原型链上有这个类，最后用这 方法检测出来的结果都是true。 三、constructor: 构造函数 作用和instanceof非常相似有如下代码：123456var obj=[],num=1，reg=/^$/; console.log(obj.constructor===Array);//-&gt;true console.log(obj.constructor===RegExp);//-&gt;false console.log(num.constructor===Number);//-&gt;true console.log(reg.constructor===RegExp);//-&gt;true console.log(reg.constructor===Object);//-&gt;false 优点:可以看出和instanceof相比，constructor可以处理基本数据类型的检测。不同:constructor和instanceof不一样的地方在于，constructor在检测的时候先在私有属性上找，找到之后就不会往后面找了，所以在用来检测Object的时候，一般情况下是检测不了的。局限性：我们可以把类的原型进行重写，在进行的重写过程中，很有可能之前contructor给覆盖掉了，这样检测出来的结果就是不准确的。 扩展：对于特殊的数据类型null和undefined,他们的所属类是Null和Undefined,但是浏览 器把这两个类保护起来了，不允许我们在外面访问使用。 四、Object.prototype.toString.call()这是最准确检测数据类型的方法； 解读：首先获取Object原型上toString方法，让方法执行，并且改变方法中的this关键字的指向。先看一下面的代码。 123456console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot;console.log((128).toString(2/8/10));-&gt;把数字转化为二进制/八进制/十进制，Number原型上的toString方法支持把数字转化为相的进制。 console.log((1).__proto__.__proto__.toString());//-&gt;&quot;[object Object]&quot; console.log(&quot;zhufeng&quot;.toString());//-&gt;也是转为为字符串，但是不支持进制 console.log(&#123;&quot;name&quot;: &quot;abc&quot;&#125;.toString());//-&gt;&quot;[object Object]&quot; console.log(Math.toString())//-&gt;&quot;[object Math]&quot; 通常情况下对toString的理解： 对于Number、String、Boolean、Array、RegExp、Date、Function原型上的toString()方法都 是把当前的数据类型转换为字符串类型（他们的作用仅仅是用来转换为字符串 Object.prototype.toString并不是用来转换为字符串的。 Object.prototype.toString它的作用是返回当前方法的执行主体（方法中this）所属类的详 细信息。var obj={name:&quot;xyz&quot;};//-&gt;&quot;[object Object]&quot; console.log(obj.toString());//-&gt;toString中的this是obj,返回的是obj所属类的信 息-&quot;[object Object]&quot;第一个object代表当前实例是对象数据类型的(这个是固定)，第二个 Object,代表的是obj是object这个类的一个实例。 1234567891011var ary=[]; console.log(Object.prototype.toString.call(ary));//-&gt;&quot;[object Array]&quot;; console.log(Object.prototype.toString.call(/^$/));//-&gt;&quot;[object RegExp]&quot;; console.log((&#123;&#125;).toString.call(1));//-&gt;&quot;[object Number]&quot;; console.log((&#123;&#125;).toString.call(&quot;dsas&quot;));//-&gt;&quot;[object String]&quot;; console.log((&#123;&#125;).toString.call(true));//-&gt;&quot;[object Boolean]&quot;; console.log((&#123;&#125;).toString.call(null));//-&gt;&quot;[object Null]&quot;; console.log((&#123;&#125;).toString.call(undefined));//-&gt;&quot;[object Undefined]&quot;; console.log((&#123;&#125;).toString.call(function () &#123;&#125;));//-&gt;&quot;[object Function]&quot;; console.log((&#123;&#125;).toString.call(new Date));//-&gt;&quot;[object Date]&quot;; console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot; 从上面代码可以总结春：Object.prototype.toString并不是用来转换为字符串的，返回的是 obj所属类的信息息-&quot;[object &quot;参数2&quot;]&quot;第一个object代表当前实例是对象数据类型的(这个 是固定)，第二个参数，“参数2”,代表的是检测的这个所属的类。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中检测兼容的三种方式]]></title>
    <url>%2F2017%2F11%2F04%2FJS%E6%A3%80%E6%B5%8B%E5%85%BC%E5%AE%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、使用try、catch来处理兼容前提：必须保证try中的代码在不兼容浏览器中执行的时候报错，这样的话我们才可以用catch捕获到异常的信息，进行其它的处理，示例代码如下面所示。缺点：不管是什么浏览器，都需要把try中的代码都需要把try中的代码执行一遍，如果当前是IE7。window.getComputedStyle本身是不兼容的，但是我们也要把它先执行一遍，报错了再把curEle.currentStyle执行一遍（消耗性能），因此使用try处理兼容只有在万不得已的情况下才使用它。 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123;//-&gt;curEle指的是操作的元素，attr指的是元素属性 var val=null; try&#123; val=window.getComputedStyle(curEle,null)[attr]; &#125;catch(e)&#123; val=curEle.currentStyle[attr]; &#125; return val; &#125;&lt;/script&gt; 二、判断当期浏览器中是否存在这个属性和方法判断当期浏览器中是否存在这个属性和方法，存在就兼容，不存在就不兼容。代码如下所示 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123; var val = null; if (getComputedStyle in window) &#123;//-&gt;如果返回结果是true，说明Window下有getComputedStyle，代表兼容 val = window.getComputedStyle(curEle, null)[attr]; &#125; else &#123; val = curEle.currentStyle[attr]; &#125; return val; &#125;&lt;/script&gt; 三、通过检测浏览器版本和类型来处理兼容代码如下所示： 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123; var val = null; if (/MSIE(6|7|8)/.test(navigator.userAgent)) &#123;//-&gt;说明是IE6-8浏览器 val = curEle.currentStyle[attr]; &#125; else &#123; val = window.getComputedStyle(curEle, null)[attr]; &#125; return val; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中常用的六种继承方式]]></title>
    <url>%2F2017%2F11%2F04%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、原型链继承可枚举和不可枚举：我们在JavaScript中使用for..in遍历对象的时候，会发现下面的情况： 12345678&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123;console.log(key)&#125;&lt;/script&gt; 最后在谷歌的控制台中会输出: name age aaa 这说明在使用for..in 遍历对象的时候默认会把自己私有的和它所属类的原型上扩展的属性和方法都可以遍历到，但是一般情况下，我们遍历对象只需要遍历私有的即可，我们可以使用以下的判断进行处理：12345678910&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123; if(obj.propertyIsEnumerable(key))&#123;console.log(key) &#125; &#125;&lt;/script&gt; propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false，下面为大家介绍下其具体的使用：propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false 1、这个属性必须属于实例的,并且不属于原型. 2、这个属性必须是可枚举的,也就是自定义的属性,可以通过for..in循环出来的 只有符合上面这两个要求，才会返回true。因为在使用for…in遍历对象对象的时候，在前面加一个这个方法来判断一下，原型上的自己定义的属性就不会被遍历出来了。 也可以用下面的方法来只遍历出对象中的私有属性： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123; if(obj.hasOwnProperty(key))&#123;console.log(key) &#125; &#125;&lt;/script&gt; hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。只遍历出私有私有属性，而不会遍历出原型链上的属性。 加上这两个判断之后，控制台中会输出同样的结果，结果是： name age Object.create(proObj):创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6-8不兼容（ECMAScript5），用下面的代码解释： 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123; getX: function () &#123; &#125; &#125;; var obj2 = Object.create(obj); obj.getY = function () &#123; console.log(2) &#125;; obj2.getY(); console.log(obj2); console.log(obj);&lt;/script&gt; 最谷歌控制台中输出的结果如图所示:2是执行 obj2.getY();输出的结果，中间的这个是obj2，最后这个是obj，可以看出，通过执行Object.create(obj)这个方法，创建出来了obj2这个对象，并且把，并且还把obj作为这个对象的原型。可以看出，在obj2和Object这个基类之间多了一个原型链。而这一级的对象就是obj。 原型继承 1、 原型继承是”JS”中最常用的一种继承方式,子类B想要继承父类A中的所有的属性和方法（私有 +公有），只需要让B.prototype=new A,即可。 2、 原型继承的特点：它是把父类私有的+公有的都继承到了子类的原型上（子类公有的）; 3、核心:原型链继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是B和A之间增加了原型链的链接看，以后B的实例n想要用A中的getX方法，需要一级级的查找来使用。代码就这样表示 123456789&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; function B()&#123; this.y=200; &#125; B.prototype=new A;&lt;/script&gt; 二、call继承call继承的最终结果是把父类私有的属性和方法克隆一份一模一样的，作为子类私有的属性和方法 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B()&#123; A.call(this); &#125; var n=new B; console.log(n.x);&lt;/script&gt; 最后在控制台中最终会输出100，为什么了？new B是创建B这个类的一个实例，在函数B中的this就是这个实例，这里表示的就是n,A.call(this)指的是把函数A中的this变为函数B中的this，而new B之后函数B中的this是n，所以最后在控制台中输出的是100。 三、冒充对象继承冒充对象继承：把父类私有的+公有的克隆一份一模一样给子类私有的。代码用下面的来表示 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; var temp=new A; for(var key in temp)&#123; this[key]=temp[key]; &#125; temp=null; &#125; var n=new B;&lt;/script&gt; 四、混合模式继承混合模式继承：指的是原型继承+call继承 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; A.call(this); &#125; B.prototype=new A; B.prototype.constructor=B; var n=new B;&lt;/script&gt; 这种继承方式会让父类私有的和公有的都会在子类公有的上面有一份，但是在原型链查找的时候会先查找私有属性，所以也不影响整体。优点是父级私有属性都放在子类的私有上了。 五、寄生组合式继承父类公有的给子类公有的，父类私有的给子类私有的。 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; A.call(this); &#125; B.prototype=Object.create(A.prototype);//这句代码的含义是把B的原型的地址换成了A的原型的地址。 B.prototype.constructor=B; var n=new B;&lt;/script&gt; 六、中间类继承法-&gt;IE下不兼容这段代码是一个数组，在去掉一个最大值和最小值之后求它的平均值。 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; function avgFn() &#123; Array.prototype.sort.call(arguments,function (a,b) &#123; return a-b; &#125;); Array.prototype.pop.call(arguments); Array.prototype.shift.call(arguments); return (eval(Array.prototype.join.call(arguments,&quot;+&quot;))/arguments.length).toFixed(2); &#125; console.log(avgFn(10,20,30,34,44))//-&gt;结果是28&lt;/script&gt; 使用中间类继承法：代码入下面所示 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; function avgFn() &#123; arguments.__proto__= Array.prototype; arguments.sort(function(a,b)&#123; return a-b; &#125;); arguments.pop(); arguments.shift(); return eval(arguments.join(&quot;+&quot;))/arguments.length; &#125; console.log(avgFn(10,20,30,34,44))//-&gt;结果是28&lt;/script&gt; 这就是直接借用原型链的机制来形成的一种继承方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP]]></title>
    <url>%2F2017%2F11%2F03%2FJSONP%2F</url>
    <content type="text"><![CDATA[综述JSONP和AJAX相同，都是向客户端向服务器发送请求:给服务器传递数据或者从服务器端获取数据的方式。但是他们两种方式之间是有区别的：JSONP属于非同源策略（跨域请求），说明一下，实现跨越的方式有很多种，只不过JSONP是最常用的；而AJAX是属于同源策略。 同源和非同源的区别同源和非同源的区别在于用当前页面的地址于数据请求的接口地址相比较：比如当前页面地址是：https://www.zhihu.com/people/fanzhanxiang;数据请求接口的地址是：https://github.com/fanzhanxiang；判断是使用AJAX请求还是JSONP请求我们需要看以下三个方面。 1、协议 2、域名 3、端口号 上面三个部分完全相同属于同源策略，我们使用AJAX获取数据；只要有一个不一样的，就属于非同源，我们一般使用JSONP来获取数据。就比如上面这两个地址，他们的协议（https和https）、域名（www.zhihu.com和github.com）、端口号（443和443）端口号和域名不一样，因此想要在当前页面中获取这个数据请求的地址需要使用非同源策略。 JSONP的原理JSOPN是利用在JavaScript中的script标签的特性，在script的世界中，没有跨域同源一说，只要你给它的SRC属性中的地址是一个合法的地址，script都可以把对应的内容请求回来。 JSONP就是利用了这个原理(JSONP请求一定需要对方的服务器做支持才可以)： 1、我们首先把需要请求数据的那个API数据接口的地址，赋值给script的SRC 2、把当前页面中的某一个函数名当做参数值传递给需要跨域请求数据的服务器（URL问号传参一 般都是这么写:canllback=fn） 3、服务器接到你的请求之后，需要进行特殊的处理：把你传递进来的函数名和他需要给你的数据 拼接成一个字符串，例如：我们传递进去的函数名是fn，它准备好的数据是&apos;fn(需要给我们的数 据)&apos;； 4、最后服务器把准备的数据通过HTTP协议返回给客户端，其实就是让我们的fn执行，而且还给fn 传递了一堆数据，那些数据就是我们想要的； 比如下面这个例子 12345678910&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fn(data)&#123; console.log(data); &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;http:// matchweb.sports.qq.com/kbs/calendar?columnId=100000&amp;callback=fn&quot;&gt; &lt;/script&gt; &lt;/body&gt; 在谷歌控制台中的输出入下图所示： jQuery的AJAX和JSONP调用AJAX请求 12345678910111213141516&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url:&quot;地址&quot;, type:&quot;请求方式&quot;, dataType:&quot;json&quot;, data:null,//-&gt;使用post请求是非服务器传递的内容 async:true,//-&gt;同步还是异步，默认是异步 cache:false,//设定GET请求的时候不走缓存数据，原理其实就是在URL末尾加随机数，默认值是true timeout:1000,//设置超时时间 一般都设定3000ms，超过时间之后就跑到error success:function(data)&#123;//-&gt;data是请求回来的数据 console.log(data); &#125;, error:function()&#123;&#125;,//请求失败的时候执行这个 &#125;);&lt;/script&gt; JSONP请求JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，而且jQuery会默认就会给JSONP的请求清除缓存 123456789101112&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url: &quot;请求地址&quot;, dataType: &quot;jsonp&quot;, jsonpCallback: &quot;fn&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的 jsonp:&quot;cb&quot;,//-&gt;把传递函数名的那个形参callback变为cb success: function (data) &#123; console.log(data); &#125; &#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>JSONP</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F10%2F31%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax:async javascript and xml 叫做异步的JS和XML(可扩展标记语言)，它是一种客户端的JS方法，用来向服务器端发送请求(还可以传递给服务器数据)，然后把服务器端返回的内容获取到，它一般运行在客户端的浏览器中的。 Ajax的四个步骤 12341、var xhr=new XMLHttpRequest; 2、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]); 3、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text (xhr.status))&#123;var val=xhr.responseText&#125; &#125;; 4、xhr.send(&quot;要传递给服务器的内容&quot;); 1、第一步11、var xhr=new XMLHttpRequest; 创建一个AJAX对象（在IE6及更低版本的浏览器中不兼容） 2、第二步12、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]); 发送前的基本信息配置：配置请求方式，请求方式有GET、POST、PUT、DELETE、HEAD，上面是几种方式不管是哪一种都可以向服务器传递数据，也可以从服务器获取到数据，而且从本质意义上来讲上面几种请求方式是没有什么区别的，例如用POST做的事情用GET也能做。以下区别都是开发者约定俗成的规范； 1、GET：一般应用于从服务器获取数据（给服务器的少，从服务器拿的数据多），使用GET请求给服 务器传递内容，我们一般都使用&quot;URL问号传参的方式&quot;；例如：xhr.open(&quot;get&quot;,&quot;/getList?num =2&quot;),但是这种方式传递的内容存在大小限制；因为GET通过URL传参给服务器，而每个浏览器对于 URL的长度存在限制，谷歌8kb、火狐7kb、IE2kb的长度限制，如果URL的长度超过限制，浏览器 会把超出的部分的截取。并且这个请求会出现缓存（这个缓存不一定304）。在项目中我们的GET请 求一般不会让其出现缓存，因此要清除缓存，清除GET请求缓存的方法是在URL的末尾加一个随机数 xhr.open(&quot;get&quot;,&quot;/getList?num =2&amp;_=&quot;+Math.random());在用get请求的时候与post 相比，是不安全的 2、POST：一般应用于向服务器推送数据（给服务器的多，从服务器上拿的少），我们一般使用&quot;请求 主体的方式&quot;传递给服务器，例如：xhr.open(&quot;post&quot;,&quot;/getList&quot;);xhr.send(&apos;{&quot;name &quot;:&quot;zhufeng&quot;,&quot;age&quot;:7&apos;)，这种传递方式理论上是没有大小限制的，并且这个请求是没有缓存的。 3、PUT：一般应用于给服务器上传资源文件（我们上传图片功能） 4、DELETE：一般应用于从服务器上删除资源文件 5、HEAD：一般应用于只获取服务器的响应头信息 第三个参数默认是异步；username:向服务器提供的用户名,userpass:向服务器提供的用户密码，这两个值一般都不写，只有服务器做了安全限制，只允许特定的用户访问，我们才传递过去。 3、第三步这一步不是必须的，如果自己不要拿回数据的话，就可以不需要执行这步，那么ajax只需要三步就可以完成。13、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text(xhr.status))&#123;var val=xhr.responseText&#125;&#125;; 给onreadyStatechange这个事件绑定一个方法，监听状态的改变(只要状态改变，就会触发这个事件绑定的相应方法执行)； xhr.readyState：AJAX状态码其中有5个值（0,1,2,3,4），可以代表当前AJAX处理的进度。 0：&quot;unset&quot;，表示当前的请求还没有发送； 1：&quot;opened&quot;,表示URL地址已经打开(发送前的参数配置已经完成)； 2：&quot;headers_received&quot;,表示响应头信息已经接收； 3：&quot;loading&quot;,主要返回的内容正在服务器端进行准备处理； 4：&quot;done&quot;:响应主体的内容已经成功返回客户端。 xhr.status:HTTP网络状态码，描述了服务器响应内容的状态，HTTP网络状态码有如下几种： 200 OR ^2\d{2}： (200或者以2开头的)都代表响应主体的内容已经成功返回了 301：永久重定向/永久转移 302：临时重定向/临时转移,服务器的负载均衡 304：本次获取的内容是读取缓存中的数据 400:客户端传递给服务器端的参数出现错误，客户端传递的参数有问题 401：无权限访问 404：访问的地址不存在 500：未知的服务器错误 503：服务器已经超负荷了，比如能承受10000人，那么第10001个人访问，如果没有做服务器的负载均 衡（302），那么这个人的状态码就是503; 4、第四步14、xhr.send(&quot;要传递给服务器的内容&quot;); 发送请求：参数是请求主体中给传递给服务器的内容；只有执行完第四步之后才开始一个AJAX请求。 补充：AJAX中的同步和异步AJAX中的同步：当AJAX任务开始的时候(XHR.SEND),一直需要到READYSTATE===4的时候任务才结束，此时才可以处理其它的事情。并且只有当其它的任务完成后，我们再看是否到4，到4之后做一些相关的操作。 AJAX中的异步：当AJAX任务开始的时候(XHR.SEND),不需要到READYSTATE===4，我依然可以处理其它的事情。 下面是几个同步编程和异步编程的几个编程题 1、问：下面的会在控制台输出几次，输出的分别是什么？ 123456var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.onreadyStatechange=function()&#123;console.log(xhr.readyState); &#125;; xhr.send(null); 答案：会输出三次，分别是2、3、4原因：因为第三个参数是true，所以这里是异步编程，所以绑定了xhr.onreadyStatechange这个事件一个方法，只要AJAX状态码发生改变，就会执行对应的这个事件绑定的对应方法。因为在open之后AJAX状态码已经变为了，所以当由1变到2的过程中，就会触发这个事件，对应后面从2到3,3到4也是这个原理，所以最终会输出三次，值分别：2、3、4 2、问：下面的会在控制台输出几次，输出的分别是什么？ 123456var xhr=new XMLHttpRequest; xhr.onreadyStatechange=function()&#123;console.log(xhr.readyState); &#125;; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null); 答案：会输出四次，分别是1、2、3、4。原因：因为这里open之前就已经绑定了这个方法，所以AJAX状态码从0变到了的过程中就会触发这个方法，所以会输出1； 3、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; xhr.send(null); 答案：会输出一次，是4。原因：代码上到下执行，当AJAX状态码为1的时候为onreadyStatechange这个事件绑定了一个方法，然后当任务执行完成之后，AJAX状态码变为4，触发这个事件，输出4。 4、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; 答案：会输出3次，分别是2、3、4 5、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.send(null); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; 答案：0次，什么都不输出原因：采用同步编程，在AJAX状态码变为4之前，什么都不做，而且在这之前也没有绑定xhr.onreadyStatechange事件，所以在这之前什么都不会做。也没有记录对应的AJAX状态码状态码值，在AJAX状态码变为4之后，绑定了一个事件，但是后面AJAX状态码不会变了，因此永远不会触发事件。]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM0级事件绑定和DOM2级事件及其扩展]]></title>
    <url>%2F2017%2F10%2F27%2FDOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在页面上写一个id为box的一个div，然后设置一些它的宽度和高度，然后在后面在做事件绑定的时使用。先是使用DOM0级事件绑定。 12box.onclick=function()&#123;console.log(1)&#125;; box.onclick=function()&#123;console.log(2)&#125;; 后面这个事件会把前一个事件给覆盖掉，最后在控制台中只会输出一个2.因为在使用DOM0级事件绑定的时候，只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉（这里主要是某一个行为绑定一次方法，不同的行为是可以绑定同一个方法的，比如这里是1box.onclick=function()&#123;console.log(2)&#125;; 这里是可以输出2的）；所以最后在控制台只能输出一次2。DOM0级事件绑定和DOM2级事件绑定最大的区别也是在这里，但是DOM2级事件中也有一些其他特别的地方。 1、基础；当我们使用DOM2级事件绑定，它的原理是让box通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现的。DOM2级事件绑定解决了DOM0级事件绑定中“只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉”这个问题，比如下面代码 12box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false); box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false); 点击box的时候，控制台上输出了1和2，方法中的第三个参数false表示的是该事件在冒泡阶段触发。总结出DOM2级事件可以给某一个元素的同一个行为绑定多个不同的方法。 2、DOM2； DOMO中行为类型，我们用DOM2一样可以绑定；而且DOM2中还提供了DOM0中没有的行为类型，比如DOM2中有一个行为DOMContentLoaded（当页面中的DOM结构或者是叫HTML结构加载完成触发的行为）这个行为是DOM0中没有的。像这个事件的绑定是这样的。 12document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;&#125;,false) ; window.onload=function()&#123;&#125;; 上面的两个事件绑定是有区别的，这个代表的意思是当页面中所有的资源都加载完成（图片、HTML结构、音视频…）才会执行后面的函数；并且在一个页面中只能使用一次，后面再写会把前面的覆盖掉，因为它是DOM0事件绑定，所以只能绑定一次。并且在jQuery中也提供了类似的方法 ： 1$(document).ready(function()&#123;&#125;)---&gt;$(function()&#123;&#125;); 只要也拿中的HTML结构加载完成就会执行对应的函数；并且在一个页面中可以出现多次，因为jQuery在写这个方法的时候是使用DOM2级事件绑定来写的，并且绑定的行为是DOM2中的“DOMContentLoaded”这个行为来绑定的。 3、移除DOM2事件绑定：前面两行代码中，里面的this是box，这里并不能移除事件绑定，因为两个匿名函数是两个不同的堆内存，因此不能移除事件绑定；把匿名函数换成实名函数就可以了，比如后面两行代码： 1234box.addEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false); box.removeEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false)； function fn1()&#123;console.log(this)&#125;； box.removeEventListener(&quot;click&quot;,fn1,false)； 这里就可以实现移除了，并且在控制台中不会输出任何东西，因为在刚绑定的时候就已经移除了。移除的时候需要保证三个参数：行为、方法、那个阶段发生，一个都不能差，因为在使用DOM2事件绑定的时候，我们一般绑定的都是实名函数，如果这样：1box.removeEventListener(&quot;click&quot;,fn1,true)； 就移除掉了，还会输出this； 4、注意点只能给某个元素的同一个行为绑定多个“不同”的方法（如果方法相同了，只能留一个），例如： 123function fn1()&#123;console.log(1)&#125;； box.removeEventListener (&quot;click&quot;,fn1,false)； box.removeEventListener(&quot;click&quot;,fn1,false)； 在点击的时候只会输出一个1。当行为触发，会按照绑定的先后顺序依次把绑定的方法执行；执行的方法中的this是当前被绑定事件的本身。并且在绑定方法的时候，浏览器天生自带的一个东西叫事件池（也有叫程序池的），用来存储绑定的事件的。 但是在IE6~8浏览器中不支持addEventListener/removeEventListener,如果想要实现DOM2级事件绑定只能用attachEvent,移除是使用detachEvent。 box.attachEvent(“onclick”,fn1); 并且它只有两个参数，不能向addEventListener那样控制在那个阶段发生，只能在冒泡阶段发生，行为需要添加”on”,和DOM0特别类似]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客的感受]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天注册了一个hexo+GitHub的一个博客。下面的是一些自己一些的感受。改天有时间写一个详细版的教程关于建立个人博客的。虽然网上已经有很多了，但是自己还是有不少想要分享的地方，下面的是最简单的几点，也是自己写的第一篇博客。 1、_config的语法非常严谨、当你要用里面的语法的时候首先需要做的一件事情把对应地方的#去掉，如果不把你想要设置的对应的地方的#去掉，当你在执行hexo g的时候会报或者是 你设置的这个地方对应的效果没有效果。 2、_config在设置的时候，”：“后面必须一个空格，这也是因为_config的语法比较严谨的原因 3、GitHub有缓存时间，这是一个比较令人头疼的问题，自己在_config设置完所有的参数之后，然后执行hexo g、hexo d.然后是过了几分钟之后自己打开了自己博客，发现竟然返回了404页面，当时也是比较懵逼的，然后就一直谷歌上面各种找原因。看到一个人回答说是GitHub的缓存原因。这才放心，后面等了一会儿之后设置的东西相应的显示出来了。 总结：总的来说大体常见的问题就是这些。在打扮博客的过程中肯定会碰到各种各样的问题，抽时间来一个大总结。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
