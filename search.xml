<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript中检测兼容的三种方式]]></title>
    <url>%2F2017%2F11%2F04%2FJS%E6%A3%80%E6%B5%8B%E5%85%BC%E5%AE%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、使用try、catch来处理兼容前提：必须保证try中的代码在不兼容浏览器中执行的时候报错，这样的话我们才可以用catch捕获到异常的信息，进行其它的处理，示例代码如下面所示。缺点：不管是什么浏览器，都需要把try中的代码都需要把try中的代码执行一遍，如果当前是IE7。window.getComputedStyle本身是不兼容的，但是我们也要把它先执行一遍，报错了再把curEle.currentStyle执行一遍（消耗性能），因此使用try处理兼容只有在万不得已的情况下才使用它。 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123;//-&gt;curEle指的是操作的元素，attr指的是元素属性 var val=null; try&#123; val=window.getComputedStyle(curEle,null)[attr]; &#125;catch(e)&#123; val=curEle.currentStyle[attr]; &#125; return val; &#125;&lt;/script&gt; 二、判断当期浏览器中是否存在这个属性和方法判断当期浏览器中是否存在这个属性和方法，存在就兼容，不存在就不兼容。代码如下所示 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123; var val = null; if (getComputedStyle in window) &#123;//-&gt;如果返回结果是true，说明Window下有getComputedStyle，代表兼容 val = window.getComputedStyle(curEle, null)[attr]; &#125; else &#123; val = curEle.currentStyle[attr]; &#125; return val; &#125;&lt;/script&gt; 三、通过检测浏览器版本和类型来处理兼容代码如下所示： 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123; var val = null; if (/MSIE(6|7|8)/.test(navigator.userAgent)) &#123;//-&gt;说明是IE6-8浏览器 val = curEle.currentStyle[attr]; &#125; else &#123; val = window.getComputedStyle(curEle, null)[attr]; &#125; return val; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中常用的六种继承方式]]></title>
    <url>%2F2017%2F11%2F04%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、原型链继承可枚举和不可枚举：我们在JavaScript中使用for..in遍历对象的时候，会发现下面的情况： 12345678&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123;console.log(key)&#125;&lt;/script&gt; 最后在谷歌的控制台中会输出: name age aaa 这说明在使用for..in 遍历对象的时候默认会把自己私有的和它所属类的原型上扩展的属性和方法都可以遍历到，但是一般情况下，我们遍历对象只需要遍历私有的即可，我们可以使用以下的判断进行处理：12345678910&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123; if(obj.propertyIsEnumerable(key))&#123;console.log(key) &#125; &#125;&lt;/script&gt; propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false，下面为大家介绍下其具体的使用：propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false 1、这个属性必须属于实例的,并且不属于原型. 2、这个属性必须是可枚举的,也就是自定义的属性,可以通过for..in循环出来的 只有符合上面这两个要求，才会返回true。因为在使用for…in遍历对象对象的时候，在前面加一个这个方法来判断一下，原型上的自己定义的属性就不会被遍历出来了。 也可以用下面的方法来只遍历出对象中的私有属性： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123; if(obj.hasOwnProperty(key))&#123;console.log(key) &#125; &#125;&lt;/script&gt; hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。只遍历出私有私有属性，而不会遍历出原型链上的属性。 加上这两个判断之后，控制台中会输出同样的结果，结果是： name age Object.create(proObj):创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6-8不兼容（ECMAScript5），用下面的代码解释： 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123; getX: function () &#123; &#125; &#125;; var obj2 = Object.create(obj); obj.getY = function () &#123; console.log(2) &#125;; obj2.getY(); console.log(obj2); console.log(obj);&lt;/script&gt; 最谷歌控制台中输出的结果如图所示:2是执行 obj2.getY();输出的结果，中间的这个是obj2，最后这个是obj，可以看出，通过执行Object.create(obj)这个方法，创建出来了obj2这个对象，并且把，并且还把obj作为这个对象的原型。可以看出，在obj2和Object这个基类之间多了一个原型链。而这一级的对象就是obj。 原型继承 1、 原型继承是”JS”中最常用的一种继承方式,子类B想要继承父类A中的所有的属性和方法（私有 +公有），只需要让B.prototype=new A,即可。 2、 原型继承的特点：它是把父类私有的+公有的都继承到了子类的原型上（子类公有的）; 3、核心:原型链继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是B和A之间增加了原型链的链接看，以后B的实例n想要用A中的getX方法，需要一级级的查找来使用。代码就这样表示 123456789&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; function B()&#123; this.y=200; &#125; B.prototype=new A;&lt;/script&gt; 二、call继承call继承的最终结果是把父类私有的属性和方法克隆一份一模一样的，作为子类私有的属性和方法 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B()&#123; A.call(this); &#125; var n=new B; console.log(n.x);&lt;/script&gt; 最后在控制台中最终会输出100，为什么了？new B是创建B这个类的一个实例，在函数B中的this就是这个实例，这里表示的就是n,A.call(this)指的是把函数A中的this变为函数B中的this，而new B之后函数B中的this是n，所以最后在控制台中输出的是100。 三、冒充对象继承冒充对象继承：把父类私有的+公有的克隆一份一模一样给子类私有的。代码用下面的来表示 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; var temp=new A; for(var key in temp)&#123; this[key]=temp[key]; &#125; temp=null; &#125; var n=new B;&lt;/script&gt; 四、混合模式继承混合模式继承：指的是原型继承+call继承 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; A.call(this); &#125; B.prototype=new A; B.prototype.constructor=B; var n=new B;&lt;/script&gt; 这种继承方式会让父类私有的和公有的都会在子类公有的上面有一份，但是在原型链查找的时候会先查找私有属性，所以也不影响整体。优点是父级私有属性都放在子类的私有上了。 五、寄生组合式继承父类公有的给子类公有的，父类私有的给子类私有的。 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; A.call(this); &#125; B.prototype=Object.create(A.prototype);//这句代码的含义是把B的原型的地址换成了A的原型的地址。 B.prototype.constructor=B; var n=new B;&lt;/script&gt; 六、中间类继承法-&gt;IE下不兼容这段代码是一个数组，在去掉一个最大值和最小值之后求它的平均值。 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; function avgFn() &#123; Array.prototype.sort.call(arguments,function (a,b) &#123; return a-b; &#125;); Array.prototype.pop.call(arguments); Array.prototype.shift.call(arguments); return (eval(Array.prototype.join.call(arguments,&quot;+&quot;))/arguments.length).toFixed(2); &#125; console.log(avgFn(10,20,30,34,44))//-&gt;结果是28&lt;/script&gt; 使用中间类继承法：代码入下面所示 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; function avgFn() &#123; arguments.__proto__= Array.prototype; arguments.sort(function(a,b)&#123; return a-b; &#125;); arguments.pop(); arguments.shift(); return eval(arguments.join(&quot;+&quot;))/arguments.length; &#125; console.log(avgFn(10,20,30,34,44))//-&gt;结果是28&lt;/script&gt; 这就是直接借用原型链的机制来形成的一种继承方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP]]></title>
    <url>%2F2017%2F11%2F03%2FJSONP%2F</url>
    <content type="text"><![CDATA[综述JSONP和AJAX相同，都是向客户端向服务器发送请求:给服务器传递数据或者从服务器端获取数据的方式。但是他们两种方式之间是有区别的：JSONP属于非同源策略（跨域请求），说明一下，实现跨越的方式有很多种，只不过JSONP是最常用的；而AJAX是属于同源策略。 同源和非同源的区别同源和非同源的区别在于用当前页面的地址于数据请求的接口地址相比较：比如当前页面地址是：https://www.zhihu.com/people/fanzhanxiang;数据请求接口的地址是：https://github.com/fanzhanxiang；判断是使用AJAX请求还是JSONP请求我们需要看以下三个方面。 1、协议 2、域名 3、端口号 上面三个部分完全相同属于同源策略，我们使用AJAX获取数据；只要有一个不一样的，就属于非同源，我们一般使用JSONP来获取数据。就比如上面这两个地址，他们的协议（https和https）、域名（www.zhihu.com和github.com）、端口号（443和443）端口号和域名不一样，因此想要在当前页面中获取这个数据请求的地址需要使用非同源策略。 JSONP的原理JSOPN是利用在JavaScript中的script标签的特性，在script的世界中，没有跨域同源一说，只要你给它的SRC属性中的地址是一个合法的地址，script都可以把对应的内容请求回来。 JSONP就是利用了这个原理(JSONP请求一定需要对方的服务器做支持才可以)： 1、我们首先把需要请求数据的那个API数据接口的地址，赋值给script的SRC 2、把当前页面中的某一个函数名当做参数值传递给需要跨域请求数据的服务器（URL问号传参一 般都是这么写:canllback=fn） 3、服务器接到你的请求之后，需要进行特殊的处理：把你传递进来的函数名和他需要给你的数据 拼接成一个字符串，例如：我们传递进去的函数名是fn，它准备好的数据是&apos;fn(需要给我们的数 据)&apos;； 4、最后服务器把准备的数据通过HTTP协议返回给客户端，其实就是让我们的fn执行，而且还给fn 传递了一堆数据，那些数据就是我们想要的； 比如下面这个例子 12345678910&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fn(data)&#123; console.log(data); &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;http:// matchweb.sports.qq.com/kbs/calendar?columnId=100000&amp;callback=fn&quot;&gt; &lt;/script&gt; &lt;/body&gt; 在谷歌控制台中的输出入下图所示： jQuery的AJAX和JSONP调用AJAX请求 12345678910111213141516&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url:&quot;地址&quot;, type:&quot;请求方式&quot;, dataType:&quot;json&quot;, data:null,//-&gt;使用post请求是非服务器传递的内容 async:true,//-&gt;同步还是异步，默认是异步 cache:false,//设定GET请求的时候不走缓存数据，原理其实就是在URL末尾加随机数，默认值是true timeout:1000,//设置超时时间 一般都设定3000ms，超过时间之后就跑到error success:function(data)&#123;//-&gt;data是请求回来的数据 console.log(data); &#125;, error:function()&#123;&#125;,//请求失败的时候执行这个 &#125;);&lt;/script&gt; JSONP请求JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，而且jQuery会默认就会给JSONP的请求清除缓存 123456789101112&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url: &quot;请求地址&quot;, dataType: &quot;jsonp&quot;, jsonpCallback: &quot;fn&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的 jsonp:&quot;cb&quot;,//-&gt;把传递函数名的那个形参callback变为cb success: function (data) &#123; console.log(data); &#125; &#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>JSONP</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F10%2F31%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax:async javascript and xml 叫做异步的JS和XML(可扩展标记语言)，它是一种客户端的JS方法，用来向服务器端发送请求(还可以传递给服务器数据)，然后把服务器端返回的内容获取到，它一般运行在客户端的浏览器中的。 Ajax的四个步骤 12341、var xhr=new XMLHttpRequest; 2、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]); 3、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text (xhr.status))&#123;var val=xhr.responseText&#125; &#125;; 4、xhr.send(&quot;要传递给服务器的内容&quot;); 1、第一步11、var xhr=new XMLHttpRequest; 创建一个AJAX对象（在IE6及更低版本的浏览器中不兼容） 2、第二步12、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]); 发送前的基本信息配置：配置请求方式，请求方式有GET、POST、PUT、DELETE、HEAD，上面是几种方式不管是哪一种都可以向服务器传递数据，也可以从服务器获取到数据，而且从本质意义上来讲上面几种请求方式是没有什么区别的，例如用POST做的事情用GET也能做。以下区别都是开发者约定俗成的规范； 1、GET：一般应用于从服务器获取数据（给服务器的少，从服务器拿的数据多），使用GET请求给服 务器传递内容，我们一般都使用&quot;URL问号传参的方式&quot;；例如：xhr.open(&quot;get&quot;,&quot;/getList?num =2&quot;),但是这种方式传递的内容存在大小限制；因为GET通过URL传参给服务器，而每个浏览器对于 URL的长度存在限制，谷歌8kb、火狐7kb、IE2kb的长度限制，如果URL的长度超过限制，浏览器 会把超出的部分的截取。并且这个请求会出现缓存（这个缓存不一定304）。在项目中我们的GET请 求一般不会让其出现缓存，因此要清除缓存，清除GET请求缓存的方法是在URL的末尾加一个随机数 xhr.open(&quot;get&quot;,&quot;/getList?num =2&amp;_=&quot;+Math.random());在用get请求的时候与post 相比，是不安全的 2、POST：一般应用于向服务器推送数据（给服务器的多，从服务器上拿的少），我们一般使用&quot;请求 主体的方式&quot;传递给服务器，例如：xhr.open(&quot;post&quot;,&quot;/getList&quot;);xhr.send(&apos;{&quot;name &quot;:&quot;zhufeng&quot;,&quot;age&quot;:7&apos;)，这种传递方式理论上是没有大小限制的，并且这个请求是没有缓存的。 3、PUT：一般应用于给服务器上传资源文件（我们上传图片功能） 4、DELETE：一般应用于从服务器上删除资源文件 5、HEAD：一般应用于只获取服务器的响应头信息 第三个参数默认是异步；username:向服务器提供的用户名,userpass:向服务器提供的用户密码，这两个值一般都不写，只有服务器做了安全限制，只允许特定的用户访问，我们才传递过去。 3、第三步这一步不是必须的，如果自己不要拿回数据的话，就可以不需要执行这步，那么ajax只需要三步就可以完成。13、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text(xhr.status))&#123;var val=xhr.responseText&#125;&#125;; 给onreadyStatechange这个事件绑定一个方法，监听状态的改变(只要状态改变，就会触发这个事件绑定的相应方法执行)； xhr.readyState：AJAX状态码其中有5个值（0,1,2,3,4），可以代表当前AJAX处理的进度。 0：&quot;unset&quot;，表示当前的请求还没有发送； 1：&quot;opened&quot;,表示URL地址已经打开(发送前的参数配置已经完成)； 2：&quot;headers_received&quot;,表示响应头信息已经接收； 3：&quot;loading&quot;,主要返回的内容正在服务器端进行准备处理； 4：&quot;done&quot;:响应主体的内容已经成功返回客户端。 xhr.status:HTTP网络状态码，描述了服务器响应内容的状态，HTTP网络状态码有如下几种： 200 OR ^2\d{2}： (200或者以2开头的)都代表响应主体的内容已经成功返回了 301：永久重定向/永久转移 302：临时重定向/临时转移,服务器的负载均衡 304：本次获取的内容是读取缓存中的数据 400:客户端传递给服务器端的参数出现错误，客户端传递的参数有问题 401：无权限访问 404：访问的地址不存在 500：未知的服务器错误 503：服务器已经超负荷了，比如能承受10000人，那么第10001个人访问，如果没有做服务器的负载均 衡（302），那么这个人的状态码就是503; 4、第四步14、xhr.send(&quot;要传递给服务器的内容&quot;); 发送请求：参数是请求主体中给传递给服务器的内容；只有执行完第四步之后才开始一个AJAX请求。 补充：AJAX中的同步和异步AJAX中的同步：当AJAX任务开始的时候(XHR.SEND),一直需要到READYSTATE===4的时候任务才结束，此时才可以处理其它的事情。并且只有当其它的任务完成后，我们再看是否到4，到4之后做一些相关的操作。 AJAX中的异步：当AJAX任务开始的时候(XHR.SEND),不需要到READYSTATE===4，我依然可以处理其它的事情。 下面是几个同步编程和异步编程的几个编程题 1、问：下面的会在控制台输出几次，输出的分别是什么？ 123456var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.onreadyStatechange=function()&#123;console.log(xhr.readyState); &#125;; xhr.send(null); 答案：会输出三次，分别是2、3、4原因：因为第三个参数是true，所以这里是异步编程，所以绑定了xhr.onreadyStatechange这个事件一个方法，只要AJAX状态码发生改变，就会执行对应的这个事件绑定的对应方法。因为在open之后AJAX状态码已经变为了，所以当由1变到2的过程中，就会触发这个事件，对应后面从2到3,3到4也是这个原理，所以最终会输出三次，值分别：2、3、4 2、问：下面的会在控制台输出几次，输出的分别是什么？ 123456var xhr=new XMLHttpRequest; xhr.onreadyStatechange=function()&#123;console.log(xhr.readyState); &#125;; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null); 答案：会输出四次，分别是1、2、3、4。原因：因为这里open之前就已经绑定了这个方法，所以AJAX状态码从0变到了的过程中就会触发这个方法，所以会输出1； 3、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; xhr.send(null); 答案：会输出一次，是4。原因：代码上到下执行，当AJAX状态码为1的时候为onreadyStatechange这个事件绑定了一个方法，然后当任务执行完成之后，AJAX状态码变为4，触发这个事件，输出4。 4、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; 答案：会输出3次，分别是2、3、4 5、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.send(null); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; 答案：0次，什么都不输出原因：采用同步编程，在AJAX状态码变为4之前，什么都不做，而且在这之前也没有绑定xhr.onreadyStatechange事件，所以在这之前什么都不会做。也没有记录对应的AJAX状态码状态码值，在AJAX状态码变为4之后，绑定了一个事件，但是后面AJAX状态码不会变了，因此永远不会触发事件。]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM0级事件绑定和DOM2级事件及其扩展]]></title>
    <url>%2F2017%2F10%2F27%2FDOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在页面上写一个id为box的一个div，然后设置一些它的宽度和高度，然后在后面在做事件绑定的时使用。先是使用DOM0级事件绑定。 12box.onclick=function()&#123;console.log(1)&#125;; box.onclick=function()&#123;console.log(2)&#125;; 后面这个事件会把前一个事件给覆盖掉，最后在控制台中只会输出一个2.因为在使用DOM0级事件绑定的时候，只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉（这里主要是某一个行为绑定一次方法，不同的行为是可以绑定同一个方法的，比如这里是1box.onclick=function()&#123;console.log(2)&#125;; 这里是可以输出2的）；所以最后在控制台只能输出一次2。DOM0级事件绑定和DOM2级事件绑定最大的区别也是在这里，但是DOM2级事件中也有一些其他特别的地方。 1、基础；当我们使用DOM2级事件绑定，它的原理是让box通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现的。DOM2级事件绑定解决了DOM0级事件绑定中“只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉”这个问题，比如下面代码 12box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false); box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false); 点击box的时候，控制台上输出了1和2，方法中的第三个参数false表示的是该事件在冒泡阶段触发。总结出DOM2级事件可以给某一个元素的同一个行为绑定多个不同的方法。 2、DOM2； DOMO中行为类型，我们用DOM2一样可以绑定；而且DOM2中还提供了DOM0中没有的行为类型，比如DOM2中有一个行为DOMContentLoaded（当页面中的DOM结构或者是叫HTML结构加载完成触发的行为）这个行为是DOM0中没有的。像这个事件的绑定是这样的。 12document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;&#125;,false) ; window.onload=function()&#123;&#125;; 上面的两个事件绑定是有区别的，这个代表的意思是当页面中所有的资源都加载完成（图片、HTML结构、音视频…）才会执行后面的函数；并且在一个页面中只能使用一次，后面再写会把前面的覆盖掉，因为它是DOM0事件绑定，所以只能绑定一次。并且在jQuery中也提供了类似的方法 ： 1$(document).ready(function()&#123;&#125;)---&gt;$(function()&#123;&#125;); 只要也拿中的HTML结构加载完成就会执行对应的函数；并且在一个页面中可以出现多次，因为jQuery在写这个方法的时候是使用DOM2级事件绑定来写的，并且绑定的行为是DOM2中的“DOMContentLoaded”这个行为来绑定的。 3、移除DOM2事件绑定：前面两行代码中，里面的this是box，这里并不能移除事件绑定，因为两个匿名函数是两个不同的堆内存，因此不能移除事件绑定；把匿名函数换成实名函数就可以了，比如后面两行代码： 1234box.addEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false); box.removeEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false)； function fn1()&#123;console.log(this)&#125;； box.removeEventListener(&quot;click&quot;,fn1,false)； 这里就可以实现移除了，并且在控制台中不会输出任何东西，因为在刚绑定的时候就已经移除了。移除的时候需要保证三个参数：行为、方法、那个阶段发生，一个都不能差，因为在使用DOM2事件绑定的时候，我们一般绑定的都是实名函数，如果这样：1box.removeEventListener(&quot;click&quot;,fn1,true)； 就移除掉了，还会输出this； 4、注意点只能给某个元素的同一个行为绑定多个“不同”的方法（如果方法相同了，只能留一个），例如： 123function fn1()&#123;console.log(1)&#125;； box.removeEventListener (&quot;click&quot;,fn1,false)； box.removeEventListener(&quot;click&quot;,fn1,false)； 在点击的时候只会输出一个1。当行为触发，会按照绑定的先后顺序依次把绑定的方法执行；执行的方法中的this是当前被绑定事件的本身。并且在绑定方法的时候，浏览器天生自带的一个东西叫事件池（也有叫程序池的），用来存储绑定的事件的。 但是在IE6~8浏览器中不支持addEventListener/removeEventListener,如果想要实现DOM2级事件绑定只能用attachEvent,移除是使用detachEvent。 box.attachEvent(“onclick”,fn1); 并且它只有两个参数，不能向addEventListener那样控制在那个阶段发生，只能在冒泡阶段发生，行为需要添加”on”,和DOM0特别类似]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客的感受]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天注册了一个hexo+GitHub的一个博客。下面的是一些自己一些的感受。改天有时间写一个详细版的教程关于建立个人博客的。虽然网上已经有很多了，但是自己还是有不少想要分享的地方，下面的是最简单的几点，也是自己写的第一篇博客。 1、_config的语法非常严谨、当你要用里面的语法的时候首先需要做的一件事情把对应地方的#去掉，如果不把你想要设置的对应的地方的#去掉，当你在执行hexo g的时候会报或者是 你设置的这个地方对应的效果没有效果。 2、_config在设置的时候，”：“后面必须一个空格，这也是因为_config的语法比较严谨的原因 3、GitHub有缓存时间，这是一个比较令人头疼的问题，自己在_config设置完所有的参数之后，然后执行hexo g、hexo d.然后是过了几分钟之后自己打开了自己博客，发现竟然返回了404页面，当时也是比较懵逼的，然后就一直谷歌上面各种找原因。看到一个人回答说是GitHub的缓存原因。这才放心，后面等了一会儿之后设置的东西相应的显示出来了。 总结：总的来说大体常见的问题就是这些。在打扮博客的过程中肯定会碰到各种各样的问题，抽时间来一个大总结。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
