<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[process.nextTick、setTimeout、setImmediate、异步ID的优先级问题]]></title>
    <url>%2F2017%2F11%2F18%2Fprocess.nextTick%E3%80%81setTimeout%E3%80%81setImmediate%E3%80%81%E5%BC%82%E6%AD%A5ID%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[上述的几种方法里面传递的函数都是异步执行的，但是他们执行的时候是有顺序的。 process.nextTick(callback)功能：在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(interval, 0) 函数的功能类似，但它的效率高多了。 通过下面的代码来比较它们的上述几种情况的优先级； 12345678910111213141516var fs=require(&apos;fs&apos;); fs.readFile(&apos;1.js&apos;,function(err,data)&#123; console.log(&quot;a: readFile&quot;) &#125;); console.log(&apos;a客人&apos;); setTimeout(function () &#123; console.log(&apos;a: setTimeout&apos;); &#125;,0); process.nextTick(function () &#123; console.log(&apos;a: nextTick1&apos;); &#125;); setImmediate(function () &#123; console.log(&apos;a: setImmediate&apos;); &#125;); console.log(&apos;b厨师&apos;); console.log(&apos;c厨师&apos;); 最后在控制台中输出结果如图所示： 得出简单的结论:他们的优先级顺序是nexttick&gt;setTimeout&gt;setImmediate&gt;异步IO 但是这里还是不能够得出看出直接比较出nexttick和setTimeout的优先级顺序，于是看下面的代码： 12345678910111213141516171819202122var fs=require(&apos;fs&apos;); fs.readFile(&apos;1.js&apos;,function(err,data)&#123; console.log(&quot;a: readFile&quot;) &#125;); console.log(&apos;a客人&apos;); setTimeout(function () &#123; console.log(&apos;a: setTimeout&apos;); &#125;,0); process.nextTick(function () &#123; console.log(&apos;a: nextTick1&apos;); process.nextTick(function () &#123; console.log(&apos;a: nextTick2&apos;); &#125;); process.nextTick(function () &#123; console.log(&apos;a: nextTick3&apos;); &#125;); &#125;); setImmediate(function () &#123; console.log(&apos;a: setImmediate&apos;); &#125;); console.log(&apos;b厨师&apos;); console.log(&apos;c厨师&apos;); 最后输出的结果如图所示： 得出结论:他们的优先级顺序是nexttick&gt;setTimeout&gt;setImmediate&gt;异步IO 注意：nexttick相当于是放在当前队列的最后一个执行，而setTimeout、setImmediate、异步IO都是在另一个队列中执行，因此nexttick永远比他们先执行。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中this]]></title>
    <url>%2F2017%2F11%2F18%2Fnode%E4%B8%ADthis%2F</url>
    <content type="text"><![CDATA[nodejs中的this和在浏览器中javascript中的this是不一样的。在全局中的this1234console.log(this); //-&gt;&#123;&#125; this.num =1; console.log(this.num); //-&gt;1 console.log(global.num); //-&gt;undefined 全局中的this默认是一个空对象。并且在全局中this与global对象没有任何的关系。那么全局中的this到底是什么了。看下面这段代码： 123var name=&quot;aba&quot;; exports.name=name; console.log(this);//-&gt;this-&gt;&#123; name: &apos;aba&apos; &#125; 全局中this会指向module.exports。 在函数中的this 1234567function fn()&#123; this.num = 1;&#125; fn(); console.log(this); /-&gt;&#123;&#125; console.log(this.num); //-&gt;undefined console.log(global.num); //-&gt;1 总结:在函数中this指向的是global对象，和全局中的this不是同一个对象，简单来说，你在函 数中通过this定义的变量就是相当于给global添加了一个属性，此时与全局中的this已经没有 关系了。 如果还堆这个结论表示怀疑，那么下面这段代码足以证明: 12345678910function fn()&#123; function fn2()&#123; this.age = 18; &#125; fn2(); console.log(this); //-&gt;global console.log(this.age); //-&gt;18 console.log(global.age); //-&gt;18 &#125;fn(); 所以总结出:函数中this指向就是global 构造函数中的this 看下面这段代码： 123456function Fn()&#123; this.num = 100; &#125; var fn = new Fn(); console.log(fn.num); //-&gt;100 console.log(global.num); //-&gt;undefined 在构造函数中this指向的是它的实例，而不是global。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式从基础到实战]]></title>
    <url>%2F2017%2F11%2F12%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[什么是正则？ 正则就是一个规则，用来处理字符串的规则 1、正则匹配编写一个规则，验证某个字符串是否符合这个规则，正则匹配使用的是 test 方法2、正则捕获编写一个规则，在一个字符串中把符合规则的内容都获取到，正则捕获使用的方法：正则的exec方法、字符串中的split、replace、match等方法都支持正则 正则的元字符和修饰符 修饰符` g(global)：全局匹配 i(ignoreCase)：忽略大小写匹配 m(multiline)：多行匹配 `元字符` [量词元字符] +：让前面的元字符出现一到多次 ?：出现零到一次 *：出现零到多次 {n}：出现n次 {n,}：出现n到多次 {n,m}：出现n到m次 [特殊意义的元字符] \：转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义字符转换为普通的字符） .：除了\n（换行符）以外的任意字符 \d：匹配一个0~9之间的数字 \D：匹配任意一个非0~9之间的数字（大写字母和小写字母的组合正好是反向的） \w：匹配一个 `0~9或字母或_` 之间的字符 \s：匹配一个任意空白字符 \b：匹配一个边界符 x|y：匹配x或者y中的一个 [a-z]：匹配a-z中的任意一个字符 [^a-z]：和上面的相反，匹配任意一个非a-z的字符 [xyz]：匹配x或者y或者z中的一个字符 [^xyz]：匹配除了xyz以外的任意字符 ()：正则的小分组，匹配一个小分组（小分组可以理解为大正则中的一个小正则） ^：以某一个元字符开始 $：以某一个元字符结束 ?:：只匹配不捕获 ?=：正向预查 ?!：负向预查 元字符详细解读^ $ var reg = /\d+/; //=&gt;包含某某某即可，这里说明包含1到多个数字即可 var str = &apos;珠峰2017培训2018&apos;; reg.test(str) =&gt;truereg=/^\d+/; reg.test(str) =&gt;falsereg=/^\d+$/; //=&gt;只能是某某某的,这里说明只能是1到多个数字 reg.test(&apos;2017&apos;); =&gt;truereg.test(&apos;2017珠峰2018&apos;); =&gt;falsereg.test(&apos;2&apos;); =&gt;true ^或者$只是一个修饰或者声明，不会占据字符串的位置 \ var reg = /^2.3$/; reg.test(&apos;2.3&apos;); =&gt;truereg.test(&apos;2+3&apos;); =&gt;true 点在正则中的意思：匹配除了\n以外的任意字符，而不是单纯的小数点 reg = /^2\.3$/; reg.test(&apos;2.3&apos;); =&gt;truereg.test(&apos;2+3&apos;); =&gt;false 使用转义字符把点转换为本身小数点的意思 x|y var reg = /^18|19$/; //=&gt;18 19 189 119 819 181 1819 ... 很多都符合这个规则/* * 18或者19 * 以1开头 以9结尾 中间是8或者1 * 以18开头或者以19结尾即可 =&gt;&apos;18珠峰&apos; &apos;珠峰19&apos;... */ var reg = /^(18|19)$/; //=&gt;此时只有18或者19符合我们的规则了 ( ) 正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体）；在正则中 我们可以使用小括号改变一些默认的优先级； 小分组还有第二个作用：分组引用 小分组的第三个作用：分组捕获 //=&gt;分组引用：\1 或者 \2 ...出现和第N个分组一模一样的内容 var reg = /^([a-z])([a-z])\2([a-z])$/; //=&gt; 符合的字符串：foot、book、week、attr、http... [ ] [xyz] [^xyz] [a-z] [^a-z] //=&gt;\w：数组字母下划线中的任意一个字符 1234567 var reg = /^[a-zA-Z0-9_]$/; //=&gt;等价于\w var reg = /^[.?+&amp;]+$/; //=&gt;里面的四个元字符都是本身含义，例如：点就是小数点了 不是所谓的任意字符… //=&gt;需求：描述样式类名的规则（数字、字母、下划线、-），并且不能以-开头 //var reg = /^[\w-]+ //=&gt;没有处理以-开头的情况 var reg = /^\w[\w-]*$/; 例子 //=&gt;需求：验证18~65之间的年龄 //var reg = /^[18-65]$/; //=&gt;1或者8~6或者5中的任意一个字符,中括号中出现的18不是数字18，而是1或者8，当前正则 是非法的：因为不能设置8~6这种范围// =&gt;分三个阶段处理： // 18 或者 19 /(18|19)/ // 20 ~ 59 /([2-5]\d)/ // 60 ~ 65 /(6[0-5])/ var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/; 常用的正则表达式编写验证是否为有效数字 可能是正数，可能是负数 12 -12 整数或者小数 0 12 0.2 12.5 -12.3 只要出现小数点，后面至少要跟一位数字 小数点前面必须有数字 -? 负号可有可无 (\d|([1-9]\d+)) \d 一位数可以是任何值 ([1-9]\d+) 多位数不能以零开头 (.\d+)? 小数部分可有可无，有的话点后面必须跟一位数字 var reg = /^-?(\d|([1-9]\d+))(\.\d+)?$/; 手机号码 11位数字 1开头 var reg = /^1\d{10}$/; 用户名：真实姓名 //=&gt;/^[\u4E00-\u9FA5]$/ 中文汉字的正则 var reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10})?$/; 邮箱 var reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/; 以数字字母下划线开头 @前面可以是 数字、字母、下划线、-、. 这些符号 不能把 -和. 连续出现，出现一次后面必须跟数字字母下划线 @后面的部分支持 企业邮箱 .com.cn 多域名情况 /// [A-Za-z0-9]+// ((.|-)[A-Za-z0-9]+)*// .[A-Za-z0-9]+// @163.com.cn// @zhu-feng-pei-xun.com.cn 身份证号码 18位 前17位必须是数字 最后一位可以是数字或者X(X代表数字10) 130828199012040617 前六位：省市县 130828 接下来八位 出生年+月+日 倒数第二位数字 奇数代表男 偶数代表女 //=&gt;这样写不仅可以匹配，而且以后捕获的时候，不仅可以把大正则匹配的结果捕获到，里面每一个小分组(小正则)匹配的结果也可以单独的捕获到 “分组捕获”//=&gt;年 1950~2017//=&gt;第一段 1950~1999//=&gt;第二段 2000~2017//==&gt; 00~09//==&gt; 10~17// /^((19[5-9]\d)|(20((0\d)|(1[0-7]))))$/ var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/; 正则捕获 把当前字符串中符合正则的字符捕获到RegExp.prototype：exec 实现正则捕获的方法 var str = &apos;珠峰培训2017扬帆起航2018&apos;; var reg = /\d+/; reg.exec(str); 当正则捕获的时候： 1、先去验证当前字符串和正则是否匹配，如果不匹配返回的结果是null（没有捕获到任何的内容） 2、如果匹配，从字符串最左边开始，向右查找到匹配的内容，并且把匹配的内容返回 exec捕获到结果的格式： -&gt; 获取的结果是一个数组 -&gt; 数组中的第一项是当前本次大正则在字符串中匹配到的结果 -&gt; index：记录了当前本次捕获到结果的起始索引 -&gt; input：当前正则操作的原始字符串 -&gt; 如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组，本次匹配到的结果（通过exec可以把分组中的内容捕获到） 执行一次exec只能把符合正则规则条件中的一个内容捕获都，如果还有其它符合规则的，需要在次执行exec才有可能捕获到 正则捕获存在懒惰性 执行一次exec捕获到第一个符合规则的内容，第二次执行exec，捕获到的依然是第一个匹配的内容，后面匹配的内容不管执行多少次exec都无法捕获到 解决正则捕获的懒惰性：在正则的末尾加修饰符g（全局匹配） //=&gt;正则为什么会存在懒惰性?/* 正则本身有一个属性：lastIndex（下一次正则在字符串中匹配查找的开始索引） 默认值：0，从字符串第一个字符开始查找匹配的内容 默认不管指定多少遍exec方法,正则的lastIndex值都不会变（也就是第二次以后查找的时候还是从第一个字符找，所以找到的结果永远都是第一个匹配的内容） 而且当我们手动把 lastIndex 进行修改的时候，不会起到任何的作用 ///=&gt;为什么加修饰符g就解决了懒惰性?/* 加了修饰符g，每一次exec结束后，浏览器默认会把lastIndex值进行修改，下一次从上一次结束的位置开始查找，所以可以得到后面匹配的内容了 12345678910var reg = /\d+/g; var str = &apos;珠峰培训2017杨帆起航2018&apos;; console.log(reg.lastIndex);//=&gt;0 console.log(reg.exec(str)[0]);//=&gt;&apos;2017&apos; console.log(reg.lastIndex);//=&gt;8 console.log(reg.exec(str)[0]);//=&gt;&apos;2018&apos; console.log(reg.lastIndex);//=&gt;16 console.log(reg.exec(str));//=&gt;null console.log(reg.lastIndex);//=&gt;0 console.log(reg.exec(str)[0]);//=&gt;&apos;2017&apos; 1234567891011121314151617181920exec有自己的局限性：执行一次exec只能捕获到一个和正则匹配的结果（即使加了修饰符g），如果需要都捕获到，我们需要执行N次exec方法才可以下面封装的myExecAll方法，目的是执行一次这个方法，可以把当前正则匹配到的全部内容都捕获到```javascript RegExp.prototype.myExecAll = function myExecAll() &#123; var str = arguments[0] || ‘’, result = []; //=&gt;首先判断THIS是否加了全局修饰符G,如果没有加,为了防止下面执行出现死循环,我们只让其执行一次EXEC即可,把执行一次的结果直接的返回 if (!this.global) &#123; return this.exec(str); &#125; var ary = this.exec(str); while (ary) &#123; result.push(ary[0]); ary = this.exec(str); &#125; return result; &#125;; var reg = /\d+/g; console.log(reg.myExecAll(‘珠峰2017培训2018杨帆2019起航2020’)); 使用字符串方法match实现捕获123var reg = /\d+/g; var str = &apos;珠峰2017培训2018杨帆2019起航2020&apos;; str.match(reg); //=&gt;[&quot;2017&quot;, &quot;2018&quot;, &quot;2019&quot;, &quot;2020&quot;] 使用字符串match捕获：1、如果正则加了修饰符g，执行一次match会把所有正则匹配的内容捕获到2、如果没有加修饰符g，执行一次match只能把第一个匹配的结果捕获到局限性：在加了修饰符g的情况下，执行match方法只能把大正则匹配的内容捕获到，对于小分组捕获的内容方法给其自动忽略了 1234567891011121314var str = ‘my name is &#123;0&#125;,i am &#123;1&#125; years old~，2017’; //=&gt;需求：把&#123;n&#125;整体捕获到，而且还要把括号中的数字也获取到 var reg = /&#123;(\d+)&#125;/g; // str.match(reg);//=&gt;[“&#123;0&#125;”, “&#123;1&#125;”] //=&gt;想要获取小分组中的内容，我们只能使用EXEC处理了 function fn(reg,str)&#123; var ary=reg.exec(str), result=[]; while(ary)&#123; result.push(ary); ary=reg.exec(str); &#125; return result; &#125; 使用test也可以实现正则的捕获不管是正则的匹配还是正则的捕获，在处理时候的原理是没区别的：从字符串的第一个字符向后查找，找到符合正则规则的字符，如果可以找到，说明正则和字符串匹配（test检测返回true、exec捕获返回捕获的内容），如果找到末尾都没有匹配的，说明正则和字符串不匹配（test检测返回false、exec捕获返回null）。 12345678910111213141516//=&gt;如果当前字符串和正则是匹配的，我们进行捕获 var reg = /&#123;(\d+)&#125;/g; var str = ‘my name is &#123;0&#125;~~’; if (reg.test(str)) &#123; //=&gt;reg.test(str) : true console.log(reg.lastIndex);//=&gt;14 console.log(reg.exec(str));//=&gt;null &#125; var reg = /&#123;(\d+)&#125;/; var str = ‘my name is &#123;0&#125;~~’; if (reg.test(str)) &#123; //=&gt;reg.test(str) : true console.log(reg.lastIndex);//=&gt;0 console.log(reg.exec(str));//=&gt;[‘&#123;0&#125;’,’0’…] &#125; 使用test不仅可以找到匹配的内容，也能像exec一样把找到的内容获取到test返回结果是 true/false，所以靠返回结果肯定不行。 1234567var reg = /&#123;(\d+)&#125;/g; var str = ‘my name is &#123;0&#125;,i am &#123;1&#125; years old‘; reg.test(str);//=&gt;true console.log(RegExp.$1);//=&gt;0 获取到当前本次匹配内容中第一个小分组捕获的内容 reg.test(str);//=&gt;true console.log(RegExp.$1);//=&gt;1 TEST可以实现捕获,但是每一次只能获取到当前本次匹配结果中,第N个分组捕获的内容 $1第一个分组 $2第二个分组 … 所有支持正则的方法都可以实现正则的捕获（一般都是字符串方法）字符串中常用的支持正则的方法：match、split、replace； split 12345678910111213var str = ‘name=珠峰&amp;age=8&amp;lx=teacher’; str.split(/&amp;|=/); //=&gt;[“name”, “珠峰”, “age”, “8”, “lx”, “teacher”] str.split(/(&amp;|=)/); //=&gt;[“name”, “=”, “珠峰”, “&amp;”, “age”, “=”, “8”, “&amp;”, “lx”, “=”, “teacher”] //=&gt;在使用split进行字符串拆分的时候，如果正则中包含小分组，会把小分组中的内容都捕获到，放在最后的数组中 //=&gt;本案例中的小括号仅仅是为了实现 改变默认的优先级 问题，但是我们不想把分组中的内容捕获到 =&gt; “只想匹配不想捕获” 我们可以使用 (?:) str.split(/(?:&amp;|=)/); //=&gt;[“name”, “珠峰”, “age”, “8”, “lx”, “teacher”] //=&gt;只匹配不捕获： //在当前一个分组中加了 ?: ，在正则检测匹配的时候，小分组可以起到自己应有的作用（例如：改变优先级…），但是在捕获的时候，遇到带?:的小分组，浏览器不会把当前这个分组中匹配的内容，单独去捕获了 var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d)(\d|X)$/; reg.exec(‘130828199012040617’); //=&gt;[“130828199012040617”, “130828”, “1990”, “12”, “04”, “06”, “1”, “7”…] var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(?:\d&#123;2&#125;)(\d)(?:\d|X)$/; reg.exec(‘130828199012040617’);//=&gt; [“130828199012040617”, “130828”, “1990”, “12”, “04”, “1”…] var reg = /^-?(\d|([1-9]\d+))(.\d+)?$/;//=&gt;计算是第几个分组的时候，我们从左向右找 ( 即可） replace replace：字符串中原有字符的替换；str.replace(old,new) 123456var str = ‘珠峰2017珠峰2018’; str = str.replace(‘珠峰’,’珠峰培训’); str = str.replace(‘珠峰’,’珠峰培训’); //=&gt;’珠峰培训培训2017珠峰2018’ 没有实现我们希望的效果 //=&gt;在不使用正则的情况下，执行一次replace只能替换一个原有字符，第二次执行replace，还是从字符串的开始位置查找，把最新找到的字符替换为新字符（类似于正则捕获时候的懒惰性：每一次执行都是从字符串最开始的位置查找）真实项目中，replace一般都是和正则搭配在一起使用的 12var str = &apos;珠峰2017珠峰2018&apos;; str = str.replace(/珠峰/g,&apos;珠峰培训&apos;);//=&gt;&quot;珠峰培训2017珠峰培训2018&quot; replace原理： 1、当replace方法执行，第一项传递一个正则正则不加g：把当前字符串中第一个和正则匹配的结果捕获到，替换成新的字符正则加g：把当前字符串中所有和正则匹配的内容都分别的捕获到，而且每一次捕获，都会把当前捕获的内容替换为新字符 2、当replace方法执行，第二个参数传递的是一个函数（回调函数）首先用正则到字符串中进行查找匹配，匹配到一个符合规则的，就把传递的函数执行一次不仅执行这个函数，而且还把正则本次捕获的结果（和执行exec捕获的结果一样：数组、大正则匹配、小分组匹配 都有）当做实参传递给这个函数（这样就可以在函数中获取这些值：而这些值就是正则每一次捕获的结果 ） 1234567891011121314151617var str = &apos;my name is &#123;0&#125;,i am &#123;1&#125; years old,i can &#123;2&#125;!&apos;; var reg = /\&#123;(\d+)\&#125;/g; str.replace(reg, function () &#123; //=&gt;传递的函数一共被执行三次 //=&gt;console.log(arguments) 每一次匹配捕获到结果,不仅把这个方法执行了,而且还会把当前捕获的结果当做实参传递给这个函数(ARG) /* * 第一次执行函数，获取的是ARG类数组 * 0:&apos;&#123;0&#125;&apos; 本次大正则匹配的结果 * 1:&apos;0&apos; 本次第一个小分组匹配的结果 * 2:11 本次大正则匹配结果在字符串中的索引 index * 3:&apos;my nam...&apos; 原始字符串 input * * 和每一次执行exec实现捕获的结果非常类似 */ //return xxx; //=&gt;每一次执行函数，函数中RETURN的结果，都相当于把本次大正则匹配的内容替换掉（原始字符串不变） &#125;);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串String的常用方法]]></title>
    <url>%2F2017%2F11%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2String%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[charAt(索引)获取指定索引位置的字符charCodeAt（索引）获取指定索引位置的字符串对应的ASCII值123var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.charAt(8));//-&gt;h console.log(str.charCodeAt(8));//-&gt;104 字符串截取1、substrsubstr(n,m) 从索引n开始截取m个字符 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.substr(0,5));//-&gt;www.f 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.substr(5,2));//-&gt;an 2、substringsubstring(n,m) 从索引n开始，找到索引m处(不包含m),将找到的字符返回。 12var str=&apos;www.fanzhanxiang.cn&apos;;console.log(str.substring(0,5));//-&gt;www.f 3、sliceslice(n,m) 从索引n开始，找到索引m处(不包含m),将找到的字符返回。并且slice支持以负数作为索引，原理是str.length+负数索引。 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.slice(0,5));//-&gt;www.f 12var str=&apos;www.fanzhanxiang.cn&apos;;console.log(str.slice(-5,-1));//-&gt;ng.c 上面的这三个方法都是如果只写了一个n,没有m:代表截取到末尾位置 查找字符的索引indexOf/lastIndexOf indexOf(字符)：获取指定字符在字符串中第一次出现的位置 lastIndexOf(字符)：获取指定字符在字符串中最后一次出现的索引位置 这两个方法都是如果没有这个字符，返回的是-1，基于这个理念我们经常用这个两个方法判断字 符串中是否包含某个字符,里面还可以放多个字符，必须连着包含才会输出对应索引、否则返回-1 123456var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.indexOf(&quot;.&quot;));//-&gt;3 console.log(str.lastIndexOf(&quot;.&quot;));//-&gt;16 console.log(str.indexOf(&quot;。&quot;));//-&gt;-1 console.log(str.lastIndexOf(&quot;。&quot;));//-&gt;-1 console.log(str.lastIndexOf(&quot;www。&quot;));//-&gt;-1 大小写转换 toUpperCase:将所有字母转换为大写 toLowerCase：将字母转换为小写 123var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.toUpperCase());//-&gt;WWW.FANZHANXIANG.CN console.log(str.toLowerCase());//-&gt;www.fanzhanxiang.cn 替换replace(要替换的老字符，替换的新字符)；在不使用正则的情况下，每一次调用方法只能替换一次。一般情况下替换我们都是使用正则处理的。 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.replace(&quot;.cn&quot;,&quot;.com&quot;));//-&gt;www.fanzhanxiang.com 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.replace(&quot;w&quot;,&quot;W&quot;));//-&gt;Www.fanzhanxiang.cn，只替换了一次 将字符串按照指定的分隔符拆分成数组split(分隔符)：将字符串按照指定的分隔符拆分成数组 1234var str=&apos;1+2+3+4+5+5&apos;; console.log(str.split(&quot;+&quot;));//-&gt;[ &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;5&apos; ] console.log(str.split(&quot;&quot;));//-&gt;[ &apos;1&apos;, &apos;+&apos;, &apos;2&apos;, &apos;+&apos;, &apos;3&apos;, &apos;+&apos;, &apos;4&apos;, &apos;+&apos;, &apos;5&apos;, &apos;+&apos;, &apos;5&apos; ] console.log(str.split(&quot; &quot;));//-&gt;[ &apos;1+2+3+4+5+5&apos; ] matchmatch()方法用于从字符串中查找指定的值，本方法类似于indexOf()和lastindexOf()，不同的是它返回的是指定的值，而不是指定值在字符串中的位置。是一个数组，并且只能查找一次，索引为0的这项是查找到的值，index是这项值的索引，input是原字符串。indexOf()和lastindexOf()方法返回位置数字 如果找不到返回-1。注意区分大小写 。 12var str=&apos;www.fanzhanxiang.cn&apos;; console.log(str.match(&quot;w&quot;));//-&gt;[ &apos;w&apos;, index: 0, input: &apos;www.fanzhanxiang.cn&apos; ]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的常用方法]]></title>
    <url>%2F2017%2F11%2F12%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面的数组的方法中都是按照下面的四个维度去详细解读： 1、这个数组方法的作用 2、需要传那些参数 3、是否有返回值、返回值是什么 4、通过这个方法是否对原来的数组产生了影响。 关于数组的增加、修改、删除1、push 作用：向数组的末尾增加新的内容 传递的参数:想要向原来数组增加的内容,而且可以传递多个值，统一向末尾增加多项 返回值是:新增加后数组的长度 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45]; var res=ary.push(100,200,300);console.log(res,ary);//-&gt;7 [ 12, 23, 34, 45, 100, 200, 300 ] 2、pop 作用：删除数组最后一项内容 传递的参数:不需要传递参数 返回值是:被删除的那一项内容 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45]; var res=ary.pop(); console.log(res,ary);//-&gt;45 [ 12, 23, 34 ] 3、shift 作用：删除数组第一项内容 传递的参数:不需要传递参数 返回值是:被删除的那一项内容 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45];var res=ary.shift();console.log(res,ary);//-&gt;12 [ 23, 34, 45 ] 4、unshift 作用：向数组开头增加一项 传递的参数:需要向数组开头增加的内容，可传递多个参数 返回值是:数组的长度 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45]; var res=ary.unshift(100,100,200); console.log(res,ary);//-&gt;7 [ 100, 100, 200, 12, 23, 34, 45 ] 5、spilce 能实现删除、修改、增加，下面依次写一下这三个方法 删除 作用：ary.splice(n,m),从索引n开始删除，删除m个元素，里面不传递参数则是一项都没有删 除，返回空数组 传递的参数:n,m 返回值是:把删除的内容以一个新的数组返回 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45,23,34]; var res=ary.splice(2,3); console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 34 ] 注意:ary.splice(n);//表示从索引n开始删除到末尾 修改 作用：ary.splice(n,m，x),从索引n开始删除，删除m个元素,用x替换删除的部分 传递的参数:n,m,x 返回值是:把删除的内容以一个新的数组返回 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45,23,34];var res=ary.splice(2,3,1000);console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 1000, 34 ] 增加 作用：ary.splice(n,0，x),从索引n开始删除，一个都不删除,用x增加到索引n是前面 传递的参数:n,m,x 返回值是:空数组 对原来数组的影响:原来数组已经发生了改变 123var ary=[12,23,34,45,23,34]; var res=ary.splice(2,0,1000); console.log(res,ary);//-&gt;[] [ 12, 23, 1000, 34, 45, 23, 34 ] 关于数组的截取和拼接1、slice 作用：实现数组的截取，在原来的数组中截取某一部分 传递的参数:slice(n,m) 从索引n开始，找到索引为m处（不包含m） 返回值是:截取到的数组 对原来数组的影响:原来的数组不变 123var ary=[12,23,34,45,23,34]; var res=ary.slice(2,5); console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 34, 45, 23, 34 ] 注意ary.slice(n),表示从索引n开始一直找到数组的末尾，返回截取到的数组 2、concat 作用：把两个数组拼接到一起，原来的数组不改变 传递的参数:要拼接的数组，可传递的多个数组 返回值是:拼接后的新数组 对原来数组的影响:原来的数组不变 1234var ary1=[12,23,34,45,23,34]; var ary2=[100,200]; var res=ary1.concat(ary2,ary2); console.log(res,ary1,ary2);//-&gt;[ 12, 23, 34, 45, 23, 34, 100, 200, 100, 200 ] [ 12, 23, 34, 45, 23, 34 ] [ 100, 200 ] 注意ary1.concat（）,相当于把ary1克隆一份一模一样的数组. 把数组转化为字符串1、toString 作用：把数组转化为字符串 传递的参数:没有参数 返回值是:转化后的字符串 对原来数组的影响:原来的数组不变 123var ary=[12,23,34,45,23,34]; var res=ary.toString(); console.log(res,ary);//-&gt;12,23,34,45,23,34 [ 12, 23, 34, 45, 23, 34 ] 2、join 作用：按照每一个分隔符把数组中的每一项拼接成一个字符串 传递的参数:要分隔的分隔符 返回值是:分隔后的结果 对原来数组的影响:原来的数组不变 123var ary=[12,23,34,45,23,34]; var res=ary.join(&quot;@&quot;); console.log(res,ary);//-&gt;12@23@34@45@23@34 [ 12, 23, 34, 45, 23, 34 ] 扩展：eval-&gt;JS中把字符串变为JS表达式执行的一个方法 1console.log(eval(&apos;12+12+34&apos;));//-&gt;58 数组的排序和排列1、reverse 作用：把数组倒过来排列 传递的参数:不需要传递参数 返回值是:倒过来排序后的数组 对原来数组的影响:原来的数组也倒过来排列 123var ary=[12,23,34,45,23,34]; var res=ary.reverse(); console.log(res,ary);//-&gt;[ 34, 23, 45, 34, 23, 12 ] [ 34, 23, 45, 34, 23, 12 ] 2、sort 作用：给数组进行排序 传递的参数:直接写ary.sort()只能处理10以内的数字进行排序 返回值是:排序后的数组 对原来数组的影响:原数组改变 直接写ary.sort()只能处理10以内的数组，比如下面这个数组。原因：因为它是按照UNICODE编码的值进行排序的。 123var ary=[12,23,340,45,23,34]; var res=ary.sort(); console.log(res,ary);//-&gt;[ 12, 23, 23, 34, 340, 45 ] [ 12, 23, 23, 34, 340, 45 ] sort（）里面传递相应参数可以对所有的进行排序，里面函数返回的值是（a-b）时是有小到大，返回”b-a”时是由大到小 12345var ary=[12,23,340,45,23,34]; var res=ary.sort(function (a,b) &#123; return a-b; &#125;); console.log(res,ary);//-&gt;[ 12, 23, 23, 34, 45, 340 ] [ 12, 23, 23, 34, 45, 340 ] 12345var ary=[12,23,340,45,23,34]; var res=ary.sort(function (a,b) &#123; return b-a; &#125;); console.log(res,ary);//-&gt;[ 340, 45, 34, 23, 23, 12 ] [ 340, 45, 34, 23, 23, 12 ] 只有在标准浏览器中兼容的方法，在IE6-8下不兼容的注意:字符串中也有两个方法是兼容所有浏览器的，而数组这两个方法是不兼容的。 1、indexOf/lastIndexOf 作用：当前内容在数组中第一次/最后一次出现的索引，如果数组中没有这一项，返回结果&gt; 是-1，如果有这一项，索引是几就返回几 传递的参数:要查找的数字 返回值是:0或-1 对原来数组的影响:不变 123var ary=[12,23,340,45,23,34]; var res=ary.indexOf(12); console.log(res,ary);//-&gt;0 [ 12, 23, 340, 45, 23, 34 ] 123var ary=[12,23,340,45,23,34]; var res=ary.indexOf(1000); console.log(res,ary);//-&gt;-1 [ 12, 23, 340, 45, 23, 34 ] 应用:可以用它的返回值来验证当前内容在数组中是否存在，看它的返回值是不是-1； 2、forEach/map 参考这篇文章:http://www.fanzhanxiang.cn/2017/11/05/forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB/ 作用：都是用来遍历数组中的每一项的 传递的参数:看例子 返回值是:前面的博文中有写这两个方法 对原来数组的影响:参考前面的一篇博文 用法:数组中有几项我们的函数就执行几次； 12345var ary=[12,23,340,45,23,34]; var res=ary.forEach(function(item,index)&#123; console.log(item,index);//依次输出：12 0 、 23 1、 340 2 、 45 3 、 23 4 、 34 5 &#125;); console.log(res,ary);//-&gt;undefined [ 12, 23, 340, 45, 23, 34 ]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm ERR publish 403,nodejs发布包流程]]></title>
    <url>%2F2017%2F11%2F08%2Fnpm%20ERR%20publish%20403%2Cnodejs%E5%8F%91%E5%B8%83%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[nodejs学习体验之发布包，发布环境如下：1:win10系统,2:已安装nodejs.具体操作步骤如下：编写模块 1）新建文件夹，比如：node 2) 该文件夹下新建js文件，比如：index.js,js里面的内容可以随便写 初始化包描述文件 进入node文件夹之后按住shift的同时按住鼠标右键，选择在此处打开命令窗口有的电脑也可以是在”此处打开Powershell窗口，然后进入”执行下列命令、 1npm init 之后连续点击enter键，帮助你生成package.json文件。这是我的文件的内容.name这个属性在按enter键的时候需要注意是要自己填的，也可以在生成package.json之后再改。12345678910&#123; &quot;name&quot;: &quot;fanzhanxiang&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; &#125; 注册包仓库账号执行这个命令 1npm adduser 输入这个命令会有提示输入用户名，密码，邮箱等资料 这和去官方源仓库https://www.npmjs.com/注册是一样的 上传包 1npm publish 如果上传成功会提示 +fanzhanxiang@1.0.0 否则上传失败 这个时候去https://www.npmjs.com/登陆仓库账号就可以看到自己的包啦。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply、bind的区别]]></title>
    <url>%2F2017%2F11%2F07%2Fcall%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[apply和call的作用是一模一样的，都是用来改变方法下的this关键字并且把方法执行，并且在”严格模式”下和非严格模式下对于第一个参数书null和undefined这种情况也是一样的。当在JS开始的时候在最前面加一句代码叫:”use strict“表示告诉当前当前浏览器，接下来的JS代码将按照严格模式编写严格模式 在非严格模式下，函数定义的形参和arguments是存在映射关系的，一个变另一个也跟着变, 但是在严格模式下这个是没有映射关系的。并且在严格模式下禁止我们使用arguments.callee 和arguments.callee.caller; call代码如下: 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; &apos;use strict&apos;;//告诉当前当前浏览器，接下来的JS代码将按照严格模式编写 var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2); console.log(this); &#125; //fn(100,200);//this是Window num1=100，num2=200 //fn.call(100,200);//this-&gt;100 num1=200 num2=undefined //fn.call(obj,100,200);//this-&gt;obj num1=100 num2=200 /*fn.call();//this-&gt;window 在严格模式下 this-&gt;undefined fn.call(null);//this-&gt;window 在严格模式下this-&gt;null fn.call(undefined);//this-&gt;window 在严格模式下this-undefined */&lt;/script&gt; 我们发现严格模式下的this相对于非严格模式的this主要区别在于：对于JS代码没有写执行 主体去情况下，非严格模式默认是在Window执行的，所以this指向的是Window;但是在严格 模式下没有写执行主体，this指向是undefined. apply123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2); console.log(this); &#125; //fn.call(obj,100,200);//-&gt;这行代码和下面这行代码的作用相同 fn.apply(obj,[100,200]);&lt;/script&gt; 和call的区别 call在给fn传递参数的时候是一个一个传递的，而apply不是一个个传，而是要把fn传递的参数值统一放在一个数组中进行操作，但是也相当于一个个的给fn的形参赋值. bind这个方法在IE6-8上不兼容-&gt;和call和apply方法类似，都是用来改变this关键字的。但是这个方法是一个预处理的效果，事先把this变为我们想要的结果，并且把函数中的参数值也准备好。以后用到了直接执行即可。 用代码表示为: 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2,this); &#125; //fn.call(obj,100,200);//-&gt;已经执行了，会输出值&quot;300,&#123;name:&quot;ABC&quot;&#125;&quot;; fn.bind(obj,100,200);//仅仅是改变了fn中的this为obj,传递参数值，并没有执行fn这个方法 var tempFn=fn.bind(obj,1,2)//-&gt;&quot;3,&#123;name:&quot;ABC&quot;&#125;&quot;;这时候fn就执行了,这就是bind的作用&lt;/script&gt; bind的还有一个作用是事先固定值的功能，比如： 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function fn(num1,num2) &#123; console.log(num1+num2，this); &#125; fn.bind(this,100);//-&gt;这里bind的作用不是改变this问题，this还是Window，但是这里是先 在函数里面固定的传入第一个参数值num1,第二个参数值在执行的时候可以在后面再传递进去。比如下 面这行代码 var tempFn=fn.bind(this,100); tempFn(2);//-&gt;这里相当于传递进来了第二个参数num2，输出值为&quot;3,window&quot;,这里的作用并没有改变this值。如果不传递第二个参数的话第二个参数默认是undefined tenpFn();//-&gt;&quot;NaN,window&quot;&lt;/script&gt; bind体现了JS中的预处理思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要是用到了，直接的执行即可。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 部署到 Github Pages 文件夹大小写问题]]></title>
    <url>%2F2017%2F11%2F06%2FHexo%20%E9%83%A8%E7%BD%B2%E5%88%B0Github%20Pages%20%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题简介使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404问题。 譬如 Hexo 生成了一个 javascript js文件夹，但是我后来把它改成了 javascript Js，即 j 的首字母大写了。Hexo会生成正确，但部署到 Github 上却老是不正确。 原因git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。 解决办法 进入到博客项目中 .deploy_git文件夹，这个文件夹在 “博客目录-&gt;.deploy_git-&gt;git”下，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false，如图所示，这是我已经修改过的，原来是true。 删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步是清空你的 github.io 项目中所有文件。在博客项目中，执行下面命令。 1234cd .deploy_git it rm -rf * git commit -m &apos;clean all file&apos; git push 使用 Hexo 再次生成及部署，在上面命令执行完之后执行下面命令,问题解决。 123cd .. hexo clean hexo deploy -generate]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储]]></title>
    <url>%2F2017%2F11%2F05%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[JS中的本地存储: 使用JS向浏览器向浏览器某一个位置中存储一些内容，浏览器即使关闭了，存储了信息也不会销毁，当在重新打开浏览器的时候我们依然可以获取到上一次存储的信息。 一、本地存储的方案传统: 1、cookie:把信息存储到客户端的浏览器中（但是项目服务器端也是可以获取COOKIE的） 2、session:把信息存储到服务器上的（服务器存储） HTML5:webStorage 1、localStorage:永久存储到客户端本地 2、sessionStorage:信息会话存储，回话窗口存在信息也存在，会话窗口关闭信息也消失了 打开谷歌控制台，按F12可以Application中可以看到这些相应的窗口:如图所示 COOKIE localStorage sessionStorage三者之间的用法以及区别webStorage localStorage和sessionStorage的用法是一样的：setItem([key],[value]):向客户端的本地存储一条记录，存储的[value]值需要使字符串格式的，如果编写的不是字符串，浏览器也会默认转化为字符串然后进行存储;存储的[key]是不会重复的，如果之前有的话，把存储的信息值重新进行修改； 1、getItem([key]):获取之前存储的值 2、removeItem([key]):移除key对应的那条记录 3、clear():把当前源下所有的存储记录都移除掉 4、localStorage.length:获取存储的记录条数 5、localStorage.key(0):获取索引为0这一项的key是什么 用代码表示为: 1234567console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;7&quot; localStorage.setItem(&apos;age&apos;,JSON.stringify(&#123;name:&apos;abc&apos;&#125;)); console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;&#123;&quot;name&quot;:&quot;abc&quot;&#125;&quot; localStorage.removeItem(&apos;age&apos;); localStorage.clear(); console.log(localStorage.length);//-&gt;0 console.log(localStorage.key(0));//-&gt;&apos;null&apos; 下面是执行下面这段代码之后存储在控制台里面看到的效果: 1console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;7&quot; localStorage和sessionStorage的区别: 1、localStorage属于永久存储到本地，不管是刷新页面还是关掉页面或者关掉浏览器，存储的内 容都不会消失，只有我们手动删除才会消失（不管是杀毒软件还是浏览器自带的清除历史记录 的功能都不能把localStorage存储的内容移除掉）; 2、sessionStorage属于临时会话存储，只要当前的页面不关闭，信息就可以存储下来，但是页 面一旦关闭,存储的信息就会自动关闭（F5刷新只是把当前的DOM机构等进行重新渲染，会话并 没有关闭） cookie cookie和locaStorage的区别: 1、cookie兼容所有浏览器，但是localStorage不兼容IE6-8 2、cookie存储内容的大小是有限制的，一般同源下只能存储4KB内容;localStorage存储的内 容大小也有限制，一般同源下只能存储5MB; 3、cookie存储的内容是有过期时间的，而localStorage是永久存储到本地，使用杀毒软件或者 清除垃圾的功能都可能把存储的cookie给删除掉 4、用户可能出于安全的角度禁用cookie(无痕浏览)，但是不能禁用localStorage.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的forEach和map方法解读]]></title>
    <url>%2F2017%2F11%2F05%2FforEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[forEach和map方法都是用来遍历数组中的每一项的; forEach 1、数组中有几项，那我们传递进去的匿名函数就需要执行几次 2、每一次执行匿名函数的时候，还给其浏览器给其默认传递了三个参数值：数组中的当前项 item，当前项的索引index，原始数组input。 3、理论上我们的方法是没有返回值的，仅仅遍历数组中的每一项不对原来的数据进行修改，但是 我们可以通过数组的索引来修改原来的数组。 执行下面代码：123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var ary=[12,23,34,45,43]; var res=ary.forEach(function (item,index,input) &#123; console.log(arguments); input[index]=item*10; &#125;); console.log(res);//-&gt;undefined console.log(ary);&lt;/script&gt; 控制台中返回结果如图所示: 原因：执行了5函数，输出了5次arguments,并且函数在遍历的时候是从索引0开始依次遍历的。 mapmap的回调函数中支持return返回值，return的后面是啥，相当于把数组中的这这一项改变为啥(但是并不影响原来的数组，只是相当于把原来的数组克隆一份，把克隆的这一份数组中的对应项改变了)。 用代码表示为: 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var ary=[12,23,34,45,43]; var res=ary.map(function (item, index, input) &#123; return item*10; &#125;); console.log(res);//-&gt; [120, 230, 340, 450, 430] console.log(ary);//-&gt;[12, 23, 34, 45, 43]&lt;/script&gt; 注意不管是forEach还是map都支持第二个参数，第二个参数的意识是把匿名函数中的this进行修改为第二个参数值。 代码表示: 1234567891011&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;abc&quot;&#125;; var ary=[12,23,34,45,43]; ary.forEach(function (item, index) &#123; console.log(this); &#125;); ary.forEach(function (item, index) &#123; console.log(this); &#125;,obj);&lt;/script&gt; 在控制台中输出的结果如图所示: 证实了上面的结论。 不管是forEach还是map在IE6-8下都不兼容]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的同步和异步编程]]></title>
    <url>%2F2017%2F11%2F05%2FJS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JS中的两种编程思想：同步、异步。 同步同步编程:上一件事情没有完成，继续做上一件事情，只有上一件事情完成了，才会做下一件事情(JS大部分都是同步编程的)。如下面代码：（1）、（2）分别代表第一次和第二次输出。 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; for(var i=0;i&lt;100000;i++)&#123; if(i===99999)&#123; console.log(&quot;循环结束了~~&quot;)//-&gt;(1) &#125; &#125; console.log(&quot;ok&quot;);//-&gt;(2)&lt;/script&gt; 原因:for循环就是同步编程的，只有循环结束后，才会执行下面的代码,因此会先输出前面的，再输出后面的。 再比如下面这段代码: 123456&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; while (1)&#123; &#125; console.log(&quot;ok&quot;);//-&gt;不会有结果输出，并且浏览器还会崩溃&lt;/script&gt; 原因:因为上面的循环是死循环，循环永远不会结束,JS不会跳过上面那段循环来执行下面的循环。 异步解读：首先规划要做一件事情，但是不是立马去执行这件事情，需要等一定的时间，这样的话我们不会继续等着它执行，而是继续执行下面的操作，”只有下面的事情都处理完成了”.只有当下面的事情都处理完成了，才会返回头处理之前的事情；如果下面的事情没有处理完成，不管之前的事情有没有处理完成，都踏踏实实的给我等着。在JS中异步编程只有四种情况：定时器都是异步编程的、所有事件绑定都是异步编程的、AJAX读取数据的时候，我们一般设定为异步编程、回调函数也是异步编程的。 比如下面这段代码: 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;1(2) &#125;,1000); console.log(n);//-&gt;0(1)&lt;/script&gt; 原因:定时器是异步编程的，在1000ms之后再执行定时器中的方法，因此会先输出0，再输出1。 关于浏览器的最小等待事件问题 比如下面的这段代码： 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;1(2) &#125;,0); console.log(n);//-&gt;0(1)&lt;/script&gt; 原因:每一个浏览器对于定时器的等待时间都有一个最小值：谷歌大概:5~6ms,IE大概:13~14ms,如果设置的等待时间小于这个值，不起作用，还是需要等到最小时间才执行；尤其是写0也不是立即执行； 定时器设置的等待时间不一定就是最后执行的时间 看下面的这段代码： 12345678910111213&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;不执行 &#125;,0); console.log(n);//-&gt;0(1) while (1)&#123; n++;//-&gt;死循环 &#125; console.log(n);//-&gt;不执行&lt;/script&gt; 原因:执行到while的时候出现了死循环，因此定时器里面的方法永远不会执行。 定时器是谁先到先执行谁 如下面这段代码： 12345678910111213141516&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n+=2; console.log(n);//-&gt;7(4) &#125;,20); window.setTimeout(function()&#123; n+=5; console.log(n);//-&gt;5(3) &#125;,5); console.log(n);//-&gt;0(1) for(var i=0;i&lt;10000000;i++)&#123; &#125; console.log(n);//-&gt;0(2)&lt;/script&gt; 原因：JS在执行的时候会有一个类似于设置闹钟的那种机制的任务队列，不是之前设置的闹钟就之前叫，而是不管是什么时候设置的，谁的时间先到了就谁先叫。如图所示。 上面仅仅是讲了定时器这一种异步编程思想，所有事件绑定、AJAX读取数据的时候、回调函数这几 种的原理也和定时器的一样]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据类型检测的四种方式]]></title>
    <url>%2F2017%2F11%2F04%2FJavaScript%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%98%AF%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、typeof 用来检测数据类型的运算符使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串包含了对应的数据类型，例如:’number’、’string’、’boolean’、’undefined’、’function’、’object’。局限性： 1typeof null-&gt;&quot;object&quot; 不能具体细分是数组还是正则，还是对象中其他的值，因为使用typeof检测数据类型，对于对象数据类型中的左右的值，最后返回的结果都是”object” 二、instanceof 检测某一个实例是否属于这个类优点：它可以用来检测是数组还是正则了。局限性：对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定的区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这类的实例，对于字面量创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散型，导致了可以使用JS原型上的方法。如下面的代码。 12345678910console.log(1 instanceof Number);//-&gt;控制台输出false console.log(new Number(1) instanceof Number);//-&gt;控制台输出true var ary=[]; function fn() &#123; &#125; console.log(ary instanceof Array)//-&gt;控制台输出true console.log(ary instanceof Object)//-&gt;控制台输出true console.log(fn instanceof Function)//-&gt;控制台输出true console.log(ary instanceof Object)//-&gt;控制台输出true 因此，它会产生以下影响： 1、不能用来检测和处理字面量方式创建出来的基本数据类型值。 2、instanceof的特性：只要在当前实例的原型链上，我们用其检测出来的结果都是true。 3、在类的原型继承中，我们最后检测出来的结果未必准确。只要它的原型链上有这个类，最后用这 方法检测出来的结果都是true。 三、constructor: 构造函数 作用和instanceof非常相似有如下代码：123456var obj=[],num=1，reg=/^$/; console.log(obj.constructor===Array);//-&gt;true console.log(obj.constructor===RegExp);//-&gt;false console.log(num.constructor===Number);//-&gt;true console.log(reg.constructor===RegExp);//-&gt;true console.log(reg.constructor===Object);//-&gt;false 优点:可以看出和instanceof相比，constructor可以处理基本数据类型的检测。不同:constructor和instanceof不一样的地方在于，constructor在检测的时候先在私有属性上找，找到之后就不会往后面找了，所以在用来检测Object的时候，一般情况下是检测不了的。局限性：我们可以把类的原型进行重写，在进行的重写过程中，很有可能之前contructor给覆盖掉了，这样检测出来的结果就是不准确的。 扩展：对于特殊的数据类型null和undefined,他们的所属类是Null和Undefined,但是浏览 器把这两个类保护起来了，不允许我们在外面访问使用。 四、Object.prototype.toString.call()这是最准确检测数据类型的方法； 解读：首先获取Object原型上toString方法，让方法执行，并且改变方法中的this关键字的指向。先看一下面的代码。 123456console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot;console.log((128).toString(2/8/10));-&gt;把数字转化为二进制/八进制/十进制，Number原型上的toString方法支持把数字转化为相的进制。 console.log((1).__proto__.__proto__.toString());//-&gt;&quot;[object Object]&quot; console.log(&quot;zhufeng&quot;.toString());//-&gt;也是转为为字符串，但是不支持进制 console.log(&#123;&quot;name&quot;: &quot;abc&quot;&#125;.toString());//-&gt;&quot;[object Object]&quot; console.log(Math.toString())//-&gt;&quot;[object Math]&quot; 通常情况下对toString的理解： 对于Number、String、Boolean、Array、RegExp、Date、Function原型上的toString()方法都 是把当前的数据类型转换为字符串类型（他们的作用仅仅是用来转换为字符串 Object.prototype.toString并不是用来转换为字符串的。 Object.prototype.toString它的作用是返回当前方法的执行主体（方法中this）所属类的详 细信息。var obj={name:&quot;xyz&quot;};//-&gt;&quot;[object Object]&quot; console.log(obj.toString());//-&gt;toString中的this是obj,返回的是obj所属类的信 息-&quot;[object Object]&quot;第一个object代表当前实例是对象数据类型的(这个是固定)，第二个 Object,代表的是obj是object这个类的一个实例。 1234567891011var ary=[]; console.log(Object.prototype.toString.call(ary));//-&gt;&quot;[object Array]&quot;; console.log(Object.prototype.toString.call(/^$/));//-&gt;&quot;[object RegExp]&quot;; console.log((&#123;&#125;).toString.call(1));//-&gt;&quot;[object Number]&quot;; console.log((&#123;&#125;).toString.call(&quot;dsas&quot;));//-&gt;&quot;[object String]&quot;; console.log((&#123;&#125;).toString.call(true));//-&gt;&quot;[object Boolean]&quot;; console.log((&#123;&#125;).toString.call(null));//-&gt;&quot;[object Null]&quot;; console.log((&#123;&#125;).toString.call(undefined));//-&gt;&quot;[object Undefined]&quot;; console.log((&#123;&#125;).toString.call(function () &#123;&#125;));//-&gt;&quot;[object Function]&quot;; console.log((&#123;&#125;).toString.call(new Date));//-&gt;&quot;[object Date]&quot;; console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot; 从上面代码可以总结春：Object.prototype.toString并不是用来转换为字符串的，返回的是 obj所属类的信息息-&quot;[object &quot;参数2&quot;]&quot;第一个object代表当前实例是对象数据类型的(这个 是固定)，第二个参数，“参数2”,代表的是检测的这个所属的类。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中检测兼容的三种方式]]></title>
    <url>%2F2017%2F11%2F04%2FJS%E6%A3%80%E6%B5%8B%E5%85%BC%E5%AE%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、使用try、catch来处理兼容前提：必须保证try中的代码在不兼容浏览器中执行的时候报错，这样的话我们才可以用catch捕获到异常的信息，进行其它的处理，示例代码如下面所示。缺点：不管是什么浏览器，都需要把try中的代码都需要把try中的代码执行一遍，如果当前是IE7。window.getComputedStyle本身是不兼容的，但是我们也要把它先执行一遍，报错了再把curEle.currentStyle执行一遍（消耗性能），因此使用try处理兼容只有在万不得已的情况下才使用它。 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123;//-&gt;curEle指的是操作的元素，attr指的是元素属性 var val=null; try&#123; val=window.getComputedStyle(curEle,null)[attr]; &#125;catch(e)&#123; val=curEle.currentStyle[attr]; &#125; return val; &#125;&lt;/script&gt; 二、判断当期浏览器中是否存在这个属性和方法判断当期浏览器中是否存在这个属性和方法，存在就兼容，不存在就不兼容。代码如下所示 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123; var val = null; if (getComputedStyle in window) &#123;//-&gt;如果返回结果是true，说明Window下有getComputedStyle，代表兼容 val = window.getComputedStyle(curEle, null)[attr]; &#125; else &#123; val = curEle.currentStyle[attr]; &#125; return val; &#125;&lt;/script&gt; 三、通过检测浏览器版本和类型来处理兼容代码如下所示： 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123; var val = null; if (/MSIE(6|7|8)/.test(navigator.userAgent)) &#123;//-&gt;说明是IE6-8浏览器 val = curEle.currentStyle[attr]; &#125; else &#123; val = window.getComputedStyle(curEle, null)[attr]; &#125; return val; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中常用的六种继承方式]]></title>
    <url>%2F2017%2F11%2F04%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、原型链继承可枚举和不可枚举：我们在JavaScript中使用for..in遍历对象的时候，会发现下面的情况： 12345678&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123;console.log(key)&#125;&lt;/script&gt; 最后在谷歌的控制台中会输出: name age aaa 这说明在使用for..in 遍历对象的时候默认会把自己私有的和它所属类的原型上扩展的属性和方法都可以遍历到，但是一般情况下，我们遍历对象只需要遍历私有的即可，我们可以使用以下的判断进行处理：12345678910&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123; if(obj.propertyIsEnumerable(key))&#123;console.log(key) &#125; &#125;&lt;/script&gt; propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false，下面为大家介绍下其具体的使用：propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false 1、这个属性必须属于实例的,并且不属于原型. 2、这个属性必须是可枚举的,也就是自定义的属性,可以通过for..in循环出来的 只有符合上面这两个要求，才会返回true。因为在使用for…in遍历对象对象的时候，在前面加一个这个方法来判断一下，原型上的自己定义的属性就不会被遍历出来了。 也可以用下面的方法来只遍历出对象中的私有属性： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123; if(obj.hasOwnProperty(key))&#123;console.log(key) &#125; &#125;&lt;/script&gt; hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。只遍历出私有私有属性，而不会遍历出原型链上的属性。 加上这两个判断之后，控制台中会输出同样的结果，结果是： name age Object.create(proObj):创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6-8不兼容（ECMAScript5），用下面的代码解释： 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123; getX: function () &#123; &#125; &#125;; var obj2 = Object.create(obj); obj.getY = function () &#123; console.log(2) &#125;; obj2.getY(); console.log(obj2); console.log(obj);&lt;/script&gt; 最谷歌控制台中输出的结果如图所示:2是执行 obj2.getY();输出的结果，中间的这个是obj2，最后这个是obj，可以看出，通过执行Object.create(obj)这个方法，创建出来了obj2这个对象，并且把，并且还把obj作为这个对象的原型。可以看出，在obj2和Object这个基类之间多了一个原型链。而这一级的对象就是obj。 原型继承 1、 原型继承是”JS”中最常用的一种继承方式,子类B想要继承父类A中的所有的属性和方法（私有 +公有），只需要让B.prototype=new A,即可。 2、 原型继承的特点：它是把父类私有的+公有的都继承到了子类的原型上（子类公有的）; 3、核心:原型链继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是B和A之间增加了原型链的链接看，以后B的实例n想要用A中的getX方法，需要一级级的查找来使用。代码就这样表示 123456789&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; function B()&#123; this.y=200; &#125; B.prototype=new A;&lt;/script&gt; 二、call继承call继承的最终结果是把父类私有的属性和方法克隆一份一模一样的，作为子类私有的属性和方法 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B()&#123; A.call(this); &#125; var n=new B; console.log(n.x);&lt;/script&gt; 最后在控制台中最终会输出100，为什么了？new B是创建B这个类的一个实例，在函数B中的this就是这个实例，这里表示的就是n,A.call(this)指的是把函数A中的this变为函数B中的this，而new B之后函数B中的this是n，所以最后在控制台中输出的是100。 三、冒充对象继承冒充对象继承：把父类私有的+公有的克隆一份一模一样给子类私有的。代码用下面的来表示 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; var temp=new A; for(var key in temp)&#123; this[key]=temp[key]; &#125; temp=null; &#125; var n=new B;&lt;/script&gt; 四、混合模式继承混合模式继承：指的是原型继承+call继承 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; A.call(this); &#125; B.prototype=new A; B.prototype.constructor=B; var n=new B;&lt;/script&gt; 这种继承方式会让父类私有的和公有的都会在子类公有的上面有一份，但是在原型链查找的时候会先查找私有属性，所以也不影响整体。优点是父级私有属性都放在子类的私有上了。 五、寄生组合式继承父类公有的给子类公有的，父类私有的给子类私有的。 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; A.call(this); &#125; B.prototype=Object.create(A.prototype);//这句代码的含义是把B的原型的地址换成了A的原型的地址。 B.prototype.constructor=B; var n=new B;&lt;/script&gt; 六、中间类继承法-&gt;IE下不兼容这段代码是一个数组，在去掉一个最大值和最小值之后求它的平均值。 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; function avgFn() &#123; Array.prototype.sort.call(arguments,function (a,b) &#123; return a-b; &#125;); Array.prototype.pop.call(arguments); Array.prototype.shift.call(arguments); return (eval(Array.prototype.join.call(arguments,&quot;+&quot;))/arguments.length).toFixed(2); &#125; console.log(avgFn(10,20,30,34,44))//-&gt;结果是28&lt;/script&gt; 使用中间类继承法：代码入下面所示 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; function avgFn() &#123; arguments.__proto__= Array.prototype; arguments.sort(function(a,b)&#123; return a-b; &#125;); arguments.pop(); arguments.shift(); return eval(arguments.join(&quot;+&quot;))/arguments.length; &#125; console.log(avgFn(10,20,30,34,44))//-&gt;结果是28&lt;/script&gt; 这就是直接借用原型链的机制来形成的一种继承方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP]]></title>
    <url>%2F2017%2F11%2F03%2FJSONP%2F</url>
    <content type="text"><![CDATA[综述JSONP和AJAX相同，都是向客户端向服务器发送请求:给服务器传递数据或者从服务器端获取数据的方式。但是他们两种方式之间是有区别的：JSONP属于非同源策略（跨域请求），说明一下，实现跨越的方式有很多种，只不过JSONP是最常用的；而AJAX是属于同源策略。 同源和非同源的区别同源和非同源的区别在于用当前页面的地址于数据请求的接口地址相比较：比如当前页面地址是：https://www.zhihu.com/people/fanzhanxiang;数据请求接口的地址是：https://github.com/fanzhanxiang；判断是使用AJAX请求还是JSONP请求我们需要看以下三个方面。 1、协议 2、域名 3、端口号 上面三个部分完全相同属于同源策略，我们使用AJAX获取数据；只要有一个不一样的，就属于非同源，我们一般使用JSONP来获取数据。就比如上面这两个地址，他们的协议（https和https）、域名（www.zhihu.com和github.com）、端口号（443和443）端口号和域名不一样，因此想要在当前页面中获取这个数据请求的地址需要使用非同源策略。 JSONP的原理JSOPN是利用在JavaScript中的script标签的特性，在script的世界中，没有跨域同源一说，只要你给它的SRC属性中的地址是一个合法的地址，script都可以把对应的内容请求回来。 JSONP就是利用了这个原理(JSONP请求一定需要对方的服务器做支持才可以)： 1、我们首先把需要请求数据的那个API数据接口的地址，赋值给script的SRC 2、把当前页面中的某一个函数名当做参数值传递给需要跨域请求数据的服务器（URL问号传参一 般都是这么写:canllback=fn） 3、服务器接到你的请求之后，需要进行特殊的处理：把你传递进来的函数名和他需要给你的数据 拼接成一个字符串，例如：我们传递进去的函数名是fn，它准备好的数据是&apos;fn(需要给我们的数 据)&apos;； 4、最后服务器把准备的数据通过HTTP协议返回给客户端，其实就是让我们的fn执行，而且还给fn 传递了一堆数据，那些数据就是我们想要的； 比如下面这个例子 12345678910&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fn(data)&#123; console.log(data); &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;http:// matchweb.sports.qq.com/kbs/calendar?columnId=100000&amp;callback=fn&quot;&gt; &lt;/script&gt; &lt;/body&gt; 在谷歌控制台中的输出入下图所示： jQuery的AJAX和JSONP调用AJAX请求 12345678910111213141516&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url:&quot;地址&quot;, type:&quot;请求方式&quot;, dataType:&quot;json&quot;, data:null,//-&gt;使用post请求是非服务器传递的内容 async:true,//-&gt;同步还是异步，默认是异步 cache:false,//设定GET请求的时候不走缓存数据，原理其实就是在URL末尾加随机数，默认值是true timeout:1000,//设置超时时间 一般都设定3000ms，超过时间之后就跑到error success:function(data)&#123;//-&gt;data是请求回来的数据 console.log(data); &#125;, error:function()&#123;&#125;,//请求失败的时候执行这个 &#125;);&lt;/script&gt; JSONP请求JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，而且jQuery会默认就会给JSONP的请求清除缓存 123456789101112&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url: &quot;请求地址&quot;, dataType: &quot;jsonp&quot;, jsonpCallback: &quot;fn&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的 jsonp:&quot;cb&quot;,//-&gt;把传递函数名的那个形参callback变为cb success: function (data) &#123; console.log(data); &#125; &#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>JSONP</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F10%2F31%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax:async javascript and xml 叫做异步的JS和XML(可扩展标记语言)，它是一种客户端的JS方法，用来向服务器端发送请求(还可以传递给服务器数据)，然后把服务器端返回的内容获取到，它一般运行在客户端的浏览器中的。 Ajax的四个步骤 12341、var xhr=new XMLHttpRequest; 2、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]); 3、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text (xhr.status))&#123;var val=xhr.responseText&#125; &#125;; 4、xhr.send(&quot;要传递给服务器的内容&quot;); 1、第一步11、var xhr=new XMLHttpRequest; 创建一个AJAX对象（在IE6及更低版本的浏览器中不兼容） 2、第二步12、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]); 发送前的基本信息配置：配置请求方式，请求方式有GET、POST、PUT、DELETE、HEAD，上面是几种方式不管是哪一种都可以向服务器传递数据，也可以从服务器获取到数据，而且从本质意义上来讲上面几种请求方式是没有什么区别的，例如用POST做的事情用GET也能做。以下区别都是开发者约定俗成的规范； 1、GET：一般应用于从服务器获取数据（给服务器的少，从服务器拿的数据多），使用GET请求给服 务器传递内容，我们一般都使用&quot;URL问号传参的方式&quot;；例如：xhr.open(&quot;get&quot;,&quot;/getList?num =2&quot;),但是这种方式传递的内容存在大小限制；因为GET通过URL传参给服务器，而每个浏览器对于 URL的长度存在限制，谷歌8kb、火狐7kb、IE2kb的长度限制，如果URL的长度超过限制，浏览器 会把超出的部分的截取。并且这个请求会出现缓存（这个缓存不一定304）。在项目中我们的GET请 求一般不会让其出现缓存，因此要清除缓存，清除GET请求缓存的方法是在URL的末尾加一个随机数 xhr.open(&quot;get&quot;,&quot;/getList?num =2&amp;_=&quot;+Math.random());在用get请求的时候与post 相比，是不安全的 2、POST：一般应用于向服务器推送数据（给服务器的多，从服务器上拿的少），我们一般使用&quot;请求 主体的方式&quot;传递给服务器，例如：xhr.open(&quot;post&quot;,&quot;/getList&quot;);xhr.send(&apos;{&quot;name &quot;:&quot;zhufeng&quot;,&quot;age&quot;:7&apos;)，这种传递方式理论上是没有大小限制的，并且这个请求是没有缓存的。 3、PUT：一般应用于给服务器上传资源文件（我们上传图片功能） 4、DELETE：一般应用于从服务器上删除资源文件 5、HEAD：一般应用于只获取服务器的响应头信息 第三个参数默认是异步；username:向服务器提供的用户名,userpass:向服务器提供的用户密码，这两个值一般都不写，只有服务器做了安全限制，只允许特定的用户访问，我们才传递过去。 3、第三步这一步不是必须的，如果自己不要拿回数据的话，就可以不需要执行这步，那么ajax只需要三步就可以完成。13、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text(xhr.status))&#123;var val=xhr.responseText&#125;&#125;; 给onreadyStatechange这个事件绑定一个方法，监听状态的改变(只要状态改变，就会触发这个事件绑定的相应方法执行)； xhr.readyState：AJAX状态码其中有5个值（0,1,2,3,4），可以代表当前AJAX处理的进度。 0：&quot;unset&quot;，表示当前的请求还没有发送； 1：&quot;opened&quot;,表示URL地址已经打开(发送前的参数配置已经完成)； 2：&quot;headers_received&quot;,表示响应头信息已经接收； 3：&quot;loading&quot;,主要返回的内容正在服务器端进行准备处理； 4：&quot;done&quot;:响应主体的内容已经成功返回客户端。 xhr.status:HTTP网络状态码，描述了服务器响应内容的状态，HTTP网络状态码有如下几种： 200 OR ^2\d{2}： (200或者以2开头的)都代表响应主体的内容已经成功返回了 301：永久重定向/永久转移 302：临时重定向/临时转移,服务器的负载均衡 304：本次获取的内容是读取缓存中的数据 400:客户端传递给服务器端的参数出现错误，客户端传递的参数有问题 401：无权限访问 404：访问的地址不存在 500：未知的服务器错误 503：服务器已经超负荷了，比如能承受10000人，那么第10001个人访问，如果没有做服务器的负载均 衡（302），那么这个人的状态码就是503; 4、第四步14、xhr.send(&quot;要传递给服务器的内容&quot;); 发送请求：参数是请求主体中给传递给服务器的内容；只有执行完第四步之后才开始一个AJAX请求。 补充：AJAX中的同步和异步AJAX中的同步：当AJAX任务开始的时候(XHR.SEND),一直需要到READYSTATE===4的时候任务才结束，此时才可以处理其它的事情。并且只有当其它的任务完成后，我们再看是否到4，到4之后做一些相关的操作。 AJAX中的异步：当AJAX任务开始的时候(XHR.SEND),不需要到READYSTATE===4，我依然可以处理其它的事情。 下面是几个同步编程和异步编程的几个编程题 1、问：下面的会在控制台输出几次，输出的分别是什么？ 123456var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.onreadyStatechange=function()&#123;console.log(xhr.readyState); &#125;; xhr.send(null); 答案：会输出三次，分别是2、3、4原因：因为第三个参数是true，所以这里是异步编程，所以绑定了xhr.onreadyStatechange这个事件一个方法，只要AJAX状态码发生改变，就会执行对应的这个事件绑定的对应方法。因为在open之后AJAX状态码已经变为了，所以当由1变到2的过程中，就会触发这个事件，对应后面从2到3,3到4也是这个原理，所以最终会输出三次，值分别：2、3、4 2、问：下面的会在控制台输出几次，输出的分别是什么？ 123456var xhr=new XMLHttpRequest; xhr.onreadyStatechange=function()&#123;console.log(xhr.readyState); &#125;; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null); 答案：会输出四次，分别是1、2、3、4。原因：因为这里open之前就已经绑定了这个方法，所以AJAX状态码从0变到了的过程中就会触发这个方法，所以会输出1； 3、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; xhr.send(null); 答案：会输出一次，是4。原因：代码上到下执行，当AJAX状态码为1的时候为onreadyStatechange这个事件绑定了一个方法，然后当任务执行完成之后，AJAX状态码变为4，触发这个事件，输出4。 4、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; 答案：会输出3次，分别是2、3、4 5、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.send(null); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; 答案：0次，什么都不输出原因：采用同步编程，在AJAX状态码变为4之前，什么都不做，而且在这之前也没有绑定xhr.onreadyStatechange事件，所以在这之前什么都不会做。也没有记录对应的AJAX状态码状态码值，在AJAX状态码变为4之后，绑定了一个事件，但是后面AJAX状态码不会变了，因此永远不会触发事件。]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM0级事件绑定和DOM2级事件及其扩展]]></title>
    <url>%2F2017%2F10%2F27%2FDOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在页面上写一个id为box的一个div，然后设置一些它的宽度和高度，然后在后面在做事件绑定的时使用。先是使用DOM0级事件绑定。 12box.onclick=function()&#123;console.log(1)&#125;; box.onclick=function()&#123;console.log(2)&#125;; 后面这个事件会把前一个事件给覆盖掉，最后在控制台中只会输出一个2.因为在使用DOM0级事件绑定的时候，只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉（这里主要是某一个行为绑定一次方法，不同的行为是可以绑定同一个方法的，比如这里是1box.onclick=function()&#123;console.log(2)&#125;; 这里是可以输出2的）；所以最后在控制台只能输出一次2。DOM0级事件绑定和DOM2级事件绑定最大的区别也是在这里，但是DOM2级事件中也有一些其他特别的地方。 1、基础；当我们使用DOM2级事件绑定，它的原理是让box通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现的。DOM2级事件绑定解决了DOM0级事件绑定中“只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉”这个问题，比如下面代码 12box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false); box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false); 点击box的时候，控制台上输出了1和2，方法中的第三个参数false表示的是该事件在冒泡阶段触发。总结出DOM2级事件可以给某一个元素的同一个行为绑定多个不同的方法。 2、DOM2； DOMO中行为类型，我们用DOM2一样可以绑定；而且DOM2中还提供了DOM0中没有的行为类型，比如DOM2中有一个行为DOMContentLoaded（当页面中的DOM结构或者是叫HTML结构加载完成触发的行为）这个行为是DOM0中没有的。像这个事件的绑定是这样的。 12document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;&#125;,false) ; window.onload=function()&#123;&#125;; 上面的两个事件绑定是有区别的，这个代表的意思是当页面中所有的资源都加载完成（图片、HTML结构、音视频…）才会执行后面的函数；并且在一个页面中只能使用一次，后面再写会把前面的覆盖掉，因为它是DOM0事件绑定，所以只能绑定一次。并且在jQuery中也提供了类似的方法 ： 1$(document).ready(function()&#123;&#125;)---&gt;$(function()&#123;&#125;); 只要也拿中的HTML结构加载完成就会执行对应的函数；并且在一个页面中可以出现多次，因为jQuery在写这个方法的时候是使用DOM2级事件绑定来写的，并且绑定的行为是DOM2中的“DOMContentLoaded”这个行为来绑定的。 3、移除DOM2事件绑定：前面两行代码中，里面的this是box，这里并不能移除事件绑定，因为两个匿名函数是两个不同的堆内存，因此不能移除事件绑定；把匿名函数换成实名函数就可以了，比如后面两行代码： 1234box.addEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false); box.removeEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false)； function fn1()&#123;console.log(this)&#125;； box.removeEventListener(&quot;click&quot;,fn1,false)； 这里就可以实现移除了，并且在控制台中不会输出任何东西，因为在刚绑定的时候就已经移除了。移除的时候需要保证三个参数：行为、方法、那个阶段发生，一个都不能差，因为在使用DOM2事件绑定的时候，我们一般绑定的都是实名函数，如果这样：1box.removeEventListener(&quot;click&quot;,fn1,true)； 就移除掉了，还会输出this； 4、注意点只能给某个元素的同一个行为绑定多个“不同”的方法（如果方法相同了，只能留一个），例如： 123function fn1()&#123;console.log(1)&#125;； box.removeEventListener (&quot;click&quot;,fn1,false)； box.removeEventListener(&quot;click&quot;,fn1,false)； 在点击的时候只会输出一个1。当行为触发，会按照绑定的先后顺序依次把绑定的方法执行；执行的方法中的this是当前被绑定事件的本身。并且在绑定方法的时候，浏览器天生自带的一个东西叫事件池（也有叫程序池的），用来存储绑定的事件的。 但是在IE6~8浏览器中不支持addEventListener/removeEventListener,如果想要实现DOM2级事件绑定只能用attachEvent,移除是使用detachEvent。 box.attachEvent(“onclick”,fn1); 并且它只有两个参数，不能向addEventListener那样控制在那个阶段发生，只能在冒泡阶段发生，行为需要添加”on”,和DOM0特别类似]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客的感受]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天注册了一个hexo+GitHub的一个博客。下面的是一些自己一些的感受。改天有时间写一个详细版的教程关于建立个人博客的。虽然网上已经有很多了，但是自己还是有不少想要分享的地方，下面的是最简单的几点，也是自己写的第一篇博客。 1、_config的语法非常严谨、当你要用里面的语法的时候首先需要做的一件事情把对应地方的#去掉，如果不把你想要设置的对应的地方的#去掉，当你在执行hexo g的时候会报或者是 你设置的这个地方对应的效果没有效果。 2、_config在设置的时候，”：“后面必须一个空格，这也是因为_config的语法比较严谨的原因 3、GitHub有缓存时间，这是一个比较令人头疼的问题，自己在_config设置完所有的参数之后，然后执行hexo g、hexo d.然后是过了几分钟之后自己打开了自己博客，发现竟然返回了404页面，当时也是比较懵逼的，然后就一直谷歌上面各种找原因。看到一个人回答说是GitHub的缓存原因。这才放心，后面等了一会儿之后设置的东西相应的显示出来了。 总结：总的来说大体常见的问题就是这些。在打扮博客的过程中肯定会碰到各种各样的问题，抽时间来一个大总结。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
