<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[call、apply、bind的区别]]></title>
    <url>%2F2017%2F11%2F07%2Fcall%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[apply和call的作用是一模一样的，都是用来改变方法下的this关键字并且把方法执行，并且在”严格模式”下和非严格模式下对于第一个参数书null和undefined这种情况也是一样的。当在JS开始的时候在最前面加一句代码叫:”use strict“表示告诉当前当前浏览器，接下来的JS代码将按照严格模式编写严格模式 在非严格模式下，函数定义的形参和arguments是存在映射关系的，一个变另一个也跟着变, 但是在严格模式下这个是没有映射关系的。并且在严格模式下禁止我们使用arguments.callee 和arguments.callee.caller; call代码如下: 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; &apos;use strict&apos;;//告诉当前当前浏览器，接下来的JS代码将按照严格模式编写 var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2); console.log(this); &#125; //fn(100,200);//this是Window num1=100，num2=200 //fn.call(100,200);//this-&gt;100 num1=200 num2=undefined //fn.call(obj,100,200);//this-&gt;obj num1=100 num2=200 /*fn.call();//this-&gt;window 在严格模式下 this-&gt;undefined fn.call(null);//this-&gt;window 在严格模式下this-&gt;null fn.call(undefined);//this-&gt;window 在严格模式下this-undefined */&lt;/script&gt; 我们发现严格模式下的this相对于非严格模式的this主要区别在于：对于JS代码没有写执行 主体去情况下，非严格模式默认是在Window执行的，所以this指向的是Window;但是在严格 模式下没有写执行主体，this指向是undefined. apply123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2); console.log(this); &#125; //fn.call(obj,100,200);//-&gt;这行代码和下面这行代码的作用相同 fn.apply(obj,[100,200]);&lt;/script&gt; 和call的区别 call在给fn传递参数的时候是一个一个传递的，而apply不是一个个传，而是要把fn传递的参数值统一放在一个数组中进行操作，但是也相当于一个个的给fn的形参赋值. bind这个方法在IE6-8上不兼容-&gt;和call和apply方法类似，都是用来改变this关键字的。但是这个方法是一个预处理的效果，事先把this变为我们想要的结果，并且把函数中的参数值也准备好。以后用到了直接执行即可。 用代码表示为: 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;ABC&quot;&#125;; function fn(num1,num2) &#123; console.log(num1+num2,this); &#125; //fn.call(obj,100,200);//-&gt;已经执行了，会输出值&quot;300,&#123;name:&quot;ABC&quot;&#125;&quot;; fn.bind(obj,100,200);//仅仅是改变了fn中的this为obj,传递参数值，并没有执行fn这个方法 var tempFn=fn.bind(obj,1,2)//-&gt;&quot;3,&#123;name:&quot;ABC&quot;&#125;&quot;;这时候fn就执行了,这就是bind的作用&lt;/script&gt; bind的还有一个作用是事先固定值的功能，比如： 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function fn(num1,num2) &#123; console.log(num1+num2，this); &#125; fn.bind(this,100);//-&gt;这里bind的作用不是改变this问题，this还是Window，但是这里是先 在函数里面固定的传入第一个参数值num1,第二个参数值在执行的时候可以在后面再传递进去。比如下 面这行代码 var tempFn=fn.bind(this,100); tempFn(2);//-&gt;这里相当于传递进来了第二个参数num2，输出值为&quot;3,window&quot;,这里的作用并没有改变this值。如果不传递第二个参数的话第二个参数默认是undefined tenpFn();//-&gt;&quot;NaN,window&quot;&lt;/script&gt; bind体现了JS中的预处理思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要是用到了，直接的执行即可。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 部署到 Github Pages 文件夹大小写问题]]></title>
    <url>%2F2017%2F11%2F06%2FHexo%20%E9%83%A8%E7%BD%B2%E5%88%B0Github%20Pages%20%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题简介使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404问题。 譬如 Hexo 生成了一个 javascript js文件夹，但是我后来把它改成了 javascript Js，即 j 的首字母大写了。Hexo会生成正确，但部署到 Github 上却老是不正确。 原因git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。 解决办法 进入到博客项目中 .deploy_git文件夹，这个文件夹在 “博客目录-&gt;.deploy_git-&gt;git”下，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false，如图所示，这是我已经修改过的，原来是true。 删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步是清空你的 github.io 项目中所有文件。在博客项目中，执行下面命令。 1234cd .deploy_git it rm -rf * git commit -m &apos;clean all file&apos; git push 使用 Hexo 再次生成及部署，在上面命令执行完之后执行下面命令,问题解决。 123cd .. hexo clean hexo deploy -generate]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储]]></title>
    <url>%2F2017%2F11%2F05%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[JS中的本地存储: 使用JS向浏览器向浏览器某一个位置中存储一些内容，浏览器即使关闭了，存储了信息也不会销毁，当在重新打开浏览器的时候我们依然可以获取到上一次存储的信息。 一、本地存储的方案传统: 1、cookie:把信息存储到客户端的浏览器中（但是项目服务器端也是可以获取COOKIE的） 2、session:把信息存储到服务器上的（服务器存储） HTML5:webStorage 1、localStorage:永久存储到客户端本地 2、sessionStorage:信息会话存储，回话窗口存在信息也存在，会话窗口关闭信息也消失了 打开谷歌控制台，按F12可以Application中可以看到这些相应的窗口:如图所示 COOKIE localStorage sessionStorage三者之间的用法以及区别webStorage localStorage和sessionStorage的用法是一样的：setItem([key],[value]):向客户端的本地存储一条记录，存储的[value]值需要使字符串格式的，如果编写的不是字符串，浏览器也会默认转化为字符串然后进行存储;存储的[key]是不会重复的，如果之前有的话，把存储的信息值重新进行修改； 1、getItem([key]):获取之前存储的值 2、removeItem([key]):移除key对应的那条记录 3、clear():把当前源下所有的存储记录都移除掉 4、localStorage.length:获取存储的记录条数 5、localStorage.key(0):获取索引为0这一项的key是什么 用代码表示为: 1234567console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;7&quot; localStorage.setItem(&apos;age&apos;,JSON.stringify(&#123;name:&apos;abc&apos;&#125;)); console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;&#123;&quot;name&quot;:&quot;abc&quot;&#125;&quot; localStorage.removeItem(&apos;age&apos;); localStorage.clear(); console.log(localStorage.length);//-&gt;0 console.log(localStorage.key(0));//-&gt;&apos;null&apos; 下面是执行下面这段代码之后存储在控制台里面看到的效果: 1console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;7&quot; localStorage和sessionStorage的区别: 1、localStorage属于永久存储到本地，不管是刷新页面还是关掉页面或者关掉浏览器，存储的内 容都不会消失，只有我们手动删除才会消失（不管是杀毒软件还是浏览器自带的清除历史记录 的功能都不能把localStorage存储的内容移除掉）; 2、sessionStorage属于临时会话存储，只要当前的页面不关闭，信息就可以存储下来，但是页 面一旦关闭,存储的信息就会自动关闭（F5刷新只是把当前的DOM机构等进行重新渲染，会话并 没有关闭） cookie cookie和locaStorage的区别: 1、cookie兼容所有浏览器，但是localStorage不兼容IE6-8 2、cookie存储内容的大小是有限制的，一般同源下只能存储4KB内容;localStorage存储的内 容大小也有限制，一般同源下只能存储5MB; 3、cookie存储的内容是有过期时间的，而localStorage是永久存储到本地，使用杀毒软件或者 清除垃圾的功能都可能把存储的cookie给删除掉 4、用户可能出于安全的角度禁用cookie(无痕浏览)，但是不能禁用localStorage.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的forEach和map方法解读]]></title>
    <url>%2F2017%2F11%2F05%2FforEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[forEach和map方法都是用来遍历数组中的每一项的; forEach 1、数组中有几项，那我们传递进去的匿名函数就需要执行几次 2、每一次执行匿名函数的时候，还给其浏览器给其默认传递了三个参数值：数组中的当前项 item，当前项的索引index，原始数组input。 3、理论上我们的方法是没有返回值的，仅仅遍历数组中的每一项不对原来的数据进行修改，但是 我们可以通过数组的索引来修改原来的数组。 执行下面代码：123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var ary=[12,23,34,45,43]; var res=ary.forEach(function (item,index,input) &#123; console.log(arguments); input[index]=item*10; &#125;); console.log(res);//-&gt;undefined console.log(ary);&lt;/script&gt; 控制台中返回结果如图所示: 原因：执行了5函数，输出了5次arguments,并且函数在遍历的时候是从索引0开始依次遍历的。 mapmap的回调函数中支持return返回值，return的后面是啥，相当于把数组中的这这一项改变为啥(但是并不影响原来的数组，只是相当于把原来的数组克隆一份，把克隆的这一份数组中的对应项改变了)。 用代码表示为: 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var ary=[12,23,34,45,43]; var res=ary.map(function (item, index, input) &#123; return item*10; &#125;); console.log(res);//-&gt; [120, 230, 340, 450, 430] console.log(ary);//-&gt;[12, 23, 34, 45, 43]&lt;/script&gt; 注意不管是forEach还是map都支持第二个参数，第二个参数的意识是把匿名函数中的this进行修改为第二个参数值。 代码表示: 1234567891011&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var obj=&#123;name:&quot;abc&quot;&#125;; var ary=[12,23,34,45,43]; ary.forEach(function (item, index) &#123; console.log(this); &#125;); ary.forEach(function (item, index) &#123; console.log(this); &#125;,obj);&lt;/script&gt; 在控制台中输出的结果如图所示: 证实了上面的结论。 不管是forEach还是map在IE6-8下都不兼容]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的同步和异步编程]]></title>
    <url>%2F2017%2F11%2F05%2FJS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JS中的两种编程思想：同步、异步。 同步同步编程:上一件事情没有完成，继续做上一件事情，只有上一件事情完成了，才会做下一件事情(JS大部分都是同步编程的)。如下面代码：（1）、（2）分别代表第一次和第二次输出。 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; for(var i=0;i&lt;100000;i++)&#123; if(i===99999)&#123; console.log(&quot;循环结束了~~&quot;)//-&gt;(1) &#125; &#125; console.log(&quot;ok&quot;);//-&gt;(2)&lt;/script&gt; 原因:for循环就是同步编程的，只有循环结束后，才会执行下面的代码,因此会先输出前面的，再输出后面的。 再比如下面这段代码: 123456&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; while (1)&#123; &#125; console.log(&quot;ok&quot;);//-&gt;不会有结果输出，并且浏览器还会崩溃&lt;/script&gt; 原因:因为上面的循环是死循环，循环永远不会结束,JS不会跳过上面那段循环来执行下面的循环。 异步解读：首先规划要做一件事情，但是不是立马去执行这件事情，需要等一定的时间，这样的话我们不会继续等着它执行，而是继续执行下面的操作，”只有下面的事情都处理完成了”.只有当下面的事情都处理完成了，才会返回头处理之前的事情；如果下面的事情没有处理完成，不管之前的事情有没有处理完成，都踏踏实实的给我等着。在JS中异步编程只有四种情况：定时器都是异步编程的、所有事件绑定都是异步编程的、AJAX读取数据的时候，我们一般设定为异步编程、回调函数也是异步编程的。 比如下面这段代码: 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;1(2) &#125;,1000); console.log(n);//-&gt;0(1)&lt;/script&gt; 原因:定时器是异步编程的，在1000ms之后再执行定时器中的方法，因此会先输出0，再输出1。 关于浏览器的最小等待事件问题 比如下面的这段代码： 12345678&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;1(2) &#125;,0); console.log(n);//-&gt;0(1)&lt;/script&gt; 原因:每一个浏览器对于定时器的等待时间都有一个最小值：谷歌大概:5~6ms,IE大概:13~14ms,如果设置的等待时间小于这个值，不起作用，还是需要等到最小时间才执行；尤其是写0也不是立即执行； 定时器设置的等待时间不一定就是最后执行的时间 看下面的这段代码： 12345678910111213&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n++; console.log(n);//-&gt;不执行 &#125;,0); console.log(n);//-&gt;0(1) while (1)&#123; n++;//-&gt;死循环 &#125; console.log(n);//-&gt;不执行&lt;/script&gt; 原因:执行到while的时候出现了死循环，因此定时器里面的方法永远不会执行。 定时器是谁先到先执行谁 如下面这段代码： 12345678910111213141516&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var n=0; window.setTimeout(function()&#123; n+=2; console.log(n);//-&gt;7(4) &#125;,20); window.setTimeout(function()&#123; n+=5; console.log(n);//-&gt;5(3) &#125;,5); console.log(n);//-&gt;0(1) for(var i=0;i&lt;10000000;i++)&#123; &#125; console.log(n);//-&gt;0(2)&lt;/script&gt; 原因：JS在执行的时候会有一个类似于设置闹钟的那种机制的任务队列，不是之前设置的闹钟就之前叫，而是不管是什么时候设置的，谁的时间先到了就谁先叫。如图所示。 上面仅仅是讲了定时器这一种异步编程思想，所有事件绑定、AJAX读取数据的时候、回调函数这几 种的原理也和定时器的一样]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据类型检测的四种方式]]></title>
    <url>%2F2017%2F11%2F04%2FJavaScript%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%98%AF%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、typeof 用来检测数据类型的运算符使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串包含了对应的数据类型，例如:’number’、’string’、’boolean’、’undefined’、’function’、’object’。局限性： 1typeof null-&gt;&quot;object&quot; 不能具体细分是数组还是正则，还是对象中其他的值，因为使用typeof检测数据类型，对于对象数据类型中的左右的值，最后返回的结果都是”object” 二、instanceof 检测某一个实例是否属于这个类优点：它可以用来检测是数组还是正则了。局限性：对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定的区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这类的实例，对于字面量创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散型，导致了可以使用JS原型上的方法。如下面的代码。 12345678910console.log(1 instanceof Number);//-&gt;控制台输出false console.log(new Number(1) instanceof Number);//-&gt;控制台输出true var ary=[]; function fn() &#123; &#125; console.log(ary instanceof Array)//-&gt;控制台输出true console.log(ary instanceof Object)//-&gt;控制台输出true console.log(fn instanceof Function)//-&gt;控制台输出true console.log(ary instanceof Object)//-&gt;控制台输出true 因此，它会产生以下影响： 1、不能用来检测和处理字面量方式创建出来的基本数据类型值。 2、instanceof的特性：只要在当前实例的原型链上，我们用其检测出来的结果都是true。 3、在类的原型继承中，我们最后检测出来的结果未必准确。只要它的原型链上有这个类，最后用这 方法检测出来的结果都是true。 三、constructor: 构造函数 作用和instanceof非常相似有如下代码：123456var obj=[],num=1，reg=/^$/; console.log(obj.constructor===Array);//-&gt;true console.log(obj.constructor===RegExp);//-&gt;false console.log(num.constructor===Number);//-&gt;true console.log(reg.constructor===RegExp);//-&gt;true console.log(reg.constructor===Object);//-&gt;false 优点:可以看出和instanceof相比，constructor可以处理基本数据类型的检测。不同:constructor和instanceof不一样的地方在于，constructor在检测的时候先在私有属性上找，找到之后就不会往后面找了，所以在用来检测Object的时候，一般情况下是检测不了的。局限性：我们可以把类的原型进行重写，在进行的重写过程中，很有可能之前contructor给覆盖掉了，这样检测出来的结果就是不准确的。 扩展：对于特殊的数据类型null和undefined,他们的所属类是Null和Undefined,但是浏览 器把这两个类保护起来了，不允许我们在外面访问使用。 四、Object.prototype.toString.call()这是最准确检测数据类型的方法； 解读：首先获取Object原型上toString方法，让方法执行，并且改变方法中的this关键字的指向。先看一下面的代码。 123456console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot;console.log((128).toString(2/8/10));-&gt;把数字转化为二进制/八进制/十进制，Number原型上的toString方法支持把数字转化为相的进制。 console.log((1).__proto__.__proto__.toString());//-&gt;&quot;[object Object]&quot; console.log(&quot;zhufeng&quot;.toString());//-&gt;也是转为为字符串，但是不支持进制 console.log(&#123;&quot;name&quot;: &quot;abc&quot;&#125;.toString());//-&gt;&quot;[object Object]&quot; console.log(Math.toString())//-&gt;&quot;[object Math]&quot; 通常情况下对toString的理解： 对于Number、String、Boolean、Array、RegExp、Date、Function原型上的toString()方法都 是把当前的数据类型转换为字符串类型（他们的作用仅仅是用来转换为字符串 Object.prototype.toString并不是用来转换为字符串的。 Object.prototype.toString它的作用是返回当前方法的执行主体（方法中this）所属类的详 细信息。var obj={name:&quot;xyz&quot;};//-&gt;&quot;[object Object]&quot; console.log(obj.toString());//-&gt;toString中的this是obj,返回的是obj所属类的信 息-&quot;[object Object]&quot;第一个object代表当前实例是对象数据类型的(这个是固定)，第二个 Object,代表的是obj是object这个类的一个实例。 1234567891011var ary=[]; console.log(Object.prototype.toString.call(ary));//-&gt;&quot;[object Array]&quot;; console.log(Object.prototype.toString.call(/^$/));//-&gt;&quot;[object RegExp]&quot;; console.log((&#123;&#125;).toString.call(1));//-&gt;&quot;[object Number]&quot;; console.log((&#123;&#125;).toString.call(&quot;dsas&quot;));//-&gt;&quot;[object String]&quot;; console.log((&#123;&#125;).toString.call(true));//-&gt;&quot;[object Boolean]&quot;; console.log((&#123;&#125;).toString.call(null));//-&gt;&quot;[object Null]&quot;; console.log((&#123;&#125;).toString.call(undefined));//-&gt;&quot;[object Undefined]&quot;; console.log((&#123;&#125;).toString.call(function () &#123;&#125;));//-&gt;&quot;[object Function]&quot;; console.log((&#123;&#125;).toString.call(new Date));//-&gt;&quot;[object Date]&quot;; console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot; 从上面代码可以总结春：Object.prototype.toString并不是用来转换为字符串的，返回的是 obj所属类的信息息-&quot;[object &quot;参数2&quot;]&quot;第一个object代表当前实例是对象数据类型的(这个 是固定)，第二个参数，“参数2”,代表的是检测的这个所属的类。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中检测兼容的三种方式]]></title>
    <url>%2F2017%2F11%2F04%2FJS%E6%A3%80%E6%B5%8B%E5%85%BC%E5%AE%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、使用try、catch来处理兼容前提：必须保证try中的代码在不兼容浏览器中执行的时候报错，这样的话我们才可以用catch捕获到异常的信息，进行其它的处理，示例代码如下面所示。缺点：不管是什么浏览器，都需要把try中的代码都需要把try中的代码执行一遍，如果当前是IE7。window.getComputedStyle本身是不兼容的，但是我们也要把它先执行一遍，报错了再把curEle.currentStyle执行一遍（消耗性能），因此使用try处理兼容只有在万不得已的情况下才使用它。 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123;//-&gt;curEle指的是操作的元素，attr指的是元素属性 var val=null; try&#123; val=window.getComputedStyle(curEle,null)[attr]; &#125;catch(e)&#123; val=curEle.currentStyle[attr]; &#125; return val; &#125;&lt;/script&gt; 二、判断当期浏览器中是否存在这个属性和方法判断当期浏览器中是否存在这个属性和方法，存在就兼容，不存在就不兼容。代码如下所示 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123; var val = null; if (getComputedStyle in window) &#123;//-&gt;如果返回结果是true，说明Window下有getComputedStyle，代表兼容 val = window.getComputedStyle(curEle, null)[attr]; &#125; else &#123; val = curEle.currentStyle[attr]; &#125; return val; &#125;&lt;/script&gt; 三、通过检测浏览器版本和类型来处理兼容代码如下所示： 1234567891011 &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function getCss(curEle,attr) &#123; var val = null; if (/MSIE(6|7|8)/.test(navigator.userAgent)) &#123;//-&gt;说明是IE6-8浏览器 val = curEle.currentStyle[attr]; &#125; else &#123; val = window.getComputedStyle(curEle, null)[attr]; &#125; return val; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中常用的六种继承方式]]></title>
    <url>%2F2017%2F11%2F04%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、原型链继承可枚举和不可枚举：我们在JavaScript中使用for..in遍历对象的时候，会发现下面的情况： 12345678&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123;console.log(key)&#125;&lt;/script&gt; 最后在谷歌的控制台中会输出: name age aaa 这说明在使用for..in 遍历对象的时候默认会把自己私有的和它所属类的原型上扩展的属性和方法都可以遍历到，但是一般情况下，我们遍历对象只需要遍历私有的即可，我们可以使用以下的判断进行处理：12345678910&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123; if(obj.propertyIsEnumerable(key))&#123;console.log(key) &#125; &#125;&lt;/script&gt; propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false，下面为大家介绍下其具体的使用：propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false 1、这个属性必须属于实例的,并且不属于原型. 2、这个属性必须是可枚举的,也就是自定义的属性,可以通过for..in循环出来的 只有符合上面这两个要求，才会返回true。因为在使用for…in遍历对象对象的时候，在前面加一个这个方法来判断一下，原型上的自己定义的属性就不会被遍历出来了。 也可以用下面的方法来只遍历出对象中的私有属性： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;; Object.prototype.aaa = function () &#123; &#125;; for(var key in obj)&#123; if(obj.hasOwnProperty(key))&#123;console.log(key) &#125; &#125;&lt;/script&gt; hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。只遍历出私有私有属性，而不会遍历出原型链上的属性。 加上这两个判断之后，控制台中会输出同样的结果，结果是： name age Object.create(proObj):创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6-8不兼容（ECMAScript5），用下面的代码解释： 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123; getX: function () &#123; &#125; &#125;; var obj2 = Object.create(obj); obj.getY = function () &#123; console.log(2) &#125;; obj2.getY(); console.log(obj2); console.log(obj);&lt;/script&gt; 最谷歌控制台中输出的结果如图所示:2是执行 obj2.getY();输出的结果，中间的这个是obj2，最后这个是obj，可以看出，通过执行Object.create(obj)这个方法，创建出来了obj2这个对象，并且把，并且还把obj作为这个对象的原型。可以看出，在obj2和Object这个基类之间多了一个原型链。而这一级的对象就是obj。 原型继承 1、 原型继承是”JS”中最常用的一种继承方式,子类B想要继承父类A中的所有的属性和方法（私有 +公有），只需要让B.prototype=new A,即可。 2、 原型继承的特点：它是把父类私有的+公有的都继承到了子类的原型上（子类公有的）; 3、核心:原型链继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是B和A之间增加了原型链的链接看，以后B的实例n想要用A中的getX方法，需要一级级的查找来使用。代码就这样表示 123456789&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; function B()&#123; this.y=200; &#125; B.prototype=new A;&lt;/script&gt; 二、call继承call继承的最终结果是把父类私有的属性和方法克隆一份一模一样的，作为子类私有的属性和方法 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B()&#123; A.call(this); &#125; var n=new B; console.log(n.x);&lt;/script&gt; 最后在控制台中最终会输出100，为什么了？new B是创建B这个类的一个实例，在函数B中的this就是这个实例，这里表示的就是n,A.call(this)指的是把函数A中的this变为函数B中的this，而new B之后函数B中的this是n，所以最后在控制台中输出的是100。 三、冒充对象继承冒充对象继承：把父类私有的+公有的克隆一份一模一样给子类私有的。代码用下面的来表示 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; var temp=new A; for(var key in temp)&#123; this[key]=temp[key]; &#125; temp=null; &#125; var n=new B;&lt;/script&gt; 四、混合模式继承混合模式继承：指的是原型继承+call继承 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; A.call(this); &#125; B.prototype=new A; B.prototype.constructor=B; var n=new B;&lt;/script&gt; 这种继承方式会让父类私有的和公有的都会在子类公有的上面有一份，但是在原型链查找的时候会先查找私有属性，所以也不影响整体。优点是父级私有属性都放在子类的私有上了。 五、寄生组合式继承父类公有的给子类公有的，父类私有的给子类私有的。 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; function A()&#123; this.x=100; &#125; A.prototype.getX=function()&#123; console.log(this.x); &#125;; function B() &#123; A.call(this); &#125; B.prototype=Object.create(A.prototype);//这句代码的含义是把B的原型的地址换成了A的原型的地址。 B.prototype.constructor=B; var n=new B;&lt;/script&gt; 六、中间类继承法-&gt;IE下不兼容这段代码是一个数组，在去掉一个最大值和最小值之后求它的平均值。 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; function avgFn() &#123; Array.prototype.sort.call(arguments,function (a,b) &#123; return a-b; &#125;); Array.prototype.pop.call(arguments); Array.prototype.shift.call(arguments); return (eval(Array.prototype.join.call(arguments,&quot;+&quot;))/arguments.length).toFixed(2); &#125; console.log(avgFn(10,20,30,34,44))//-&gt;结果是28&lt;/script&gt; 使用中间类继承法：代码入下面所示 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; function avgFn() &#123; arguments.__proto__= Array.prototype; arguments.sort(function(a,b)&#123; return a-b; &#125;); arguments.pop(); arguments.shift(); return eval(arguments.join(&quot;+&quot;))/arguments.length; &#125; console.log(avgFn(10,20,30,34,44))//-&gt;结果是28&lt;/script&gt; 这就是直接借用原型链的机制来形成的一种继承方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP]]></title>
    <url>%2F2017%2F11%2F03%2FJSONP%2F</url>
    <content type="text"><![CDATA[综述JSONP和AJAX相同，都是向客户端向服务器发送请求:给服务器传递数据或者从服务器端获取数据的方式。但是他们两种方式之间是有区别的：JSONP属于非同源策略（跨域请求），说明一下，实现跨越的方式有很多种，只不过JSONP是最常用的；而AJAX是属于同源策略。 同源和非同源的区别同源和非同源的区别在于用当前页面的地址于数据请求的接口地址相比较：比如当前页面地址是：https://www.zhihu.com/people/fanzhanxiang;数据请求接口的地址是：https://github.com/fanzhanxiang；判断是使用AJAX请求还是JSONP请求我们需要看以下三个方面。 1、协议 2、域名 3、端口号 上面三个部分完全相同属于同源策略，我们使用AJAX获取数据；只要有一个不一样的，就属于非同源，我们一般使用JSONP来获取数据。就比如上面这两个地址，他们的协议（https和https）、域名（www.zhihu.com和github.com）、端口号（443和443）端口号和域名不一样，因此想要在当前页面中获取这个数据请求的地址需要使用非同源策略。 JSONP的原理JSOPN是利用在JavaScript中的script标签的特性，在script的世界中，没有跨域同源一说，只要你给它的SRC属性中的地址是一个合法的地址，script都可以把对应的内容请求回来。 JSONP就是利用了这个原理(JSONP请求一定需要对方的服务器做支持才可以)： 1、我们首先把需要请求数据的那个API数据接口的地址，赋值给script的SRC 2、把当前页面中的某一个函数名当做参数值传递给需要跨域请求数据的服务器（URL问号传参一 般都是这么写:canllback=fn） 3、服务器接到你的请求之后，需要进行特殊的处理：把你传递进来的函数名和他需要给你的数据 拼接成一个字符串，例如：我们传递进去的函数名是fn，它准备好的数据是&apos;fn(需要给我们的数 据)&apos;； 4、最后服务器把准备的数据通过HTTP协议返回给客户端，其实就是让我们的fn执行，而且还给fn 传递了一堆数据，那些数据就是我们想要的； 比如下面这个例子 12345678910&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fn(data)&#123; console.log(data); &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;http:// matchweb.sports.qq.com/kbs/calendar?columnId=100000&amp;callback=fn&quot;&gt; &lt;/script&gt; &lt;/body&gt; 在谷歌控制台中的输出入下图所示： jQuery的AJAX和JSONP调用AJAX请求 12345678910111213141516&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url:&quot;地址&quot;, type:&quot;请求方式&quot;, dataType:&quot;json&quot;, data:null,//-&gt;使用post请求是非服务器传递的内容 async:true,//-&gt;同步还是异步，默认是异步 cache:false,//设定GET请求的时候不走缓存数据，原理其实就是在URL末尾加随机数，默认值是true timeout:1000,//设置超时时间 一般都设定3000ms，超过时间之后就跑到error success:function(data)&#123;//-&gt;data是请求回来的数据 console.log(data); &#125;, error:function()&#123;&#125;,//请求失败的时候执行这个 &#125;);&lt;/script&gt; JSONP请求JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，而且jQuery会默认就会给JSONP的请求清除缓存 123456789101112&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url: &quot;请求地址&quot;, dataType: &quot;jsonp&quot;, jsonpCallback: &quot;fn&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的 jsonp:&quot;cb&quot;,//-&gt;把传递函数名的那个形参callback变为cb success: function (data) &#123; console.log(data); &#125; &#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>JSONP</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F10%2F31%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax:async javascript and xml 叫做异步的JS和XML(可扩展标记语言)，它是一种客户端的JS方法，用来向服务器端发送请求(还可以传递给服务器数据)，然后把服务器端返回的内容获取到，它一般运行在客户端的浏览器中的。 Ajax的四个步骤 12341、var xhr=new XMLHttpRequest; 2、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]); 3、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text (xhr.status))&#123;var val=xhr.responseText&#125; &#125;; 4、xhr.send(&quot;要传递给服务器的内容&quot;); 1、第一步11、var xhr=new XMLHttpRequest; 创建一个AJAX对象（在IE6及更低版本的浏览器中不兼容） 2、第二步12、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]); 发送前的基本信息配置：配置请求方式，请求方式有GET、POST、PUT、DELETE、HEAD，上面是几种方式不管是哪一种都可以向服务器传递数据，也可以从服务器获取到数据，而且从本质意义上来讲上面几种请求方式是没有什么区别的，例如用POST做的事情用GET也能做。以下区别都是开发者约定俗成的规范； 1、GET：一般应用于从服务器获取数据（给服务器的少，从服务器拿的数据多），使用GET请求给服 务器传递内容，我们一般都使用&quot;URL问号传参的方式&quot;；例如：xhr.open(&quot;get&quot;,&quot;/getList?num =2&quot;),但是这种方式传递的内容存在大小限制；因为GET通过URL传参给服务器，而每个浏览器对于 URL的长度存在限制，谷歌8kb、火狐7kb、IE2kb的长度限制，如果URL的长度超过限制，浏览器 会把超出的部分的截取。并且这个请求会出现缓存（这个缓存不一定304）。在项目中我们的GET请 求一般不会让其出现缓存，因此要清除缓存，清除GET请求缓存的方法是在URL的末尾加一个随机数 xhr.open(&quot;get&quot;,&quot;/getList?num =2&amp;_=&quot;+Math.random());在用get请求的时候与post 相比，是不安全的 2、POST：一般应用于向服务器推送数据（给服务器的多，从服务器上拿的少），我们一般使用&quot;请求 主体的方式&quot;传递给服务器，例如：xhr.open(&quot;post&quot;,&quot;/getList&quot;);xhr.send(&apos;{&quot;name &quot;:&quot;zhufeng&quot;,&quot;age&quot;:7&apos;)，这种传递方式理论上是没有大小限制的，并且这个请求是没有缓存的。 3、PUT：一般应用于给服务器上传资源文件（我们上传图片功能） 4、DELETE：一般应用于从服务器上删除资源文件 5、HEAD：一般应用于只获取服务器的响应头信息 第三个参数默认是异步；username:向服务器提供的用户名,userpass:向服务器提供的用户密码，这两个值一般都不写，只有服务器做了安全限制，只允许特定的用户访问，我们才传递过去。 3、第三步这一步不是必须的，如果自己不要拿回数据的话，就可以不需要执行这步，那么ajax只需要三步就可以完成。13、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text(xhr.status))&#123;var val=xhr.responseText&#125;&#125;; 给onreadyStatechange这个事件绑定一个方法，监听状态的改变(只要状态改变，就会触发这个事件绑定的相应方法执行)； xhr.readyState：AJAX状态码其中有5个值（0,1,2,3,4），可以代表当前AJAX处理的进度。 0：&quot;unset&quot;，表示当前的请求还没有发送； 1：&quot;opened&quot;,表示URL地址已经打开(发送前的参数配置已经完成)； 2：&quot;headers_received&quot;,表示响应头信息已经接收； 3：&quot;loading&quot;,主要返回的内容正在服务器端进行准备处理； 4：&quot;done&quot;:响应主体的内容已经成功返回客户端。 xhr.status:HTTP网络状态码，描述了服务器响应内容的状态，HTTP网络状态码有如下几种： 200 OR ^2\d{2}： (200或者以2开头的)都代表响应主体的内容已经成功返回了 301：永久重定向/永久转移 302：临时重定向/临时转移,服务器的负载均衡 304：本次获取的内容是读取缓存中的数据 400:客户端传递给服务器端的参数出现错误，客户端传递的参数有问题 401：无权限访问 404：访问的地址不存在 500：未知的服务器错误 503：服务器已经超负荷了，比如能承受10000人，那么第10001个人访问，如果没有做服务器的负载均 衡（302），那么这个人的状态码就是503; 4、第四步14、xhr.send(&quot;要传递给服务器的内容&quot;); 发送请求：参数是请求主体中给传递给服务器的内容；只有执行完第四步之后才开始一个AJAX请求。 补充：AJAX中的同步和异步AJAX中的同步：当AJAX任务开始的时候(XHR.SEND),一直需要到READYSTATE===4的时候任务才结束，此时才可以处理其它的事情。并且只有当其它的任务完成后，我们再看是否到4，到4之后做一些相关的操作。 AJAX中的异步：当AJAX任务开始的时候(XHR.SEND),不需要到READYSTATE===4，我依然可以处理其它的事情。 下面是几个同步编程和异步编程的几个编程题 1、问：下面的会在控制台输出几次，输出的分别是什么？ 123456var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.onreadyStatechange=function()&#123;console.log(xhr.readyState); &#125;; xhr.send(null); 答案：会输出三次，分别是2、3、4原因：因为第三个参数是true，所以这里是异步编程，所以绑定了xhr.onreadyStatechange这个事件一个方法，只要AJAX状态码发生改变，就会执行对应的这个事件绑定的对应方法。因为在open之后AJAX状态码已经变为了，所以当由1变到2的过程中，就会触发这个事件，对应后面从2到3,3到4也是这个原理，所以最终会输出三次，值分别：2、3、4 2、问：下面的会在控制台输出几次，输出的分别是什么？ 123456var xhr=new XMLHttpRequest; xhr.onreadyStatechange=function()&#123;console.log(xhr.readyState); &#125;; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null); 答案：会输出四次，分别是1、2、3、4。原因：因为这里open之前就已经绑定了这个方法，所以AJAX状态码从0变到了的过程中就会触发这个方法，所以会输出1； 3、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; xhr.send(null); 答案：会输出一次，是4。原因：代码上到下执行，当AJAX状态码为1的时候为onreadyStatechange这个事件绑定了一个方法，然后当任务执行完成之后，AJAX状态码变为4，触发这个事件，输出4。 4、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; 答案：会输出3次，分别是2、3、4 5、问：下面的会在控制台输出几次，输出的分别是什么？ var xhr=new XMLHttpRequest; xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.send(null); xhr.onreadyStatechange=function(){ console.log(xhr.readyState); }; 答案：0次，什么都不输出原因：采用同步编程，在AJAX状态码变为4之前，什么都不做，而且在这之前也没有绑定xhr.onreadyStatechange事件，所以在这之前什么都不会做。也没有记录对应的AJAX状态码状态码值，在AJAX状态码变为4之后，绑定了一个事件，但是后面AJAX状态码不会变了，因此永远不会触发事件。]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM0级事件绑定和DOM2级事件及其扩展]]></title>
    <url>%2F2017%2F10%2F27%2FDOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在页面上写一个id为box的一个div，然后设置一些它的宽度和高度，然后在后面在做事件绑定的时使用。先是使用DOM0级事件绑定。 12box.onclick=function()&#123;console.log(1)&#125;; box.onclick=function()&#123;console.log(2)&#125;; 后面这个事件会把前一个事件给覆盖掉，最后在控制台中只会输出一个2.因为在使用DOM0级事件绑定的时候，只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉（这里主要是某一个行为绑定一次方法，不同的行为是可以绑定同一个方法的，比如这里是1box.onclick=function()&#123;console.log(2)&#125;; 这里是可以输出2的）；所以最后在控制台只能输出一次2。DOM0级事件绑定和DOM2级事件绑定最大的区别也是在这里，但是DOM2级事件中也有一些其他特别的地方。 1、基础；当我们使用DOM2级事件绑定，它的原理是让box通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现的。DOM2级事件绑定解决了DOM0级事件绑定中“只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉”这个问题，比如下面代码 12box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false); box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false); 点击box的时候，控制台上输出了1和2，方法中的第三个参数false表示的是该事件在冒泡阶段触发。总结出DOM2级事件可以给某一个元素的同一个行为绑定多个不同的方法。 2、DOM2； DOMO中行为类型，我们用DOM2一样可以绑定；而且DOM2中还提供了DOM0中没有的行为类型，比如DOM2中有一个行为DOMContentLoaded（当页面中的DOM结构或者是叫HTML结构加载完成触发的行为）这个行为是DOM0中没有的。像这个事件的绑定是这样的。 12document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;&#125;,false) ; window.onload=function()&#123;&#125;; 上面的两个事件绑定是有区别的，这个代表的意思是当页面中所有的资源都加载完成（图片、HTML结构、音视频…）才会执行后面的函数；并且在一个页面中只能使用一次，后面再写会把前面的覆盖掉，因为它是DOM0事件绑定，所以只能绑定一次。并且在jQuery中也提供了类似的方法 ： 1$(document).ready(function()&#123;&#125;)---&gt;$(function()&#123;&#125;); 只要也拿中的HTML结构加载完成就会执行对应的函数；并且在一个页面中可以出现多次，因为jQuery在写这个方法的时候是使用DOM2级事件绑定来写的，并且绑定的行为是DOM2中的“DOMContentLoaded”这个行为来绑定的。 3、移除DOM2事件绑定：前面两行代码中，里面的this是box，这里并不能移除事件绑定，因为两个匿名函数是两个不同的堆内存，因此不能移除事件绑定；把匿名函数换成实名函数就可以了，比如后面两行代码： 1234box.addEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false); box.removeEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false)； function fn1()&#123;console.log(this)&#125;； box.removeEventListener(&quot;click&quot;,fn1,false)； 这里就可以实现移除了，并且在控制台中不会输出任何东西，因为在刚绑定的时候就已经移除了。移除的时候需要保证三个参数：行为、方法、那个阶段发生，一个都不能差，因为在使用DOM2事件绑定的时候，我们一般绑定的都是实名函数，如果这样：1box.removeEventListener(&quot;click&quot;,fn1,true)； 就移除掉了，还会输出this； 4、注意点只能给某个元素的同一个行为绑定多个“不同”的方法（如果方法相同了，只能留一个），例如： 123function fn1()&#123;console.log(1)&#125;； box.removeEventListener (&quot;click&quot;,fn1,false)； box.removeEventListener(&quot;click&quot;,fn1,false)； 在点击的时候只会输出一个1。当行为触发，会按照绑定的先后顺序依次把绑定的方法执行；执行的方法中的this是当前被绑定事件的本身。并且在绑定方法的时候，浏览器天生自带的一个东西叫事件池（也有叫程序池的），用来存储绑定的事件的。 但是在IE6~8浏览器中不支持addEventListener/removeEventListener,如果想要实现DOM2级事件绑定只能用attachEvent,移除是使用detachEvent。 box.attachEvent(“onclick”,fn1); 并且它只有两个参数，不能向addEventListener那样控制在那个阶段发生，只能在冒泡阶段发生，行为需要添加”on”,和DOM0特别类似]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客的感受]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天注册了一个hexo+GitHub的一个博客。下面的是一些自己一些的感受。改天有时间写一个详细版的教程关于建立个人博客的。虽然网上已经有很多了，但是自己还是有不少想要分享的地方，下面的是最简单的几点，也是自己写的第一篇博客。 1、_config的语法非常严谨、当你要用里面的语法的时候首先需要做的一件事情把对应地方的#去掉，如果不把你想要设置的对应的地方的#去掉，当你在执行hexo g的时候会报或者是 你设置的这个地方对应的效果没有效果。 2、_config在设置的时候，”：“后面必须一个空格，这也是因为_config的语法比较严谨的原因 3、GitHub有缓存时间，这是一个比较令人头疼的问题，自己在_config设置完所有的参数之后，然后执行hexo g、hexo d.然后是过了几分钟之后自己打开了自己博客，发现竟然返回了404页面，当时也是比较懵逼的，然后就一直谷歌上面各种找原因。看到一个人回答说是GitHub的缓存原因。这才放心，后面等了一会儿之后设置的东西相应的显示出来了。 总结：总的来说大体常见的问题就是这些。在打扮博客的过程中肯定会碰到各种各样的问题，抽时间来一个大总结。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
