<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fanzhanxiang&#39; Blog</title>
  
  <subtitle>勿忘初心、方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/"/>
  <updated>2017-11-05T02:45:03.810Z</updated>
  <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/</id>
  
  <author>
    <name>范占祥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组的forEach和map方法解读</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/forEach和map方法解读/</id>
    <published>2017-11-05T02:45:03.800Z</published>
    <updated>2017-11-05T02:45:03.810Z</updated>
    
    <content type="html"><![CDATA[<p>forEach和map方法都是用来遍历数组中的每一项的;<br><a id="more"></a></p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><blockquote><pre><code>1、数组中有几项，那我们传递进去的匿名函数就需要执行几次2、每一次执行匿名函数的时候，还给其浏览器给其默认传递了三个参数值：数组中的当前项 item，当前项的索引index，原始数组input。3、理论上我们的方法是没有返回值的，仅仅遍历数组中的每一项不对原来的数据进行修改，但是我们可以通过数组的索引来修改原来的数组。</code></pre></blockquote><p>执行下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">    var ary=[12,23,34,45,43];</div><div class="line">    var res=ary.forEach(function (item,index,input) &#123;</div><div class="line">        console.log(arguments);</div><div class="line">        input[index]=item*10;</div><div class="line">    &#125;);</div><div class="line">    console.log(res);//-&gt;undefined</div><div class="line">    console.log(ary);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>控制台中返回结果如图所示:<br><img src="http://oyh928sxz.bkt.clouddn.com/forEach.png" alt=""></p><p>原因：执行了5函数，输出了5次arguments,并且函数在遍历的时候是从索引0开始依次遍历的。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的回调函数中支持return返回值，return的后面是啥，相当于把数组中的这这一项改变为啥(但是并不影响原来的数组，只是相当于把原来的数组克隆一份，把克隆的这一份数组中的对应项改变了)。</p><p>用代码表示为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">        var ary=[12,23,34,45,43];</div><div class="line">    var res=ary.map(function (item, index, input) &#123;</div><div class="line">        return item*10;</div><div class="line">    &#125;);</div><div class="line">    console.log(res);//-&gt; [120, 230, 340, 450, 430]</div><div class="line">    console.log(ary);//-&gt;[12, 23, 34, 45, 43]</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>不管是forEach还是map都支持第二个参数，第二个参数的意识是把匿名函数中的this进行修改为第二个参数值。</p><p>代码表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">     var obj=&#123;name:&quot;abc&quot;&#125;;</div><div class="line">    var ary=[12,23,34,45,43];</div><div class="line"></div><div class="line">    ary.forEach(function (item, index) &#123;</div><div class="line">        console.log(this);</div><div class="line">    &#125;);</div><div class="line">    ary.forEach(function (item, index) &#123;</div><div class="line">        console.log(this);</div><div class="line">    &#125;,obj);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>在控制台中输出的结果如图所示:</p><p><img src="http://oyh928sxz.bkt.clouddn.com/map%E6%88%96forEach%E4%B8%AD%E7%9A%84this%E9%97%AE%E9%A2%98.png" alt=""></p><p>证实了上面的结论。</p><blockquote><pre><code>不管是forEach还是map在IE6-8下都不兼容</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;forEach和map方法都是用来遍历数组中的每一项的;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的同步和异步编程</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/JS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/JS的同步和异步编程/</id>
    <published>2017-11-05T01:28:49.752Z</published>
    <updated>2017-11-05T01:30:59.997Z</updated>
    
    <content type="html"><![CDATA[<p>JS中的两种编程思想：同步、异步。<br><a id="more"></a></p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步编程:上一件事情没有完成，继续做上一件事情，只有上一件事情完成了，才会做下一件事情(JS大部分都是同步编程的)。如下面代码：（1）、（2）分别代表第一次和第二次输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">for(var i=0;i&lt;100000;i++)&#123;</div><div class="line">      if(i===99999)&#123;</div><div class="line">           console.log(&quot;循环结束了~~&quot;)//-&gt;(1)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(&quot;ok&quot;);//-&gt;(2)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:for循环就是同步编程的，只有循环结束后，才会执行下面的代码,因此会先输出前面的，再输出后面的。</p><p>再比如下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">while (1)&#123;</div><div class="line"></div><div class="line"> &#125;</div><div class="line">    console.log(&quot;ok&quot;);//-&gt;不会有结果输出，并且浏览器还会崩溃</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:因为上面的循环是死循环，循环永远不会结束,JS不会跳过上面那段循环来执行下面的循环。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>解读：首先规划要做一件事情，但是不是立马去执行这件事情，需要等一定的时间，这样的话我们不会继续等着它执行，而是继续执行下面的操作，”只有下面的事情都处理完成了”.只有当下面的事情都处理完成了，才会返回头处理之前的事情；如果下面的事情没有处理完成，不管之前的事情有没有处理完成，都踏踏实实的给我等着。在JS中异步编程只有四种情况：定时器都是异步编程的、所有事件绑定都是异步编程的、AJAX读取数据的时候，我们一般设定为异步编程、回调函数也是异步编程的。</p><p>比如下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">var n=0;</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">          n++;</div><div class="line">          console.log(n);//-&gt;1(2)</div><div class="line">       &#125;,1000);</div><div class="line">       console.log(n);//-&gt;0(1)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:定时器是异步编程的，在1000ms之后再执行定时器中的方法，因此会先输出0，再输出1。</p><p><strong>关于浏览器的最小等待事件问题</strong></p><p>比如下面的这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">var n=0;</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">        n++;</div><div class="line">        console.log(n);//-&gt;1(2)</div><div class="line">    &#125;,0);</div><div class="line">    console.log(n);//-&gt;0(1)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:每一个浏览器对于定时器的等待时间都有一个最小值：谷歌大概:5~6ms,IE大概:13~14ms,如果设置的等待时间小于这个值，不起作用，还是需要等到最小时间才执行；尤其是写0也不是立即执行；</p><p><strong>定时器设置的等待时间不一定就是最后执行的时间</strong></p><p>看下面的这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">    var n=0;</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">        n++;</div><div class="line">        console.log(n);//-&gt;不执行</div><div class="line">    &#125;,0);</div><div class="line">    console.log(n);//-&gt;0(1)</div><div class="line"></div><div class="line">    while (1)&#123;</div><div class="line">        n++;//-&gt;死循环</div><div class="line">    &#125;</div><div class="line">    console.log(n);//-&gt;不执行</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:执行到while的时候出现了死循环，因此定时器里面的方法永远不会执行。</p><p><strong>定时器是谁先到先执行谁</strong></p><p>如下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">       var n=0;</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">        n+=2;</div><div class="line">        console.log(n);//-&gt;7(4)</div><div class="line">    &#125;,20);</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">        n+=5;</div><div class="line">        console.log(n);//-&gt;5(3)</div><div class="line">    &#125;,5);</div><div class="line">    console.log(n);//-&gt;0(1)</div><div class="line">    for(var i=0;i&lt;10000000;i++)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    console.log(n);//-&gt;0(2)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因：JS在执行的时候会有一个类似于设置闹钟的那种机制的任务队列，不是之前设置的闹钟就之前叫，而是不管是什么时候设置的，谁的时间先到了就谁先叫。如图所示。</p><p><img src="http://oyh928sxz.bkt.clouddn.com/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.png" alt=""></p><blockquote><pre><code>上面仅仅是讲了定时器这一种异步编程思想，所有事件绑定、AJAX读取数据的时候、回调函数这几种的原理也和定时器的一样</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS中的两种编程思想：同步、异步。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据类型检测的四种方式</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/JavaScript%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%98%AF%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/JavaScript中数据类型检测是四种方式/</id>
    <published>2017-11-04T12:09:27.663Z</published>
    <updated>2017-11-05T01:02:17.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、typeof-用来检测数据类型的运算符"><a href="#一、typeof-用来检测数据类型的运算符" class="headerlink" title="一、typeof 用来检测数据类型的运算符"></a>一、typeof 用来检测数据类型的运算符</h2><p>使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串包含了对应的数据类型，例<br><a id="more"></a><br>如:’number’、’string’、’boolean’、’undefined’、’function’、’object’。<br><strong>局限性</strong>：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeof null-&gt;&quot;object&quot;</div></pre></td></tr></table></figure><p>不能具体细分是数组还是正则，还是对象中其他的值，因为使用typeof检测数据类型，对于对象数据类型中的左右的值，最后返回的结果都是”object”</p><h2 id="二、instanceof-检测某一个实例是否属于这个类"><a href="#二、instanceof-检测某一个实例是否属于这个类" class="headerlink" title="二、instanceof 检测某一个实例是否属于这个类"></a>二、instanceof 检测某一个实例是否属于这个类</h2><p>优点：它可以用来检测是数组还是正则了。<br>局限性：对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定的区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这类的实例，对于字面量创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散型，导致了可以使用JS原型上的方法。如下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">console.log(1 instanceof Number);//-&gt;控制台输出false     </div><div class="line">console.log(new Number(1) instanceof Number);//-&gt;控制台输出true  </div><div class="line"> var ary=[];  </div><div class="line">   function fn() &#123;</div><div class="line">       </div><div class="line">   &#125;  </div><div class="line">   console.log(ary instanceof Array)//-&gt;控制台输出true  </div><div class="line">   console.log(ary instanceof Object)//-&gt;控制台输出true  </div><div class="line">   console.log(fn instanceof Function)//-&gt;控制台输出true  </div><div class="line">   console.log(ary instanceof Object)//-&gt;控制台输出true</div></pre></td></tr></table></figure><p>因此，它会产生以下影响：</p><blockquote><pre><code>1、不能用来检测和处理字面量方式创建出来的基本数据类型值。2、instanceof的特性：只要在当前实例的原型链上，我们用其检测出来的结果都是true。3、在类的原型继承中，我们最后检测出来的结果未必准确。只要它的原型链上有这个类，最后用这方法检测出来的结果都是true。</code></pre></blockquote><h2 id="三、constructor-构造函数-作用和instanceof非常相似"><a href="#三、constructor-构造函数-作用和instanceof非常相似" class="headerlink" title="三、constructor: 构造函数 作用和instanceof非常相似"></a>三、constructor: 构造函数 作用和instanceof非常相似</h2><p>有如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj=[],num=1，reg=/^$/;   </div><div class="line">console.log(obj.constructor===Array);//-&gt;true  </div><div class="line">console.log(obj.constructor===RegExp);//-&gt;false  </div><div class="line">console.log(num.constructor===Number);//-&gt;true  </div><div class="line">console.log(reg.constructor===RegExp);//-&gt;true  </div><div class="line">console.log(reg.constructor===Object);//-&gt;false</div></pre></td></tr></table></figure></p><p>优点:可以看出和instanceof相比，constructor可以处理基本数据类型的检测。<br>不同:constructor和instanceof不一样的地方在于，constructor在检测的时候先在私有属性上找，找到之后就不会往后面找了，所以在用来检测Object的时候，一般情况下是检测不了的。<br>局限性：我们可以把类的原型进行重写，在进行的重写过程中，很有可能之前contructor给覆盖掉了，这样检测出来的结果就是不准确的。</p><blockquote><pre><code>扩展：对于特殊的数据类型null和undefined,他们的所属类是Null和Undefined,但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。</code></pre></blockquote><h2 id="四、Object-prototype-toString-call"><a href="#四、Object-prototype-toString-call" class="headerlink" title="四、Object.prototype.toString.call()"></a>四、Object.prototype.toString.call()</h2><p>这是最准确检测数据类型的方法；</p><p>解读：首先获取Object原型上toString方法，让方法执行，并且改变方法中的this关键字的指向。先看一下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot;</div><div class="line">console.log((128).toString(2/8/10));-&gt;把数字转化为二进制/八进制/十进制，Number原型上的toString方法支持把数字转化为相的进制。  </div><div class="line">console.log((1).__proto__.__proto__.toString());//-&gt;&quot;[object Object]&quot;  </div><div class="line">console.log(&quot;zhufeng&quot;.toString());//-&gt;也是转为为字符串，但是不支持进制  </div><div class="line">console.log(&#123;&quot;name&quot;: &quot;abc&quot;&#125;.toString());//-&gt;&quot;[object Object]&quot;  </div><div class="line">console.log(Math.toString())//-&gt;&quot;[object Math]&quot;</div></pre></td></tr></table></figure><p>通常情况下对toString的理解：</p><blockquote><pre><code>对于Number、String、Boolean、Array、RegExp、Date、Function原型上的toString()方法都是把当前的数据类型转换为字符串类型（他们的作用仅仅是用来转换为字符串Object.prototype.toString并不是用来转换为字符串的。Object.prototype.toString它的作用是返回当前方法的执行主体（方法中this）所属类的详细信息。var obj={name:&quot;xyz&quot;};//-&gt;&quot;[object Object]&quot;console.log(obj.toString());//-&gt;toString中的this是obj,返回的是obj所属类的信息-&quot;[object Object]&quot;第一个object代表当前实例是对象数据类型的(这个是固定)，第二个Object,代表的是obj是object这个类的一个实例。</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var ary=[];   </div><div class="line"> console.log(Object.prototype.toString.call(ary));//-&gt;&quot;[object Array]&quot;;   </div><div class="line"> console.log(Object.prototype.toString.call(/^$/));//-&gt;&quot;[object RegExp]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(1));//-&gt;&quot;[object Number]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(&quot;dsas&quot;));//-&gt;&quot;[object String]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(true));//-&gt;&quot;[object Boolean]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(null));//-&gt;&quot;[object Null]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(undefined));//-&gt;&quot;[object Undefined]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(function () &#123;&#125;));//-&gt;&quot;[object Function]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(new Date));//-&gt;&quot;[object Date]&quot;;  </div><div class="line"> console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot;</div></pre></td></tr></table></figure><blockquote><pre><code>从上面代码可以总结春：Object.prototype.toString并不是用来转换为字符串的，返回的是obj所属类的信息息-&quot;[object &quot;参数2&quot;]&quot;第一个object代表当前实例是对象数据类型的(这个是固定)，第二个参数，“参数2”,代表的是检测的这个所属的类。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、typeof-用来检测数据类型的运算符&quot;&gt;&lt;a href=&quot;#一、typeof-用来检测数据类型的运算符&quot; class=&quot;headerlink&quot; title=&quot;一、typeof 用来检测数据类型的运算符&quot;&gt;&lt;/a&gt;一、typeof 用来检测数据类型的运算符&lt;/h2&gt;&lt;p&gt;使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串包含了对应的数据类型，例&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中检测兼容的三种方式</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/JS%E6%A3%80%E6%B5%8B%E5%85%BC%E5%AE%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/JS检测兼容的三种方式/</id>
    <published>2017-11-04T11:57:38.077Z</published>
    <updated>2017-11-04T12:10:53.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、使用try、catch来处理兼容"><a href="#一、使用try、catch来处理兼容" class="headerlink" title="一、使用try、catch来处理兼容"></a>一、使用try、catch来处理兼容</h2><p>前提：必须保证try中的代码在不兼容浏览器中执行的时候报错，这样的话我们才可以用catch捕获到异常的信息，进行其它的处理，示例代码如下面所示。<br>缺点：不管是什么浏览器，都需要把try中的代码都需要把try中的代码执行一遍，如果当前是IE7。window.getComputedStyle本身是不兼容的，但是我们也要把它先执行一遍，报错了再把curEle.currentStyle执行一遍（消耗性能），因此使用try处理兼容只有在万不得已的情况下才使用它。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;</div><div class="line">    function getCss(curEle,attr) &#123;//-&gt;curEle指的是操作的元素，attr指的是元素属性</div><div class="line">        var val=null;</div><div class="line">        try&#123;</div><div class="line">            val=window.getComputedStyle(curEle,null)[attr];</div><div class="line">        &#125;catch(e)&#123;</div><div class="line">            val=curEle.currentStyle[attr];</div><div class="line">        &#125;</div><div class="line">        return val;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="二、判断当期浏览器中是否存在这个属性和方法"><a href="#二、判断当期浏览器中是否存在这个属性和方法" class="headerlink" title="二、判断当期浏览器中是否存在这个属性和方法"></a>二、判断当期浏览器中是否存在这个属性和方法</h2><p>判断当期浏览器中是否存在这个属性和方法，存在就兼容，不存在就不兼容。代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;</div><div class="line">    function getCss(curEle,attr) &#123;</div><div class="line">        var val = null;</div><div class="line">        if (getComputedStyle in window) &#123;//-&gt;如果返回结果是true，说明Window下有getComputedStyle，代表兼容</div><div class="line">            val = window.getComputedStyle(curEle, null)[attr];</div><div class="line">        &#125; else &#123;</div><div class="line">            val = curEle.currentStyle[attr];</div><div class="line">        &#125;</div><div class="line">        return val;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="三、通过检测浏览器版本和类型来处理兼容"><a href="#三、通过检测浏览器版本和类型来处理兼容" class="headerlink" title="三、通过检测浏览器版本和类型来处理兼容"></a>三、通过检测浏览器版本和类型来处理兼容</h2><p>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;</div><div class="line">    function getCss(curEle,attr) &#123;</div><div class="line">        var val = null;</div><div class="line">        if (/MSIE(6|7|8)/.test(navigator.userAgent)) &#123;//-&gt;说明是IE6-8浏览器</div><div class="line">            val = curEle.currentStyle[attr];</div><div class="line">        &#125; else &#123;</div><div class="line">            val = window.getComputedStyle(curEle, null)[attr];</div><div class="line">        &#125;</div><div class="line">        return val;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、使用try、catch来处理兼容&quot;&gt;&lt;a href=&quot;#一、使用try、catch来处理兼容&quot; class=&quot;headerlink&quot; title=&quot;一、使用try、catch来处理兼容&quot;&gt;&lt;/a&gt;一、使用try、catch来处理兼容&lt;/h2&gt;&lt;p&gt;前提：必须保证try中的代码在不兼容浏览器中执行的时候报错，这样的话我们才可以用catch捕获到异常的信息，进行其它的处理，示例代码如下面所示。&lt;br&gt;缺点：不管是什么浏览器，都需要把try中的代码都需要把try中的代码执行一遍，如果当前是IE7。window.getComputedStyle本身是不兼容的，但是我们也要把它先执行一遍，报错了再把curEle.currentStyle执行一遍（消耗性能），因此使用try处理兼容只有在万不得已的情况下才使用它。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中常用的六种继承方式</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/常用的六种继承方式/</id>
    <published>2017-11-04T06:05:20.860Z</published>
    <updated>2017-11-04T12:21:14.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><p><strong>可枚举和不可枚举</strong>：<br>我们在JavaScript中使用for..in遍历对象的时候，会发现下面的情况：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;;</div><div class="line">    Object.prototype.aaa = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    for(var key in obj)&#123;</div><div class="line">console.log(key)</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>最后在谷歌的控制台中会输出:</p><blockquote><pre><code>nameageaaa</code></pre></blockquote><p>这说明在使用for..in 遍历对象的时候默认会把自己私有的和它所属类的原型上扩展的属性和方法都可以遍历到，但是一般情况下，我们遍历对象只需要遍历私有的即可，我们可以使用以下的判断进行处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;;</div><div class="line">    Object.prototype.aaa = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    for(var key in obj)&#123;</div><div class="line">             if(obj.propertyIsEnumerable(key))&#123;</div><div class="line">console.log(key)</div><div class="line">             &#125;</div><div class="line">     &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false，下面为大家介绍下其具体的使用：propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false</p><blockquote><pre><code>1、这个属性必须属于实例的,并且不属于原型. 2、这个属性必须是可枚举的,也就是自定义的属性,可以通过for..in循环出来的</code></pre></blockquote><p>只有符合上面这两个要求，才会返回true。因为在使用for…in遍历对象对象的时候，在前面加一个这个方法来判断一下，原型上的自己定义的属性就不会被遍历出来了。</p><p>也可以用下面的方法来只遍历出对象中的私有属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;;</div><div class="line">    Object.prototype.aaa = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    for(var key in obj)&#123;</div><div class="line">             if(obj.hasOwnProperty(key))&#123;</div><div class="line">console.log(key)</div><div class="line">             &#125;</div><div class="line">     &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。只遍历出私有私有属性，而不会遍历出原型链上的属性。</p><p>加上这两个判断之后，控制台中会输出同样的结果，结果是：</p><blockquote><pre><code>nameage</code></pre></blockquote><p><strong>Object.create(proObj)</strong>:创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6-8不兼容（ECMAScript5），用下面的代码解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var obj = &#123;</div><div class="line">        getX: function () &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    var obj2 = Object.create(obj);</div><div class="line">    obj.getY = function () &#123;</div><div class="line">        console.log(2)</div><div class="line">    &#125;;</div><div class="line">    obj2.getY();</div><div class="line">    console.log(obj2);</div><div class="line">    console.log(obj);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>最谷歌控制台中输出的结果如图所示:<br><img src="http://oyh928sxz.bkt.clouddn.com/Object.create%28%29.png" alt=""><br>2是执行 obj2.getY();输出的结果，中间的这个是obj2，最后这个是obj，可以看出，通过执行Object.create(obj)这个方法，创建出来了obj2这个对象，并且把，并且还把obj作为这个对象的原型。可以看出，在obj2和Object这个基类之间多了一个原型链。而这一级的对象就是obj。</p><p><strong>原型继承</strong></p><blockquote><p>   1、 原型继承是”JS”中最常用的一种继承方式,子类B想要继承父类A中的所有的属性和方法（私有<br>   +公有），只需要让B.prototype=new A,即可。<br>   2、 原型继承的特点：它是把父类私有的+公有的都继承到了子类的原型上（子类公有的）;<br>   3、核心:原型链继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是B和A之间增加了原型链的链接看，以后B的实例n想要用A中的getX方法，需要一级级的查找来使用。代码就这样表示</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    function B()&#123;</div><div class="line">        this.y=200;</div><div class="line">    &#125;</div><div class="line">    B.prototype=new A;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="二、call继承"><a href="#二、call继承" class="headerlink" title="二、call继承"></a>二、call继承</h2><p>call继承的最终结果是把父类私有的属性和方法克隆一份一模一样的，作为子类私有的属性和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    A.prototype.getX=function()&#123;</div><div class="line">        console.log(this.x);</div><div class="line">    &#125;;</div><div class="line">    function B()&#123;</div><div class="line">         A.call(this);</div><div class="line">    &#125;</div><div class="line">    var n=new B;</div><div class="line">    console.log(n.x);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>最后在控制台中最终会输出100，为什么了？new B是创建B这个类的一个实例，在函数B中的this就是这个实例，这里表示的就是n,A.call(this)指的是把函数A中的this变为函数B中的this，而new B之后函数B中的this是n，所以最后在控制台中输出的是100。</p><h2 id="三、冒充对象继承"><a href="#三、冒充对象继承" class="headerlink" title="三、冒充对象继承"></a>三、冒充对象继承</h2><p>冒充对象继承：把父类私有的+公有的克隆一份一模一样给子类私有的。代码用下面的来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    A.prototype.getX=function()&#123;</div><div class="line">        console.log(this.x);</div><div class="line">    &#125;;</div><div class="line">    function B() &#123;</div><div class="line">        var temp=new A;</div><div class="line">        for(var key in temp)&#123;</div><div class="line">            this[key]=temp[key];</div><div class="line">        &#125;</div><div class="line">        temp=null;</div><div class="line">    &#125;</div><div class="line">    var n=new B;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="四、混合模式继承"><a href="#四、混合模式继承" class="headerlink" title="四、混合模式继承"></a>四、混合模式继承</h2><p>混合模式继承：指的是原型继承+call继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    A.prototype.getX=function()&#123;</div><div class="line">        console.log(this.x);</div><div class="line">    &#125;;</div><div class="line">    function B() &#123;</div><div class="line">        A.call(this);</div><div class="line">    &#125;</div><div class="line">    B.prototype=new A;</div><div class="line">    B.prototype.constructor=B;</div><div class="line">    var n=new B;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>这种继承方式会让父类私有的和公有的都会在子类公有的上面有一份，但是在原型链查找的时候会先查找私有属性，所以也不影响整体。优点是父级私有属性都放在子类的私有上了。</p><h2 id="五、寄生组合式继承"><a href="#五、寄生组合式继承" class="headerlink" title="五、寄生组合式继承"></a>五、寄生组合式继承</h2><p>父类公有的给子类公有的，父类私有的给子类私有的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    A.prototype.getX=function()&#123;</div><div class="line">        console.log(this.x);</div><div class="line">    &#125;;</div><div class="line">    function B() &#123;</div><div class="line">        A.call(this);</div><div class="line">    &#125;</div><div class="line">    B.prototype=Object.create(A.prototype);//这句代码的含义是把B的原型的地址换成了A的原型的地址。</div><div class="line">    B.prototype.constructor=B;</div><div class="line">    var n=new B;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="六、中间类继承法-gt-IE下不兼容"><a href="#六、中间类继承法-gt-IE下不兼容" class="headerlink" title="六、中间类继承法-&gt;IE下不兼容"></a>六、中间类继承法-&gt;IE下不兼容</h2><p>这段代码是一个数组，在去掉一个最大值和最小值之后求它的平均值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function avgFn() &#123;</div><div class="line">        Array.prototype.sort.call(arguments,function (a,b) &#123;</div><div class="line">            return a-b;</div><div class="line">        &#125;);</div><div class="line">        Array.prototype.pop.call(arguments);</div><div class="line">        Array.prototype.shift.call(arguments);</div><div class="line">        return (eval(Array.prototype.join.call(arguments,&quot;+&quot;))/arguments.length).toFixed(2);</div><div class="line">    &#125;</div><div class="line">    console.log(avgFn(10,20,30,34,44))//-&gt;结果是28</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>使用中间类继承法：代码入下面所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function avgFn() &#123;</div><div class="line">       arguments.__proto__= Array.prototype;</div><div class="line">        arguments.sort(function(a,b)&#123;</div><div class="line">            return a-b;</div><div class="line">        &#125;);</div><div class="line">        arguments.pop();</div><div class="line">        arguments.shift();</div><div class="line">        return eval(arguments.join(&quot;+&quot;))/arguments.length;</div><div class="line">    &#125;</div><div class="line">    console.log(avgFn(10,20,30,34,44))//-&gt;结果是28</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>这就是直接借用原型链的机制来形成的一种继承方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、原型链继承&quot;&gt;&lt;a href=&quot;#一、原型链继承&quot; class=&quot;headerlink&quot; title=&quot;一、原型链继承&quot;&gt;&lt;/a&gt;一、原型链继承&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;可枚举和不可枚举&lt;/strong&gt;：&lt;br&gt;我们在JavaScript中使用for..in遍历对象的时候，会发现下面的情况：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JSONP</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/03/JSONP/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/03/JSONP/</id>
    <published>2017-11-03T01:32:59.320Z</published>
    <updated>2017-11-04T12:10:37.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>JSONP和AJAX相同，都是向客户端向服务器发送请求:给服务器传递数据或者从服务器端获取数据的方式。但是他们两种方式之间是有区别的：JSONP属于非同源策略（跨域请求），说明一下，实现跨越的方式有很多种，只不过JSONP是最常用的；而AJAX是属于同源策略。</p><h2 id="同源和非同源的区别"><a href="#同源和非同源的区别" class="headerlink" title="同源和非同源的区别"></a>同源和非同源的区别</h2><p>同源和非同源的区别在于用当前页面的地址于数据请求的接口地址相比较：比如<br>当前页面地址是：<strong><a href="https://www.zhihu.com/people/fanzhanxiang" target="_blank" rel="external">https://www.zhihu.com/people/fanzhanxiang</a></strong>;<br>数据请求接口的地址是：<strong><a href="https://github.com/fanzhanxiang">https://github.com/fanzhanxiang</a></strong>；判断是使用AJAX请求还是JSONP请求我们需要看以下三个方面。</p><blockquote><pre><code>1、协议2、域名3、端口号</code></pre></blockquote><p>上面三个部分完全相同属于同源策略，我们使用AJAX获取数据；只要有一个不一样的，就属于非同源，我们一般使用JSONP来获取数据。就比如上面这两个地址，他们的协议（https和https）、域名（www.zhihu.com和github.com）、端口号（443和443）端口号和域名不一样，因此想要在当前页面中获取这个数据请求的地址需要使用非同源策略。</p><h2 id="JSONP的原理"><a href="#JSONP的原理" class="headerlink" title="JSONP的原理"></a>JSONP的原理</h2><p>JSOPN是利用在JavaScript中的script标签的特性，在script的世界中，没有跨域同源一说，只要你给它的SRC属性中的地址是一个合法的地址，script都可以把对应的内容请求回来。</p><p><strong>JSONP就是利用了这个原理(JSONP请求一定需要对方的服务器做支持才可以)</strong>：</p><blockquote><pre><code>1、我们首先把需要请求数据的那个API数据接口的地址，赋值给script的SRC2、把当前页面中的某一个函数名当做参数值传递给需要跨域请求数据的服务器（URL问号传参一般都是这么写:canllback=fn）3、服务器接到你的请求之后，需要进行特殊的处理：把你传递进来的函数名和他需要给你的数据拼接成一个字符串，例如：我们传递进去的函数名是fn，它准备好的数据是&apos;fn(需要给我们的数据)&apos;；4、最后服务器把准备的数据通过HTTP协议返回给客户端，其实就是让我们的fn执行，而且还给fn传递了一堆数据，那些数据就是我们想要的；</code></pre></blockquote><p>比如下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;  </div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">    function fn(data)&#123;  </div><div class="line">        console.log(data);  </div><div class="line">   &#125;  </div><div class="line">&lt;/script&gt;  </div><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;http://  </div><div class="line">matchweb.sports.qq.com/kbs/calendar?columnId=100000&amp;callback=fn&quot;&gt;    </div><div class="line">&lt;/script&gt;  </div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure><p>在谷歌控制台中的输出入下图所示：<img src="http://oyh928sxz.bkt.clouddn.com/JSONP.png" alt="JSONP"></p><h2 id="jQuery的AJAX和JSONP调用"><a href="#jQuery的AJAX和JSONP调用" class="headerlink" title="jQuery的AJAX和JSONP调用"></a>jQuery的AJAX和JSONP调用</h2><p><strong>AJAX请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        $.ajax(&#123;</div><div class="line">            url:&quot;地址&quot;,</div><div class="line">            type:&quot;请求方式&quot;,</div><div class="line">            dataType:&quot;json&quot;,</div><div class="line">            data:null,//-&gt;使用post请求是非服务器传递的内容</div><div class="line">            async:true,//-&gt;同步还是异步，默认是异步</div><div class="line">            cache:false,//设定GET请求的时候不走缓存数据，原理其实就是在URL末尾加随机数，默认值是true</div><div class="line">            timeout:1000,//设置超时时间 一般都设定3000ms，超过时间之后就跑到error</div><div class="line">            success:function(data)&#123;//-&gt;data是请求回来的数据</div><div class="line">                console.log(data);</div><div class="line">            &#125;,</div><div class="line">            error:function()&#123;&#125;,//请求失败的时候执行这个</div><div class="line">        &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p><strong>JSONP请求</strong><br>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，而且jQuery会默认就会给JSONP的请求清除缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.2.1.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">      $.ajax(&#123;</div><div class="line">        url: &quot;请求地址&quot;,</div><div class="line">        dataType: &quot;jsonp&quot;,</div><div class="line">        jsonpCallback: &quot;fn&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的</div><div class="line">        jsonp:&quot;cb&quot;,//-&gt;把传递函数名的那个形参callback变为cb</div><div class="line">        success: function (data) &#123;</div><div class="line">            console.log(data);</div><div class="line">        &#125;</div><div class="line">    &#125;);  </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;JSONP和AJAX相同，都是向客户端向服务器发送请求:给服务器传递数据或者从服务器端获取数据的方式。但是他们两种方式之间是有区别的：JSO
      
    
    </summary>
    
      <category term="JSONP" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JSONP/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/31/ajax/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/31/ajax/</id>
    <published>2017-10-31T09:32:52.925Z</published>
    <updated>2017-11-04T12:10:07.168Z</updated>
    
    <content type="html"><![CDATA[<p>Ajax:async javascript and xml 叫做异步的JS和XML(可扩展标记语言)，它是一种客户端的JS方法，用来向服务器端发送请求(还可以传递给服务器数据)，然后把服务器端返回的内容获取到，它一般运行在客户端的浏览器中的。</p><h2 id="Ajax的四个步骤"><a href="#Ajax的四个步骤" class="headerlink" title="Ajax的四个步骤"></a>Ajax的四个步骤</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1、var xhr=new XMLHttpRequest;   </div><div class="line">2、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]);  </div><div class="line">3、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text  (xhr.status))&#123;var val=xhr.responseText&#125;  &#125;;  </div><div class="line">4、xhr.send(&quot;要传递给服务器的内容&quot;);</div></pre></td></tr></table></figure><h2 id="1、第一步"><a href="#1、第一步" class="headerlink" title="1、第一步"></a>1、第一步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1、var xhr=new XMLHttpRequest;</div></pre></td></tr></table></figure><p>创建一个AJAX对象（在IE6及更低版本的浏览器中不兼容）</p><h2 id="2、第二步"><a href="#2、第二步" class="headerlink" title="2、第二步"></a>2、第二步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2、xhr.open(&quot;请求方式&quot;,&quot;请求资源的地址&quot;,&quot;同步还是一异步（同步用false，异步用true）&quot;,[username],[userpass]);</div></pre></td></tr></table></figure><p>发送前的基本信息配置：配置请求方式，请求方式有GET、POST、PUT、DELETE、HEAD，上面是几种方式不管是哪一种都可以向服务器传递数据，也可以从服务器获取到数据，而且从本质意义上来讲上面几种请求方式是没有什么区别的，例如用POST做的事情用GET也能做。以下区别都是开发者约定俗成的规范；</p><blockquote><pre><code>1、GET：一般应用于从服务器获取数据（给服务器的少，从服务器拿的数据多），使用GET请求给服务器传递内容，我们一般都使用&quot;URL问号传参的方式&quot;；例如：xhr.open(&quot;get&quot;,&quot;/getList?num=2&quot;),但是这种方式传递的内容存在大小限制；因为GET通过URL传参给服务器，而每个浏览器对于URL的长度存在限制，谷歌8kb、火狐7kb、IE2kb的长度限制，如果URL的长度超过限制，浏览器会把超出的部分的截取。并且这个请求会出现缓存（这个缓存不一定304）。在项目中我们的GET请求一般不会让其出现缓存，因此要清除缓存，清除GET请求缓存的方法是在URL的末尾加一个随机数xhr.open(&quot;get&quot;,&quot;/getList?num =2&amp;_=&quot;+Math.random());在用get请求的时候与post相比，是不安全的2、POST：一般应用于向服务器推送数据（给服务器的多，从服务器上拿的少），我们一般使用&quot;请求主体的方式&quot;传递给服务器，例如：xhr.open(&quot;post&quot;,&quot;/getList&quot;);xhr.send(&apos;{&quot;name&quot;:&quot;zhufeng&quot;,&quot;age&quot;:7&apos;)，这种传递方式理论上是没有大小限制的，并且这个请求是没有缓存的。3、PUT：一般应用于给服务器上传资源文件（我们上传图片功能）4、DELETE：一般应用于从服务器上删除资源文件5、HEAD：一般应用于只获取服务器的响应头信息</code></pre></blockquote><p>第三个参数默认是异步；username:向服务器提供的用户名,userpass:向服务器提供的用户密码，这两个值一般都不写，只有服务器做了安全限制，只允许特定的用户访问，我们才传递过去。</p><h2 id="3、第三步"><a href="#3、第三步" class="headerlink" title="3、第三步"></a>3、第三步</h2><p>这一步不是必须的，如果自己不要拿回数据的话，就可以不需要执行这步，那么ajax只需要三步就可以完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3、xhr.onreadyStatechange=function()&#123;if(xhr.readyState===4 &amp;&amp; /^2\d&#123;2&#125;.text(xhr.status))&#123;var val=xhr.responseText&#125;&#125;;</div></pre></td></tr></table></figure></p><p>给<strong>onreadyStatechange</strong>这个事件绑定一个方法，监听状态的改变(只要状态改变，就会触发这个事件绑定的相应方法执行)；</p><p><strong>xhr.readyState</strong>：AJAX状态码其中有5个值（0,1,2,3,4），可以代表当前AJAX处理的进度。</p><blockquote><pre><code>0：&quot;unset&quot;，表示当前的请求还没有发送；1：&quot;opened&quot;,表示URL地址已经打开(发送前的参数配置已经完成)；2：&quot;headers_received&quot;,表示响应头信息已经接收；3：&quot;loading&quot;,主要返回的内容正在服务器端进行准备处理；4：&quot;done&quot;:响应主体的内容已经成功返回客户端。</code></pre></blockquote><p><strong>xhr.status</strong>:HTTP网络状态码，描述了服务器响应内容的状态，HTTP网络状态码有如下几种：</p><blockquote><pre><code>200 OR ^2\d{2}： (200或者以2开头的)都代表响应主体的内容已经成功返回了301：永久重定向/永久转移302：临时重定向/临时转移,服务器的负载均衡304：本次获取的内容是读取缓存中的数据400:客户端传递给服务器端的参数出现错误，客户端传递的参数有问题401：无权限访问404：访问的地址不存在500：未知的服务器错误503：服务器已经超负荷了，比如能承受10000人，那么第10001个人访问，如果没有做服务器的负载均衡（302），那么这个人的状态码就是503;</code></pre></blockquote><h2 id="4、第四步"><a href="#4、第四步" class="headerlink" title="4、第四步"></a>4、第四步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4、xhr.send(&quot;要传递给服务器的内容&quot;);</div></pre></td></tr></table></figure><p>发送请求：参数是请求主体中给传递给服务器的内容；只有执行完第四步之后才开始一个AJAX请求。</p><h2 id="补充：AJAX中的同步和异步"><a href="#补充：AJAX中的同步和异步" class="headerlink" title="补充：AJAX中的同步和异步"></a>补充：AJAX中的同步和异步</h2><p><strong>AJAX中的同步</strong>：当AJAX任务开始的时候(XHR.SEND),一直需要到READYSTATE===4的时候任务才结束，此时才可以处理其它的事情。并且只有当其它的任务完成后，我们再看是否到4，到4之后做一些相关的操作。</p><p><strong>AJAX中的异步</strong>：当AJAX任务开始的时候(XHR.SEND),不需要到READYSTATE===4，我依然可以处理其它的事情。</p><p><strong>下面是几个同步编程和异步编程的几个编程题</strong></p><p>1、问：下面的会在控制台输出几次，输出的分别是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var xhr=new XMLHttpRequest;   </div><div class="line">xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true);  </div><div class="line">xhr.onreadyStatechange=function()&#123;</div><div class="line">console.log(xhr.readyState);  </div><div class="line">&#125;;  </div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure><p>答案：会输出三次，分别是2、3、4<br>原因：因为第三个参数是true，所以这里是异步编程，所以绑定了xhr.onreadyStatechange这个事件一个方法，只要AJAX状态码发生改变，就会执行对应的这个事件绑定的对应方法。因为在open之后AJAX状态码已经变为了，所以当由1变到2的过程中，就会触发这个事件，对应后面从2到3,3到4也是这个原理，所以最终会输出三次，值分别：2、3、4</p><p>2、问：下面的会在控制台输出几次，输出的分别是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var xhr=new XMLHttpRequest;   </div><div class="line">xhr.onreadyStatechange=function()&#123;</div><div class="line">console.log(xhr.readyState);  </div><div class="line">&#125;;  </div><div class="line">xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true);  </div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure><p>答案：会输出四次，分别是1、2、3、4。<br>原因：因为这里open之前就已经绑定了这个方法，所以AJAX状态码从0变到了的过程中就会触发这个方法，所以会输出1；</p><p>3、问：下面的会在控制台输出几次，输出的分别是什么？</p><pre><code>var xhr=new XMLHttpRequest;    xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.onreadyStatechange=function(){  console.log(xhr.readyState);  };  xhr.send(null);</code></pre><p>答案：会输出一次，是4。<br>原因：代码上到下执行，当AJAX状态码为1的时候为onreadyStatechange这个事件绑定了一个方法，然后当任务执行完成之后，AJAX状态码变为4，触发这个事件，输出4。</p><p>4、问：下面的会在控制台输出几次，输出的分别是什么？</p><pre><code>var xhr=new XMLHttpRequest;    xhr.open(&quot;get&quot;,&quot;note.txt&quot;,true); xhr.send(null);  xhr.onreadyStatechange=function(){  console.log(xhr.readyState);  };</code></pre><p>答案：会输出3次，分别是2、3、4</p><p>5、问：下面的会在控制台输出几次，输出的分别是什么？</p><pre><code>var xhr=new XMLHttpRequest;    xhr.open(&quot;get&quot;,&quot;note.txt&quot;,false); xhr.send(null);  xhr.onreadyStatechange=function(){  console.log(xhr.readyState);  };</code></pre><p>答案：0次，什么都不输出<br>原因：采用同步编程，在AJAX状态码变为4之前，什么都不做，而且在这之前也没有绑定xhr.onreadyStatechange事件，所以在这之前什么都不会做。也没有记录对应的AJAX状态码状态码值，在AJAX状态码变为4之后，绑定了一个事件，但是后面AJAX状态码不会变了，因此永远不会触发事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ajax:async javascript and xml 叫做异步的JS和XML(可扩展标记语言)，它是一种客户端的JS方法，用来向服务器端发送请求(还可以传递给服务器数据)，然后把服务器端返回的内容获取到，它一般运行在客户端的浏览器中的。&lt;/p&gt;
&lt;h2 id=&quot;Ajax的四个步骤&quot;&gt;&lt;a href=&quot;#Ajax的四个步骤&quot; class=&quot;headerlink&quot; title=&quot;Ajax的四个步骤&quot;&gt;&lt;/a&gt;Ajax的四个步骤&lt;/h2&gt;
    
    </summary>
    
      <category term="Ajax" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Ajax/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DOM0级事件绑定和DOM2级事件及其扩展</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/27/DOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/27/DOM2级事件/</id>
    <published>2017-10-27T08:06:22.139Z</published>
    <updated>2017-11-04T12:18:14.639Z</updated>
    
    <content type="html"><![CDATA[<p> 在页面上写一个id为box的一个div，然后设置一些它的宽度和高度，然后在后面在做事件绑定的时使用。先是使用DOM0级事件绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">box.onclick=function()&#123;console.log(1)&#125;;  </div><div class="line">box.onclick=function()&#123;console.log(2)&#125;;</div></pre></td></tr></table></figure><p> 后面这个事件会把前一个事件给覆盖掉，最后在控制台中只会输出一个2.因为在使用DOM0级事件绑定的时候，<strong>只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉</strong>（这里主要是某一个行为绑定一次方法，不同的行为是可以绑定同一个方法的，比如这里是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box.onclick=function()&#123;console.log(2)&#125;;</div></pre></td></tr></table></figure></p><p>这里是可以输出2的）；所以最后在控制台只能输出一次2。DOM0级事件绑定和DOM2级事件绑定最大的区别也是在这里，但是DOM2级事件中也有一些其他特别的地方。<br><a id="more"></a></p><h2 id="1、基础；"><a href="#1、基础；" class="headerlink" title="1、基础；"></a>1、基础；</h2><p>当我们使用DOM2级事件绑定，它的原理是让box通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现的。DOM2级事件绑定解决了DOM0级事件绑定中“只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉”这个问题，比如下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false);         </div><div class="line">box.addEventListener(&quot;click&quot;,function()&#123;console.log(1)&#125;,false);</div></pre></td></tr></table></figure><p>点击box的时候，控制台上输出了1和2，方法中的第三个参数false表示的是该事件在冒泡阶段触发。总结出DOM2级事件可以给某一个元素的同一个行为绑定多个不同的方法。</p><h2 id="2、DOM2；"><a href="#2、DOM2；" class="headerlink" title="2、DOM2；"></a>2、DOM2；</h2><p> DOMO中行为类型，我们用DOM2一样可以绑定；而且DOM2中还提供了DOM0中没有的行为类型，比如DOM2中有一个行为<strong>DOMContentLoaded</strong>（当页面中的DOM结构或者是叫HTML结构加载完成触发的行为）这个行为是DOM0中没有的。像这个事件的绑定是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;&#125;,false) ;  </div><div class="line">window.onload=function()&#123;&#125;;</div></pre></td></tr></table></figure><p>上面的两个事件绑定是有区别的，这个代表的意思是当页面中所有的资源都加载完成（图片、HTML结构、音视频…）才会执行后面的函数；并且在一个页面中只能使用一次，后面再写会把前面的覆盖掉，因为它是DOM0事件绑定，所以只能绑定一次。<br>并且在jQuery中也提供了类似的方法 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(document).ready(function()&#123;&#125;)---&gt;$(function()&#123;&#125;);</div></pre></td></tr></table></figure><p>只要也拿中的HTML结构加载完成就会执行对应的函数；并且在一个页面中可以出现多次，因为jQuery在写这个方法的时候是使用DOM2级事件绑定来写的，并且绑定的行为是DOM2中的“DOMContentLoaded”这个行为来绑定的。</p><h2 id="3、移除DOM2事件绑定："><a href="#3、移除DOM2事件绑定：" class="headerlink" title="3、移除DOM2事件绑定："></a>3、移除DOM2事件绑定：</h2><p>前面两行代码中，里面的this是box，这里并不能移除事件绑定，因为两个匿名函数是两个不同的堆内存，因此不能移除事件绑定；把匿名函数换成实名函数就可以了，比如后面两行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">box.addEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false);                                                         </div><div class="line">box.removeEventListener(&quot;click&quot;,function(e)&#123;console.log(this)&#125;,false)； </div><div class="line">function fn1()&#123;console.log(this)&#125;；  </div><div class="line">box.removeEventListener(&quot;click&quot;,fn1,false)；</div></pre></td></tr></table></figure><p>这里就可以实现移除了，并且在控制台中不会输出任何东西，因为在刚绑定的时候就已经移除了。<br>移除的时候需要保证三个参数：行为、方法、那个阶段发生，一个都不能差，因为在使用DOM2事件绑定的时候，我们一般绑定的都是实名函数，如果这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box.removeEventListener(&quot;click&quot;,fn1,true)；</div></pre></td></tr></table></figure></p><p>   就移除掉了，还会输出this；</p><h2 id="4、注意点"><a href="#4、注意点" class="headerlink" title="4、注意点"></a>4、注意点</h2><p>只能给某个元素的同一个行为绑定多个“<strong>不同</strong>”的方法（如果方法相同了，只能留一个），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function fn1()&#123;console.log(1)&#125;；  </div><div class="line">box.removeEventListener (&quot;click&quot;,fn1,false)；  </div><div class="line">box.removeEventListener(&quot;click&quot;,fn1,false)；</div></pre></td></tr></table></figure><p>在点击的时候只会输出一个1。当行为触发，会按照绑定的先后顺序依次把绑定的方法执行；执行的方法中的this是当前被绑定事件的本身。并且在绑定方法的时候，浏览器天生自带的一个东西叫事件池（也有叫程序池的），用来存储绑定的事件的。</p><p>  但是在IE6~8浏览器中不支持addEventListener/removeEventListener,如果想要实现DOM2级事件绑定只能用attachEvent,移除是使用detachEvent。  box.attachEvent(“onclick”,fn1);<br>  并且它只有两个参数，不能向addEventListener那样控制在那个阶段发生，只能在冒泡阶段发生，行为需要添加”on”,和DOM0特别类似</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在页面上写一个id为box的一个div，然后设置一些它的宽度和高度，然后在后面在做事件绑定的时使用。先是使用DOM0级事件绑定。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;box.onclick=function()&amp;#123;console.log(1)&amp;#125;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;box.onclick=function()&amp;#123;console.log(2)&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 后面这个事件会把前一个事件给覆盖掉，最后在控制台中只会输出一个2.因为在使用DOM0级事件绑定的时候，&lt;strong&gt;只能给元素的某一个行为绑定一次方法，第二次绑定会把前面的覆盖掉&lt;/strong&gt;（这里主要是某一个行为绑定一次方法，不同的行为是可以绑定同一个方法的，比如这里是&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;box.onclick=function()&amp;#123;console.log(2)&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里是可以输出2的）；所以最后在控制台只能输出一次2。DOM0级事件绑定和DOM2级事件绑定最大的区别也是在这里，但是DOM2级事件中也有一些其他特别的地方。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客的感受</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/15/%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/15/博客小总结/</id>
    <published>2017-10-15T11:00:43.144Z</published>
    <updated>2017-10-31T12:49:39.024Z</updated>
    
    <content type="html"><![CDATA[<p>今天注册了一个hexo+GitHub的一个博客。下面的是一些自己一些的感受。改天有时间写一个详细版的教程关于建立个人博客的。虽然网上已经有很多了，但是自己还是有不少想要分享的地方，下面的是最简单的几点，也是自己写的第一篇博客。</p><a id="more"></a><ul><li><p>1、<strong>_config</strong>的语法非常严谨、当你要用里面的语法的时候首先需要做的一件事情把对应地方的#去掉，如果不把你想要设置的对应的地方的#去掉，当你在执行hexo g的时候会报或者是 你设置的这个地方对应的效果没有效果。</p></li><li><p>2、<strong>_config</strong>在设置的时候，”：“后面必须一个空格，这也是因为_config的语法比较严谨的原因</p></li><li><p>3、<strong>GitHub</strong>有缓存时间，这是一个比较令人头疼的问题，自己在_config设置完所有的参数之后，然后执行hexo g、hexo d.然后是过了几分钟之后自己打开了自己博客，发现竟然返回了404页面，当时也是比较懵逼的，然后就一直谷歌上面各种找原因。看到一个人回答说是GitHub的缓存原因。这才放心，后面等了一会儿之后设置的东西相应的显示出来了。</p></li></ul><p>总结：总的来说大体常见的问题就是这些。在打扮博客的过程中肯定会碰到各种各样的问题，抽时间来一个大总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天注册了一个hexo+GitHub的一个博客。下面的是一些自己一些的感受。改天有时间写一个详细版的教程关于建立个人博客的。虽然网上已经有很多了，但是自己还是有不少想要分享的地方，下面的是最简单的几点，也是自己写的第一篇博客。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/11/hello-world/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/10/11/hello-world/</id>
    <published>2017-10-11T06:05:37.558Z</published>
    <updated>2017-10-15T11:38:38.934Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
