<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fanzhanxiang&#39; Blog</title>
  
  <subtitle>勿忘初心、方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/"/>
  <updated>2018-03-16T12:36:03.953Z</updated>
  <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/</id>
  
  <author>
    <name>范占祥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fs模块基础知识</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2018/03/16/fs%E6%A8%A1%E5%9D%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2018/03/16/fs模块基础知识/</id>
    <published>2018-03-16T05:02:16.975Z</published>
    <updated>2018-03-16T12:36:03.953Z</updated>
    
    <content type="html"><![CDATA[<p>fs模块是操作文件的模块，里面有很多种方法<br><a id="more"></a></p><h2 id="readFile和readFileSync"><a href="#readFile和readFileSync" class="headerlink" title="readFile和readFileSync"></a>readFile和readFileSync</h2><blockquote><pre><code>readFile是异步读取文件，会在readFileSync之后执行readFileSync同步读取文件</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var fs=require(&apos;fs&apos;);  //注:index.txt里面存放的是123   </div><div class="line">fs.readFile(&apos;index.txt&apos;,&apos;utf8&apos;,function(err,data)&#123;console.log(data)&#125;);//-&gt;123  </div><div class="line">var data=fs.readFileSync(&apos;index.txt&apos;);//-&gt;（不给编码的话返回的是一个buffer）   </div><div class="line">console.log(data);&lt;Buffer 31 32 33&gt;  </div><div class="line">console.log(fs.readFileSync(&apos;index.txt&apos;));//-&gt;&lt;Buffer 31 32 33&gt;</div></pre></td></tr></table></figure><blockquote><pre><code>控制台中依次输出的是&quot;&lt;Buffer 31 32 33&gt;&quot;,&quot;&lt;Buffer 31 32 33&gt;&quot;, &quot;123&quot;证明了readFileSync同步读取文件会先执行，readFile异步读取文件会后执行</code></pre></blockquote><ul><li>writeFileSync和writeFile是把内容写在文件里，用法如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(&apos;line.txt&apos;,&apos;第一行&apos;,&#123;flag:&apos;w&apos;,encoding:&apos;utf8&apos;&#125;,function (err) &#123;</div><div class="line">    console.error(err);  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><pre><code>第一个参数是写入文件路径，第个参数是写入文件的内容，第三个是可选参数，最后一个是写入之后的回调</code></pre></blockquote><ul><li>appendFile</li></ul><blockquote><pre><code>appendFile是往文件夹中加内容，用法和上面的类似</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.appendFile(&apos;line.txt&apos;,&apos;第一行&apos;,&#123;flag:&apos;w&apos;,encoding:&apos;utf8&apos;&#125;,function (err) &#123;</div><div class="line">    console.error(err);  </div><div class="line">&#125;);  //这时候文件中就有&quot;line.txt&quot;中就有&quot;第一行第二行&quot;这个内容了</div></pre></td></tr></table></figure><ul><li>writeFile和writeFileSync同时执行的时候只有writeFile起作用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fs.writeFileSync(&apos;line.txt&apos;,&apos;第一行&apos;,&#123;flag:&apos;w&apos;,encoding:&apos;utf8&apos;&#125;);   </div><div class="line">fs.writeFile(&apos;line.txt&apos;,&apos;第三行&apos;,&#123;flag:&apos;w&apos;,encoding:&apos;utf8&apos;&#125;,function (err) &#123;   </div><div class="line">    console.error(err);  </div><div class="line">    console.log(&quot;异步&quot;)  </div><div class="line">&#125;);   //最后在line.text中只能找到&quot;第三行&quot;</div></pre></td></tr></table></figure><blockquote><pre><code>openSync和readSync，这是同步的，也有异步的open和readfs.readSync(fd,buffer,offset,length,position)</code></pre></blockquote><ul><li>fd:文件描述符，每打开一个文件的时候都会给它分配一个文件描述符</li><li>buffer: 存放buffer的容器</li><li>offset:  在buffer里面的偏移量</li><li>length:  长度</li><li>position: 文件的当前读取位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var fd=fs.openSync(&apos;line.txt&apos;, &apos;r&apos;);  </div><div class="line">// var fd=fs.open(&apos;line.txt&apos;, &apos;r&apos;,function(err,fd)&#123;     </div><div class="line">//     console.log(fd);//-&gt;3  打开一个文件系统会给它分配一个索引;      </div><div class="line">// &#125;);&quot;        </div><div class="line">var buffer=new Buffer(3);      </div><div class="line">fs.readSync(fd,buffer,0,3,0);    </div><div class="line">console.log(buffer.toString()); //-&gt;&quot;第&quot;，因为一个汉字是三个字节</div></pre></td></tr></table></figure><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><blockquote><pre><code>使用read方法可将文件里面的内容分块读取</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var fs=require(&apos;fs&apos;);  </div><div class="line">var list=[];  </div><div class="line">var buffer=new Buffer(12);    </div><div class="line">fs.open(&apos;line.txt&apos;,&apos;r&apos;,function(err,fd)&#123;  </div><div class="line">    var pos=0;  </div><div class="line">    function read()&#123;   </div><div class="line">        var buffer=new Buffer(3);   </div><div class="line">        fs.read(fd,buffer,0,3,pos,function(err,bytesRead,buffer)&#123;   </div><div class="line">            pos+=bytesRead;   </div><div class="line">            console.log(bytesRead);//-&gt;依次输出了3,3,3,0,说明读取了四次   </div><div class="line">            list.push(buffer.slice(0,bytesRead));   </div><div class="line">            if(bytesRead&gt;0)   </div><div class="line">                read();else&#123;   </div><div class="line">                    var result=Buffer.concat(list);   </div><div class="line">                    console.log(result.toString());//第三行   </div><div class="line">            &#125;   </div><div class="line">        &#125;);  </div><div class="line">    &#125;   </div><div class="line">    read();   </div><div class="line">&#125;);     </div><div class="line">//这个方法就实现了每次读三个字节</div></pre></td></tr></table></figure><h2 id="fs-write"><a href="#fs-write" class="headerlink" title="fs.write"></a>fs.write</h2><blockquote><p> write方法实现了往文件中分块写入内容,用法和read方法一样，只是加了一个要写入的内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var buffer=new Buffer(&quot;你好世界&quot;);  </div><div class="line">var fs=require(&apos;fs&apos;);   </div><div class="line">fs.open(&apos;line.txt&apos;,&apos;w&apos;,function(err,fd)&#123;   </div><div class="line">    console.log(&quot;first&quot;,fd);  //first 3 </div><div class="line">    fs.write(fd,buffer,6,6,6,function(err,bytesWritten)&#123;   </div><div class="line">        //console.log(bytesWritten);  </div><div class="line">        fs.write(fd,buffer,0,6,0,function(err,bytesWritten)&#123;</div><div class="line">            //console.log(bytesWritten);   </div><div class="line">            fs.close(fd);   </div><div class="line">            fs.open(&apos;line.txt&apos;,&apos;w&apos;,function(err,fd)&#123;   </div><div class="line">                console.log(&quot;second&quot;,fd); //second 3  </div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><blockquote><pre><code>通过下面的代码看</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">console.log(process.stdin.fd);//0   </div><div class="line">console.log(process.stdout.fd);//1   </div><div class="line">console.log(process.stderr.fd); //2 </div><div class="line">var fs=require(&apos;fs&apos;);  </div><div class="line">setTimeout(function()&#123;  </div><div class="line">    var buffer=new Buffer(1);  </div><div class="line">    fs.read(0,buffer,0,1,0,function(err)&#123;  </div><div class="line">        console.log(buffer.toString());//当往控制台中输入1的时候，就会触发这个方法，就会再输出一个1  </div><div class="line">    &#125;);  </div><div class="line">&#125;,3000);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fs模块是操作文件的模块，里面有很多种方法&lt;br&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6(ES6)基础知识</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2018/03/13/ECMAScript6(ES6)%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2018/03/13/ECMAScript6(ES6)基础知识/</id>
    <published>2018-03-13T15:32:27.723Z</published>
    <updated>2018-03-14T04:51:44.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6中的let和const"><a href="#ES6中的let和const" class="headerlink" title="ES6中的let和const"></a>ES6中的let和const</h2><p><strong>1、let不存在变量提升机制</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">console.log(str);//=&gt;undefined  </div><div class="line"></div><div class="line">console.log(fn);//=&gt;fn本身  </div><div class="line"></div><div class="line">console.log(avg);//=&gt;undefined</div><div class="line"></div><div class="line">console.log(sum);//=&gt;Uncaught ReferenceError: sum is not defined</div><div class="line"></div><div class="line">console.log(num);//=&gt;Uncaught ReferenceError: num is not defined</div><div class="line"></div><div class="line">var str = &apos;123&apos;;   </div><div class="line">let num = 12;    </div><div class="line">function fn() &#123;&#125;   </div><div class="line">var avg = function () &#123;&#125;;   </div><div class="line">let sum = function () &#123;&#125;;   </div><div class="line">//=&gt;ES6中只提供了创建变量的新语法标准（let），创建函数还是沿用ES5中的function（还会存在变量提升），如果想让函数也不存在变量提升，都使用函数表达式赋值的方式操作：</div><div class="line">let FN=function()&#123;&#125;//=&gt;创建函数     </div><div class="line">let xxx=xxx;//=&gt;创建变量    </div><div class="line">(function()&#123;   </div><div class="line">&#125;)();//=&gt;自执行函数;    </div><div class="line">//=&gt;好处：此时代码中就不要在考虑变量提升了，只要这样处理，没有所谓的变量提升</div></pre></td></tr></table></figure><p><strong> 2、使用let定义的变量不允许在<code>同一个作用域中</code>重复声明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var num2 = 12;  </div><div class="line">var num2 = 13;  </div><div class="line">console.log(num2);//=&gt;13  </div><div class="line">  </div><div class="line">let str = &apos;你好&apos;;  </div><div class="line">let str = &apos;世界&apos;;  </div><div class="line">console.log(str);//=&gt;Uncaught SyntaxError: Identifier &apos;str&apos; has already been declared  当前报错,上面代码也不会执行(在JS代码执行之前就已经知道有重复声明的了，也就是浏览器依然存在类似于变量提升的机制：在JS代码之前先把所有LET声明的变量过一遍，发现有重复的直接报错)  </div><div class="line"></div><div class="line">let num = 12;   </div><div class="line">num = 13;   </div><div class="line">console.log(num);//=&gt;13 LET不允许重复被声明，但是允许重新赋值   </div><div class="line"></div><div class="line">var att=200;    </div><div class="line">let att=100;//=&gt;Uncaught SyntaxError: Identifier &apos;att&apos; has already been declared 不管你之前使用什么方式在当前作用域中声明的变量，再使用let声明的时候都会报错  </div><div class="line"></div><div class="line">let num = 12,  </div><div class="line">    fn = function () &#123;          </div><div class="line">         let num = 13;  </div><div class="line">    &#125;;  </div><div class="line">     console.log(num);//=&gt;12 当前作用域下别重复声明即可(不同作用域中的变量是自己私有的,名字重复没有关系)    </div><div class="line">let att = 13,  </div><div class="line">    sum = function () &#123;   </div><div class="line">        att = 14;   </div><div class="line">    &#125;;   </div><div class="line">sum();   </div><div class="line">console.log(att);   </div><div class="line">//=&gt;let也存在私有变量和作用域链的概念，和ES5中基本上差不多  =&gt;14</div></pre></td></tr></table></figure><p><strong>3、关于暂时性死区：使用typeof检测一个未被声明过的变量</strong></p><blockquote><pre><code>ES5中返回的结果是undefined但是不报错ES6中直接报错</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">console.log(typeof num);</div><div class="line">//=&gt;undefined 当前变量不存在,但是使用typeof检测的时候,不会提示错误,而是返回undefined</div><div class="line">console.log(typeof num);//=&gt;Uncaught ReferenceError: num is not defined  ES6中检测一个没有被声明过的变量直接报错,不像之前ES5中的值是UNDEFINED一样了</div><div class="line">let num;</div><div class="line">console.log(typeof num);</div><div class="line">//=&gt;undefined 只声明没有定义(赋值),默认值是UNDEFINED</div></pre></td></tr></table></figure><p><strong>4、ES6语法创建的变量(let)存在块级作用域，ES5语法创建变量(var/function)没有块级作用域</strong></p><blockquote><p>[ES5]window全局作用域，函数执行形成的私有作用域</p><p>[ES6]除了有ES5中的两个作用域，ES6中新增加块级作用域（我们可以把块级作用域理解为之前学习的私有作用域：存在私有变量和作用域链的一些机制） ES6语法中把大部分用大括号包起来都称之为块级作用域</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let num = 12,  </div><div class="line">    str = &apos;&apos;;  </div><div class="line">    let fn = function (str) &#123;  </div><div class="line">    str = &apos;HELLO&apos;;           </div><div class="line">    //console.log(arguments[0]);   </div><div class="line">    //=&gt;&quot;HELLO&quot; 当前JS并没有开启严格模式,所以形参变量和ARG存在映射机制(但是我们以后尽量不要这样处理:因为把ES6编译为ES5之后,会默认的开启严格模式,映射机制会中断,此处的值依然是&apos;你好&apos;,这样导致我们的ES6结果和ES5结果不一致)   </div><div class="line">    // console.log(num);  </div><div class="line">    //=&gt;Uncaught ReferenceError: num is not defined   </div><div class="line">    let num = 13;         </div><div class="line">    console.log(num, str);//=&gt;13 &quot;HELLO&quot;   </div><div class="line">&#125;;   </div><div class="line">fn(&apos;你好&apos;);   </div><div class="line">console.log(num, str);//=&gt;12 &apos;&apos;</div></pre></td></tr></table></figure><blockquote><pre><code>大部分我们遇到的大括号操作都是块级作用域</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let num = 12,  </div><div class="line">    str = &apos;&apos;;  </div><div class="line">    let fn = function (str) &#123;  </div><div class="line">    str = &apos;HELLO&apos;;           </div><div class="line">    //console.log(arguments[0]);   </div><div class="line">    //=&gt;&quot;HELLO&quot; 当前JS并没有开启严格模式,所以形参变量和ARG存在映射机制(但是我们以后尽量不要这样处理:因为把ES6编译为ES5之后,会默认的开启严格模式,映射机制会中断,此处的值依然是&apos;你好&apos;,这样导致我们的ES6结果和ES5结果不一致)   </div><div class="line">    // console.log(num);  </div><div class="line">    //=&gt;Uncaught ReferenceError: num is not defined   </div><div class="line">    let num = 13;         </div><div class="line">    console.log(num, str);//=&gt;13 &quot;HELLO&quot;   </div><div class="line">&#125;;   </div><div class="line">fn(&apos;你好&apos;);   </div><div class="line">console.log(num, str);//=&gt;12 &apos;&apos;</div></pre></td></tr></table></figure><blockquote><pre><code>块级作用域的增加有什么用？</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let tempList = document.getElementsByName(&apos;TEMP&apos;);   </div><div class="line">// for (var i = 0; i &lt; tempList.length; i++) &#123;   </div><div class="line"></div><div class="line">// tempList[i].onclick = function () &#123;    </div><div class="line">    //console.log(i);//=&gt;5 怎么点击都是5 异步操作以及作用域链的查找,找到的都是全局下最后一次循环的结束值//     &#125;// &#125;//=&gt;自定义属性解决// for (var i = 0; i &lt; tempList.length; i++) &#123;//     tempList[i].index = i;//     tempList[i].onclick = function () &#123;//         console.log(this.index);//     &#125;// &#125;//=&gt;闭包解决// for (var i = 0; i &lt; tempList.length; i++) &#123;//     ~function (i) &#123;//         tempList[i].onclick = function () &#123;//             console.log(i);//         &#125;//     &#125;(i);// &#125;//=&gt;使用ES6的块级作用域</div><div class="line">for (let i = 0; i &lt; tempList.length; i++) &#123;    </div><div class="line">    tempList[i].onclick = function () &#123;             </div><div class="line">        console.log(i);    </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="const的基础语法"><a href="#const的基础语法" class="headerlink" title="const的基础语法"></a>const的基础语法</h2><blockquote><p>const的细节知识点和let一样，和let的主要区别在于：let是创建变量，const是创建常量</p><pre><code>变量：值是可以修改的   常量：值不能被修改</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let num = 12;   </div><div class="line">num = 13;  </div><div class="line">console.log(num);//=&gt;13   </div><div class="line">const str = &apos;你好&apos;;  </div><div class="line">str = &apos;世界&apos;;  </div><div class="line">//=&gt;而且使用BABEL如果遇到了CONST设置的常量在进行修改，就无法进行编译了  </div><div class="line">console.log(str);   </div><div class="line">//=&gt;Uncaught TypeError: Assignment to constant variable.</div></pre></td></tr></table></figure><h2 id="ES6中的解构赋值"><a href="#ES6中的解构赋值" class="headerlink" title="ES6中的解构赋值"></a>ES6中的解构赋值</h2><blockquote><pre><code>结构赋值本身是ES6的语法规范，使用什么关键字来声明这些变量是无所谓的</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let [a,b,c] = [12,23,34];   </div><div class="line">//=&gt;a:12 b:23 c:34   </div><div class="line">var [d,e,f] = [12,23,34];  </div><div class="line">//=&gt;d:12 e:23 f:34   </div><div class="line">[g,h,i] = [12,23,34];  </div><div class="line">//=&gt;此处相当于给window增加的全局属性  </div><div class="line">//g:12 h:23 i:34    </div><div class="line">//=&gt;但是这个操作在JS的严格模式下是不允许的，因为严格模式下不允许出现非使用var/let等声明的变量</div></pre></td></tr></table></figure><blockquote><pre><code>多维数组的结构赋值，可以让我们快速获取到需要的结果</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [,[,A],[,B,[,C]]] = [12, [23, 34], [45, 56, [67, 78]]];   </div><div class="line">console.log(A, B, C);   </div><div class="line">//=&gt;34 56 78</div></pre></td></tr></table></figure><blockquote><pre><code>在解构赋值中，我们可以给某一项设置默认值</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [,,,A]=[12, 23, 34];   </div><div class="line">console.log(A);//=&gt;undefined  </div><div class="line">let [,,,B = 0]=[12, 23, 34];  </div><div class="line">console.log(B);//=&gt;0</div></pre></td></tr></table></figure><blockquote><pre><code>在解构赋值中，支持...xxx的拓展运算符</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let [A,...B]=[12, 23, 34, 45, 56];   </div><div class="line">console.log(A, B);//=&gt;12 [23,34...]  </div><div class="line">let [...C]=[12, 23, 34, 45, 56];  </div><div class="line">console.log(C);//=&gt;[12,23...] 数组克隆  </div><div class="line">let [D,...E,F]=[12, 23, 34, 45, 56];  </div><div class="line">console.log(D, E, F);  </div><div class="line">//=&gt;Uncaught SyntaxError: Rest element must be last element 拓展运算符只能出现在解构赋值中的结构末尾的位置  </div><div class="line">let [G,,,...H]=[12, 23, 34, 45, 56];  </div><div class="line">console.log(G, H);//=&gt;12 [45,56]</div></pre></td></tr></table></figure><blockquote><pre><code>对象的解构赋值</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">let &#123;name, age&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;;   </div><div class="line">console.log(name, age);//=&gt;&apos;你好&apos; 9  </div><div class="line">let &#123;A, B&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;;   </div><div class="line">console.log(A, B);//=&gt;在对象的解构赋值中需要注意的是:赋值的变量需要和对象中的属性名吻合,否则无法获取对应的属性值 undefined*2   </div><div class="line">let &#123;C = 0&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;;  </div><div class="line">console.log(C);//=&gt;0 可以给当前的变量设置默认值  </div><div class="line"></div><div class="line"></div><div class="line">let &#123;name&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;;      </div><div class="line">console.log(name);//=&gt;&apos;你好&apos;  和数组的解构赋值一样,我们可以把后面不需要获取的结构省略掉      </div><div class="line"></div><div class="line">let &#123;,age&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;;//=&gt;Uncaught SyntaxError: Unexpected token , 和数组的解构赋值不一样的地方在于,对象前面不允许出现空来占位(因为对象获取需要通过具体的属性名获取,写成空的话,浏览器不知道怎么识别)      </div><div class="line"></div><div class="line">let &#123;age&#125;=&#123;name:&apos;xxx&apos;,age:&apos;xxx&apos;&#125;;//=&gt;但是我们可以把逗号去掉,这样就是只获取其中一个     </div><div class="line"></div><div class="line"></div><div class="line">let &#123;name, ...arg&#125;=&#123;name: &apos;你好&apos;, age: 9, teacher: &apos;周老师&apos;&#125;;   </div><div class="line">console.log(name, arg);   </div><div class="line">//=&gt;&apos;你好&apos; &#123;age:9...&#125;  支持拓展运算符的  </div><div class="line">//=&gt;把对象进行浅克隆(只把第一级克隆了)  </div><div class="line">let obj = &#123;name: &apos;xxx&apos;, age: 10, score: [100, 90, 80]&#125;;  </div><div class="line">let &#123;...arg&#125;=obj;console.log(arg, obj);  </div><div class="line">console.log(arg === obj);//=&gt;false  </div><div class="line">console.log(arg.score === obj.score);//=&gt;true    </div><div class="line"></div><div class="line"></div><div class="line">let &#123;name:A, age:B&#125;=&#123;name: &apos;你好&apos;, age: 9&#125;;  </div><div class="line">console.log(A, B);  </div><div class="line">//=&gt;&apos;你好&apos; 9  在对象的结构赋值中,我们可以把对象的属性名起一个小名(A和B相当于小名或者叫做别名)</div></pre></td></tr></table></figure><p><strong>解构赋值的作用</strong></p><blockquote><pre><code>快速交换两个变量的值</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = 12;let b = 13;   </div><div class="line">[a, b] = [b, a];  </div><div class="line">console.log(a, b);//=&gt;13 12</div></pre></td></tr></table></figure><blockquote><pre><code>接收函数返回的多个值</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let fn = function () &#123;       </div><div class="line">        let a = 12,   </div><div class="line">        b = 13,  </div><div class="line">        c = 14;       </div><div class="line">    return [a, b, c];   </div><div class="line">&#125;;   </div><div class="line">let [a,b,c] = fn();   </div><div class="line">console.log(a, b, c);//=&gt;12 13 14</div></pre></td></tr></table></figure><p><strong>在ES6中支持给函数设置默认值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let fn = function (x) &#123;       </div><div class="line">    console.log(x);//=&gt;undefined   </div><div class="line">    x = x || 0;       </div><div class="line">    console.log(x);//=&gt;0&#125;;   </div><div class="line">fn();   </div><div class="line">let fn2 = function (x = 0) &#123;       </div><div class="line">    console.log(x);//=&gt;0   </div><div class="line">&#125;;   </div><div class="line">fn2();</div></pre></td></tr></table></figure><h2 id="ES6中的箭头函数"><a href="#ES6中的箭头函数" class="headerlink" title="ES6中的箭头函数"></a>ES6中的箭头函数</h2><p><strong>箭头函数的基础语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let fn = function (x, y) &#123;        </div><div class="line">    return x + y;   </div><div class="line">&#125;;   </div><div class="line">console.log(fn(10, 20));   </div><div class="line">//=&gt;30//=&gt;改写成箭头函数   </div><div class="line">let fn = (x, y)=&gt; x + y;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let fn = function (n = 0) &#123;        </div><div class="line">    let x = 10,   </div><div class="line">        y = 20;       </div><div class="line">    return x + y + n;   </div><div class="line">&#125;;   </div><div class="line">//=&gt;改写成箭头函数   </div><div class="line">let arrowFn = (n = 0)=&gt; &#123;       </div><div class="line">    let x = 10,   </div><div class="line">        y = 20;       </div><div class="line">     return x + y + n;   </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><strong>箭头函数中不支持arguments</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//=&gt;传统函数支持ARGUMENTS// let fn = function () &#123;    </div><div class="line">//     let arg = Array.prototype.slice.call(arguments);</div><div class="line">//     return eval(arg.join(&apos;+&apos;));// &#125;;    </div><div class="line">let fn = (...arg)=&gt; &#123;        </div><div class="line">    //console.log(arguments);    </div><div class="line">    //=&gt;Uncaught ReferenceError: arguments is not defined     </div><div class="line">    //=&gt;不支持ARGUMENTS没事,我们使用ES6中的剩余运算符...来获取传递的进来的所有参数值（优势:使用剩余运算符接收到的结果本身就是一个数组，不需要再转换了）    </div><div class="line">    //console.log(arg instanceof Array);//=&gt;true    </div><div class="line">    return eval(arg.join(&apos;+&apos;));   </div><div class="line">&#125;;   </div><div class="line">//=&gt;也可以把FN简写成以下方式   </div><div class="line">//let fn = (...arg)=&gt; eval(arg.join(&apos;+&apos;));   </div><div class="line">console.log(fn(10, 20, 30, 40));</div></pre></td></tr></table></figure><p><strong>箭头函数中的this问题</strong></p><blockquote><pre><code>普通函数中this指向的问题</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;  </div><div class="line">    name: &apos;obj&apos;,   </div><div class="line">    fn()&#123;           </div><div class="line">    //=&gt;这样处理和下面SUM的处理是一样的  </div><div class="line">        console.log(this);  </div><div class="line">    &#125;,   </div><div class="line">    sum: function () &#123;   </div><div class="line">   </div><div class="line">    &#125;   </div><div class="line">&#125;;   </div><div class="line">obj.fn();   </div><div class="line">//=&gt;this:obj 普通函数执行THIS的指向:看函数执行前面是否有点,有点,点前面是谁THIS就是谁,没有点THIS指向WINDOW或者UNDEFINED(严格模式下)  </div><div class="line">document.body.onclick = obj.fn;  </div><div class="line">//=&gt;this:body  </div><div class="line">setTimeout(obj.fn, 1000);  </div><div class="line">//=&gt;this:window  </div><div class="line">obj.fn.call(12);//=&gt;this:12</div></pre></td></tr></table></figure><blockquote><pre><code>箭头函数中没有自己的THIS指向,用到的THIS都是所在宿主环境(它的上级作用域)中的THIS</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;   </div><div class="line">    name: &apos;obj&apos;,    </div><div class="line">    fn()&#123;        //=&gt;this:obj   </div><div class="line">   </div><div class="line">        // setTimeout(function () &#123;   </div><div class="line">        //     //=&gt;this:window  </div><div class="line">        // &#125;, 1000);   </div><div class="line"></div><div class="line">        // setTimeout(function () &#123;  </div><div class="line">        //     //=&gt;this:obj  </div><div class="line">        // &#125;.bind(this), 1000);  </div><div class="line"></div><div class="line">        // var _this = this;   </div><div class="line">        // setTimeout(function () &#123;  </div><div class="line">        //     //=&gt;_this:obj   </div><div class="line">        // &#125;, 1000);   </div><div class="line"></div><div class="line">        setTimeout(()=&gt; &#123;             </div><div class="line">            //=&gt;this:obj   </div><div class="line">        &#125;, 1000);  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div><div class="line">obj.fn();</div></pre></td></tr></table></figure><blockquote><p>   宿主环境：不是执行的环境而是定义的环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let fn = ()=&gt; &#123;       </div><div class="line">    console.log(this);   </div><div class="line">&#125;;   </div><div class="line">let obj = &#123;   </div><div class="line">    name: &apos;obj&apos;,  </div><div class="line">    sum: function () &#123;           </div><div class="line">        //=&gt;this:obj  </div><div class="line">        fn();  </div><div class="line">        //=&gt;this:window   </div><div class="line">        //宿主环境：不是执行的环境而是定义的环境，FN虽然是在这执行的，但是它是在WINDOW下定义的，所以它的宿主环境还是WINDOW  </div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line">obj.sum();</div></pre></td></tr></table></figure><blockquote><pre><code>层级嵌套的箭头函数</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// let fn = function (i) &#123;   </div><div class="line">//     return function (n) &#123;   </div><div class="line">//         return n + (++i);   </div><div class="line">//     &#125;   </div><div class="line">// &#125;;   </div><div class="line"></div><div class="line">let fn = (i)=&gt; (n)=&gt; n + (++i);</div></pre></td></tr></table></figure><h2 id="ES6中的类和继承"><a href="#ES6中的类和继承" class="headerlink" title="ES6中的类和继承"></a>ES6中的类和继承</h2><blockquote><pre><code>ES5中创建类和实例，以及如何禁止用户把类当做普通函数执行：new.target</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Person(name, age) &#123;       </div><div class="line">//console.log(new.target);//=&gt;ES6新增加的语法,如果是通过NEW执行的,返回的结果是当前创建的类,如果是当做普通函数执行的,返回的是UNDEFINED   </div><div class="line">    if (typeof new.target === &apos;undefined&apos;) &#123;            </div><div class="line">        throw new SyntaxError(`当前Person不能作为一个普通函数执行，请使用new Person来执行~~`);   </div><div class="line">    &#125;    //=&gt;NEW执行的时候,THIS是当前类的实例,THIS.XXX=XXX是给当前实例增加的私有属性</div><div class="line">    this.name = name;       </div><div class="line">    this.age = age;   </div><div class="line">&#125;//=&gt;原型上存放的是公有的属性和方法:给创建的实例使用   </div><div class="line"></div><div class="line">Person.prototype = &#123;   </div><div class="line">    constructor: Person,   </div><div class="line">    say: function () &#123;            </div><div class="line">    console.log(`my name is $&#123;this.name&#125;,i am $&#123;this.age&#125; years old~`);   </div><div class="line">    &#125;   </div><div class="line">&#125;;   </div><div class="line">//=&gt;把PERSON当做一个普通的对象,给对象设置的私有属性   </div><div class="line">Person.study = function () &#123;       </div><div class="line">    console.log(`good good study,day day up~`);   </div><div class="line">&#125;;</div><div class="line">var p1 = new Person(&apos;王雪超&apos;, &apos;80&apos;);  //不会抛出&quot;当前Person不能作为一个普通函数执行，请使用new Person来执行~~&quot;  </div><div class="line">Person(&apos;王雪超&apos;, &apos;80&apos;); //会抛出错误&quot;当前Person不能作为一个普通函数执行，请使用new Person来执行~~&quot;</div></pre></td></tr></table></figure><blockquote><pre><code>ES6中创建类</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//console.log(Person);//=&gt;Uncaught ReferenceError: Person is not defined 不存在变量提升     </div><div class="line">class Person &#123;   </div><div class="line">    constructor(name = &apos;你好&apos;, age = 9) &#123;           </div><div class="line">    //=&gt;给实例设置的私有属性   </div><div class="line">        this.name = name;           </div><div class="line">        this.age = age;   </div><div class="line">    &#125;       </div><div class="line">    //=&gt;直接在大括号中编写的方法都设置在类的原型上：ES6默认把CONSTRUCTOR的问题解决了,此时原型上的CONSTRUCTOR指向的就是PERSON   </div><div class="line">    say() &#123;           </div><div class="line">        console.log(`my name is $&#123;this.name&#125;,i am $&#123;this.age&#125; years old~`);</div><div class="line">    &#125;        </div><div class="line">    //=&gt;把PERSON当做普通对象设置属性和方法,只需要在设置的方法前面加STATIC即可</div><div class="line">    static study() &#123;            </div><div class="line">        console.log(`good good study,day day up~`);    </div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line">let p1 = new Person(&apos;王雪超&apos;);    </div><div class="line">p1.say()   //my name is 王雪超,i am 9 years old~   </div><div class="line">Person.study()    // good good study,day day up~      </div><div class="line">//Person();//=&gt;Uncaught TypeError: Class constructor Person cannot be invoked without &apos;new&apos; =&gt;ES6中使用CLASS创建的类,天生自带NEW.TARGET的验证,不允许把创建的类当做普通函数执行</div></pre></td></tr></table></figure><blockquote><pre><code>ES6中的继承</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class Person &#123;   </div><div class="line">    constructor(...ARG) &#123;          </div><div class="line">        let [x = 0,y = 0]=ARG;          </div><div class="line">        this.x = x;           </div><div class="line">        this.y = y;  </div><div class="line">    &#125;  </div><div class="line">    sum() &#123;           </div><div class="line">        return this.x + this.y;   </div><div class="line">    &#125;   </div><div class="line">&#125;   </div><div class="line">class Child extends Person &#123;      </div><div class="line">    //=&gt;创建CHILD类,并且让CHILD类继承了PERSON类:     </div><div class="line">    //1、把PERSON中的私有属性继承过来设置给了子类实例的私有属性   </div><div class="line">    //2、让子类实例的原型链上能够找到PERSON父类的原型(这样子类的实例就可以调用父类原型上的方法了)       </div><div class="line">    //=&gt;我们可以不写CONSTRUCTOR,浏览器默认会创建它,而且默认就把父类私有的属性继承过来了(而且把传给子类的参数值也传递给父类了)   </div><div class="line">    // constructor(...arg) &#123;  </div><div class="line">    //     //=&gt;ARG:传递给子类的参数(数组) [剩余运算符     </div><div class="line">    //     super(...arg);//=&gt;[展开运算符] 把ARG中每一项值展开,分别传递给父类方法 SUPER(10,20,30)    </div><div class="line">    // &#125;      </div><div class="line">    //=&gt;很多时候我们不仅要继承父类私有的,还需要给子类增加一些而外私有的,此时就必须写   CONSTRUCTOR,但是一定要在CONSTRUCTOR中的第一行写上SUPPER,否则会报错   </div><div class="line">    // constructor(...arg) &#123;   </div><div class="line">    //     super(...arg);   </div><div class="line">    //</div><div class="line">    //     let [,,z]=arg;   </div><div class="line">    //     this.z = z;    </div><div class="line">    // &#125;   </div><div class="line">    constructor(x, y, z) &#123;   </div><div class="line">        super();//&lt;=&gt;Person.prototype.constructor.call(this)   </div><div class="line">        this.z = z;   </div><div class="line">    &#125;   </div><div class="line">    fn() &#123;        </div><div class="line">       &#125;      </div><div class="line">    &#125;  </div><div class="line">let c = new Child(10, 20, 30);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ES6中的let和const&quot;&gt;&lt;a href=&quot;#ES6中的let和const&quot; class=&quot;headerlink&quot; title=&quot;ES6中的let和const&quot;&gt;&lt;/a&gt;ES6中的let和const&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、let不存在变量提升机制&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>mongoose的简单总结</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/12/09/mongoose%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/12/09/mongoose的简单总结/</id>
    <published>2017-12-09T01:52:54.108Z</published>
    <updated>2017-12-09T09:00:23.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mongoose是MongoDB的一个对象模型工具是基于node-mongodb-native开发的MongoDB  nodejs驱动，可以在异步的环境下执行同时他也是针对MongoDB操作的对象模型库，封装了MongoDB对文档一些增删改等常用方法，让nodeJS操作MongoDB数据库变得更加灵活简。Mongoose,因为封装了MongoDB对文档操作常用的处理方法，让NodeJS操作MongoDB数据库变得更加容易。</p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>1、 安装mongoose </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install mongoose</div></pre></td></tr></table></figure><p>2、 引用mongoose<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var mongoose=require(&quot;mongoose&quot;)</div></pre></td></tr></table></figure></p><p>3、使用mongoose连接数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var mongoose=require(&quot;mongoose&quot;);  </div><div class="line">var db=mongoose.connect(&apos;mongodb://192.168.1.101:27017/test&apos;,&#123;useMongoClient:true&#125;,   function (err) &#123;  </div><div class="line">       if(err)&#123;   </div><div class="line">           console.log(&quot;数据库连接失败！&quot;);  </div><div class="line">       &#125;else&#123;  </div><div class="line">           console.log(&quot;数据库连接成功！&quot;);  </div><div class="line">       &#125;  </div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p><blockquote><pre><code>192.168.1.101是本机的IP地址，test是自己建的数据库名称</code></pre></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote><p>MongoDB—是一个对象数据库，没有表行等概念，也没有固定的模式和结构，所有的数据以Document(以下简称文档)的形式存储(Document,就是一个关联数组的对象，它的内部由属性组成，它的内部由属性组成，一个属性对应的值可能是一个数，字符串，日期、数组、日期、组成、甚至是一个嵌套的文档。)，后面我们会学习如何创建并插入内容。<br>在MongoDB中，多个Document可以组成Collection（以下简称集合），多个集合可以组成数据。 </p><p>文档–是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象，同时他也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。集合–由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么集合相当于一张表。如果我们通过MongoDB去创建一个集合并对其进行增删改查，该怎么实现呢，到这里我们就先了解Schema(数据属性模型)Model、Entity。</p></blockquote><p><strong>Schema简述</strong></p><p>Schema——一种以文件的形式存储的数据模型架构，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅是数据库模型在程序片段的一种表现，可以说是数据属性模型(传统意义的表结构)，又或者是”集合”的模型骨架。<br>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var PersonSchema=new mongoose.Schema(&#123;  </div><div class="line">   name:&#123;type:String&#125;,  </div><div class="line">   age:&#123;type:Number,default:0&#125;,  </div><div class="line">   time:&#123;type:Date,default:Date.now&#125;,  </div><div class="line">   email:&#123;type:String,default:&quot;&quot;&#125;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><pre><code>基本属性类型有:字符串、日期型、数值型、布尔型(Boolean)、null、数组、内嵌文档等。</code></pre></blockquote><p><strong>Model简述</strong></p><blockquote><p>Model–由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库的属性，行为的类。</p></blockquote><p>如何通过Schema来创建Mode呢，如下实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var db=mongoose.connect(&quot;mongodb://192.168.1.103:27017/test&quot;);</div></pre></td></tr></table></figure><p>创建Model </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var PersonModel=db.model(&quot;person&quot;,PersonSchema);</div></pre></td></tr></table></figure><p>person:数据库中集合的名称，当我们对其添加数据时如果person已经存在，则会保存到其目录下，如果未存在，则会创建person集合，然后保存数据。<br>拥有了Model,我们也就拥有了操作数据库的能力<br>如果你想对某个集合有所作为，那就交给Model来处理吧，创建一个Model模型，我们需要指定:<br>&emsp;1、集合名称<br>&emsp;2、集合的Schema结构对象，满足这两个条件，我们就可以操作数据库了  、</p><p><strong>Entity简述</strong></p><p>Entity—由Model创建的实体，使用save方法保存数据，Model和Entity都能影响数据库的操作，但Model比Entity更具操作性。</p><p>使用Model创建Entity,如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var PersonEntity=new PersonModel(&#123;  </div><div class="line">     name:&quot;zhangsan&quot;,  </div><div class="line">     age:6,  </div><div class="line">     email:&quot;zhangsan.com&quot;  </div><div class="line">&#125;);  </div><div class="line">console.log(PersonEntity.name);//zhangsan </div><div class="line">console.log(PersonEntity.age);//6</div></pre></td></tr></table></figure><blockquote><pre><code>创建成功之后，Schema的属性就变成了Model和Entity的公有属性了</code></pre></blockquote><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p><strong>查询</strong><br>查询分为很多种类型，入条件查询，过滤查询等等，今天只学习最基本的，现在先来看最基本的find查询</p><p>1、find查询:obj.find(查询条件，callback);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PersonModel.find(&#123;&#125;,function(error,docs)&#123;  </div><div class="line">    //没有向find传递参数，默认的是显示所有文档  </div><div class="line">  &#125;);  </div><div class="line"></div><div class="line">  PersonModel.find(&#123;&quot;age&quot;:6&#125;,function(error,docs)&#123;  </div><div class="line">      if(error)&#123;  </div><div class="line">      console.log(&quot;error:&quot;+error);  </div><div class="line">      &#125;else&#123;  </div><div class="line">      console.log(docs);//docs:age为6的所有文档  </div><div class="line">      &#125;  </div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p><strong>Model保存方法</strong></p><p>Model提供了一个create方法来对数据进行保存，下面我们来看一下实例:  </p><blockquote><pre><code>Model.create(文档数据,callback);   </code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PersonModel.create(&#123;name:&quot;test&quot;,age:7&#125;,function(error,doc)&#123;  </div><div class="line">    if(error)&#123;  </div><div class="line">    console.log(error);  </div><div class="line">    &#125;else&#123;  </div><div class="line">    console.log(doc);</div><div class="line">    &#125;  </div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p><strong>entity保存方法</strong></p><p>entity也提供的对数据的保存方法和Model提供保存方法类似</p><blockquote><pre><code>Entity.save(文档数据,callback);</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var PersonEntity=new PersonModel(&#123;name:&quot;test&quot;,age:9&#125;);  </div><div class="line">    PersonEntity.save(function(error,doc)&#123;  </div><div class="line">    if(error)&#123;  </div><div class="line">        console.log(error);  </div><div class="line">    &#125;else&#123;  </div><div class="line">        console.log(doc);  </div><div class="line">    &#125;  </div><div class="line">  &#125;);</div></pre></td></tr></table></figure><blockquote><pre><code>model调用的是create方法，entity调用的是save方法</code></pre></blockquote><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>实例:Model.update(查询条件，更新对象，callback);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var condition=&#123;name:&quot;Zhangsan&quot;&#125;;  </div><div class="line">var update=&#123;$set:&#123;age:100&#125;&#125;;  </div><div class="line">PersonModel.update(condition,update,function(error)&#123;  </div><div class="line">    if(error)&#123;  </div><div class="line">       console.log(error);  </div><div class="line">    &#125;else&#123;  </div><div class="line">      console.log(&apos;Update success&apos;);  </div><div class="line">    &#125;  </div><div class="line">&#125;)；</div></pre></td></tr></table></figure><blockquote><pre><code>更新后find()一下，此时数据已经修改成功 了!请注意如果匹配到多条记录，默认只更新一条，如果要更新匹配到所有记录的话需要加一个参数{multi:true}。</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var condition=&#123;name:&quot;Zhangsan&quot;&#125;;  </div><div class="line">var update=&#123;$set:&#123;age:100&#125;&#125;;  </div><div class="line">PersonModel.update(condition,update,&#123;multi:true&#125;,function(error)&#123;  </div><div class="line">    if(error)&#123;  </div><div class="line">      console.log(error);  </div><div class="line">    &#125;else&#123;  </div><div class="line">      console.log(&apos;Update success&apos;);  </div><div class="line">    &#125;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><strong>删除数据</strong><br>实例：Model.remove(查询条件，callback); </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var condition=&#123;name:&quot;Zhangsan&quot;&#125;;  </div><div class="line">PersonModel.remove(conditions,function(error)&#123;  </div><div class="line">    if(error)&#123;  </div><div class="line">      console.log(error);  </div><div class="line">    &#125;else&#123;  </div><div class="line">      console.log(&quot;Delete success&quot;);  </div><div class="line">    &#125;;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><pre><code>和update类似吧，有了remove方法我们就可以呀进行删除操作了。</code></pre></blockquote><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><p><strong>简介</strong><br>查询就是返回一个集合中的文档的子集，Mongoose模型提供了find、findOne、和findById方法用于文档查询我们这里先添加一些数据;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">PersonModel.create([</div><div class="line">  &#123;name:&apos;name1&apos;,age:1&#125;,</div><div class="line">  &#123;name:&apos;name2&apos;,age:2&#125;,</div><div class="line">  &#123;name:&apos;name3&apos;,age:3&#125;,</div><div class="line">  &#123;name:&apos;name4&apos;,age:4&#125;,</div><div class="line">  &#123;name:&apos;name5&apos;,age:5&#125;,</div><div class="line">  &#123;name:&apos;name6&apos;,age:6&#125;,</div><div class="line">  &#123;name:&apos;name7&apos;,age:7&#125;,</div><div class="line">  &#123;name:&apos;name8&apos;,age:8&#125;,</div><div class="line">  &#123;name:&apos;name9&apos;,age:9&#125;,</div><div class="line">  &#123;name:&apos;name10&apos;,age:10&#125;</div><div class="line">],function(error,docs)&#123;</div><div class="line">    if(error)&#123;</div><div class="line">      console.log(error);</div><div class="line">   &#125;else&#123;</div><div class="line">      console.log(&quot;save ok&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><strong>属性过滤</strong><br>find(Condition,field,callback);field省略或为Null,则返回所有属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//返回只包好name,age两个键的所有记录  </div><div class="line">PersonModel.find(&#123;&#125;,&#123;name:1,age:1,_id:0&#125;,function(err,docs)&#123;  </div><div class="line">  //docs 查询结果集  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><pre><code>说明:我们只需要把显示属性设置为大于零的数就可以了，当然1是最好理解的，_id是默认返回，如果不要显示加上(&quot;_id&quot;:0),但是，对其他不需要显示的属性且不是_id,如果设置为0的话将会抛出异常或查询无果。</code></pre></blockquote><ul><li>findOne查询单条</li></ul><p>返回查询结果<br>1、单条数据 findOne(Conditions,callback);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PersonModel.findOne(&#123;age:6&#125;,function(err,doc)&#123;  </div><div class="line">     //查询符合age等于6的第一条数据  </div><div class="line">     //doc是查询结果  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>findById(按ID单条数据)，与findOne相同，但它只接收文档的_id作为参数，返回单个文档。<br>1、按ID单条数据findById(_id,callback);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PersonModel.findById(person._id,function(err,doc)&#123;  </div><div class="line">  //doc 查询结果文档  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><p><strong>$gt(大于)、$lt(小于)</strong><br>查询时我们经常会碰到要根据，某些字段进行条件筛选查询，比如说Number类型，怎么办了，我们可以使用$gt、$lte(&lt;=),$gte(&gt;=)操作进行排除性查询，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Model.find(&#123;&quot;age&quot;&#125;:&#123;&quot;$gt&quot;:6&#125;,function(error,docs)&#123;  </div><div class="line">  //查询所有age大于6的数据  </div><div class="line">&#125;);  </div><div class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$lt&quot;:6&#125;&#125;,function(error,docs)&#123;  </div><div class="line">  //查询所有age小于6的数据  </div><div class="line">&#125;);  </div><div class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:6,&quot;lt&quot;:9&#125;&#125;,function(error,docs)&#123;  </div><div class="line">  //查询所有age大于6小于9的数据  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><strong>$ne(不等于)</strong> </p><p>$ne(!=)操作符的含义相当于不等于、不包含，查询时我们可通过它进行条件判定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$ne&quot;:6&#125;&#125;,function(error,docs)&#123;  </div><div class="line">  //查询所有age不等于6的数据  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><pre><code>$ne可以匹配单个值，也可以匹配不同类型的值</code></pre></blockquote><p><strong>$in(包含)</strong></p><p>和$ne操作符相反，$in相当于包含、等于、查询时查找包含于指定字段条件的数据，具体使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$in&quot;:6&#125;&#125;,function(error,docs)&#123;  </div><div class="line">  //查询所有age等于6的数据  </div><div class="line">&#125;);  </div><div class="line"></div><div class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$ne&quot;:[6,7]&#125;&#125;,function(error,docs)&#123;  </div><div class="line">  //可以把多个值组织成一个数组  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><strong>$or(或者)</strong><br>$or操作符，可以查询多个键值的任意给定值，只要满足其中一个就可返回，用于存在多个条件判定的情况下使用，如下示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Model.find(&#123;&quot;$or&quot;:[&#123;&quot;name&quot;:&quot;name1&quot;&#125;,&#123;&quot;age&quot;:6&#125;]&#125;,function(error,docs)&#123;  </div><div class="line">//查询name为name1或age为6的全部文档  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><strong>$exists(是否存在)</strong><br>$exists操作符，用于判断某些关键字是否存在来进行条件查询，如下示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Model.find(&#123;name:&#123;$exists:true&#125;&#125;,function(error,docs)&#123;  </div><div class="line">//查询所有存在name的文档  </div><div class="line">&#125;);  </div><div class="line"></div><div class="line">Model.find(&#123;email:&#123;$exists:false&#125;&#125;,function(error,docs)&#123;  </div><div class="line">//查询所有不存在email的文档  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="游标操作"><a href="#游标操作" class="headerlink" title="游标操作"></a>游标操作</h2><p>简介<br>数据库用游标返回find的执行结果，客户端对游标的实现通常能够对最终的结果进行有效的控制，可以限制结果的数量，略过部门结果，根据任意键任意顺序的组合对结果进行各种排序，或者是执行其他操作</p><p>最常用的选项查询就是限制返回结果的数量(limit函数)、忽略一点数量的结果(skip函数)以及排序(sort函数)，通过它来限制结果数量</p><p>limit函数的基本用法<br>在查询操作中，有时数据量会很大，这时我们就需要对返回结果的数量进行限制，那时我们就可以使用limit函数，通过它来限制结果数量<br>1、限制数量:find(Condition,fields,options,callback); </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Model.find(&#123;&#125;,null,&#123;limit:20&#125;,function(err,docs)&#123;  </div><div class="line">console.log(docs)  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>如果匹配到的结果不到20个，则返回匹配数量的结果，也就是说limit函数指定的是上限而非下限</p><p>skip函数的基本用法<br>skip和limit类似，都是对返回结果的数量进行操作，不同的是skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果，如下实例:<br>1、跳过数量:find(Conditions,fields,options,callback);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Model.find(&#123;&#125;,null,&#123;skip:4&#125;,function(err,docs)&#123;</div><div class="line">console.log(docs)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><pre><code>如果查询结果数量中少于4个的话，则不会返回任何结果。</code></pre></blockquote><p><strong>sort函数基本用法</strong><br>sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键值对，键代表排序键名，值代表排序的方向1是升序，-1是降序。<br>1、结果排序:find(Conditions,fields,options,callback);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Model.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;,function(err,docs)&#123;  </div><div class="line">//查询所有的数据，并按照降序顺序返回数据docs  </div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><pre><code>sort函数可以根据用户自定义条件有选择性的来进行排序显示数据结果</code></pre></blockquote><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p><strong>ObjectId简述</strong></p><p>存储的mongodb集合的中的每个文档(document)都有一个默认的主键，这个主键的名称是固定的，他可以是mongodb支持的任何数据类型，默认是ObjectId,该类型的值由系统自己生成，从某种意义上集合不会重复：</p><p>MySQL等关系数据可的主键都是自增的，但在分布式的环境下，这种方法就不可行了，会产生冲突，为此，MongoDB采用了一个称之为Objectid的类型做主键，Objectid是一个12字节的BSON类型的字符串，按照字节排序，依次代表</p><blockquote><pre><code>4字节：UNIX时间戳3字节：运行mongoDB的机器2字节:表示生成此_id的进程3字节:由一个随机开始的计数器生成的值</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var mongoose=require(&quot;mongoose&quot;);  </div><div class="line">var personSchema=new mongoose.Schema(&#123;&#125;);//默认_id:ObjectId类型</div></pre></td></tr></table></figure><p>每一个文档都有一个特殊的键”_id”,这个键在文档所属的集合中是唯一的。<br>Shema添加属性值:<br>前面我们已经讲述了如何如何定义了一个Schema并赋予某些属性值，那能不能先定义后添加属性了，答案是可以的，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var mongoose=require=require(&quot;mongoose&quot;);  </div><div class="line">var PersonSchema=new mongoose.Schema;  </div><div class="line">PersonSchema.add(&#123;name:&quot;String&quot;,email:&quot;String&quot;,age:&quot;Number&quot;&#125;);</div></pre></td></tr></table></figure><p>实例方法:<br>有的时候，我们需要创造的Schema不仅要为后面的Model和Entity提供公共属性，还要提供公共方法，那怎么在Schema下创建一个实例方法了，请看实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var mongoose=require(&quot;mongoose&quot;);  </div><div class="line">var PersonSchema=new mongoose.Schema(&#123;name:String&#125;);  </div><div class="line">PersonSchema.method(&apos;greet&apos;,function()&#123;  </div><div class="line">console.log(&quot;how are you&quot;);  </div><div class="line">&#125;);  </div><div class="line">var Person=mongoose.model(&apos;person&apos;,PersonSchema);  </div><div class="line">var person=new Person();  </div><div class="line">person.greet();//how are you</div></pre></td></tr></table></figure><p><strong>Schema静态方法</strong><br>如下实例； </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var mongoose=require(&quot;mongoose&quot;);  </div><div class="line">var db=mongoose.connect(&quot;mongodb://192.168.1.103:27017/test&quot;);  </div><div class="line">var PersonSchema=new mongoose.Schema(&#123;  </div><div class="line">    name:&#123;type:String&#125;,  </div><div class="line">    age:&#123;type:Number,default:0&#125;,  </div><div class="line">  &#125;  </div><div class="line">);  </div><div class="line">PersonSchema.static(&quot;findByName&quot;,function(name,callback)&#123;  </div><div class="line">   return this.find(&#123;name:name&#125;,callback)  </div><div class="line">&#125;);  </div><div class="line">var PersonModel=db.model(&quot;person&quot;,PersonSchema);  </div><div class="line"></div><div class="line">PersonSchema.findName(&quot;zfpx&quot;,function(err,docs)&#123;  </div><div class="line">//docs所有名字叫zfpx的结果集  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Mongoose是MongoDB的一个对象模型工具是基于node-mongodb-native开发的MongoDB  nodejs驱动，可以
      
    
    </summary>
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/"/>
    
      <category term="mongoDB" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/mongoDB/"/>
    
      <category term="Mongose" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/mongoDB/Mongose/"/>
    
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/Node-js/"/>
    
      <category term="mongoDB" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/mongoDB/"/>
    
      <category term="Mongose" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/Mongose/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码解读和常用方法</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/25/jQuery/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/25/jQuery/</id>
    <published>2017-11-25T14:41:12.511Z</published>
    <updated>2017-11-25T14:41:12.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JQ的版本和下载"><a href="#JQ的版本和下载" class="headerlink" title="JQ的版本和下载"></a>JQ的版本和下载</h2><p>jQuery (JQ) 的版本<br>1.x：兼容IE6~8浏览器，是目前PC端开发常用的类库<br>2.x / 3.x：不支持IE6~8的兼容了，目前市场上应用的特别少 (移动端开发一般我们都用zepto.js)  </p><ul><li>jquery-1.9.1.min.js</li><li>jquery-1.11.3.min.js</li><li>jquery.min.js</li><li>…</li></ul><p><strong>下载JQ</strong></p><p>官网下载：<a href="http://jquery.com/" target="_blank" rel="external">http://jquery.com/</a><br>GitHub：<a href="https://github.com/jquery/jquery">https://github.com/jquery/jquery </a>下载JQ的源码进行学习和分析<br>百度搜索或者在 <a href="http://code.jquery.com/jquery-1.11.1.min.js" target="_blank" rel="external">http://code.jquery.com/jquery-1.11.1.min.js</a> （地址后面放入的是对应的JQ的版本号）  </p><p>基于NODE的NPM包管理器也可以下载JQ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm view jquery &gt; jquery.version.json</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install jquery //下载最新版本JQ</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install jquery@1.11.3 //下载指定版本JQ</div></pre></td></tr></table></figure><h2 id="JQ的核心原理解读"><a href="#JQ的核心原理解读" class="headerlink" title="JQ的核心原理解读"></a>JQ的核心原理解读</h2><p>JQ是一个常用方法类库（常用的DOM库），提供了很多真实项目开发中需要使用的属性和方法（这些方法JQ已经帮我们完善了浏览器兼容处理以及一些细节的优化）,jQuery本身是一个类<br>JQ是基于构造函数模式构建的类库.</p><p><strong>JQ的选择器</strong></p><pre><code>var jQuery=function(selector,context){          return new jQuery.fn.init(selector, context);  };  jQuery.fn=jQuery.prototype={      jquery:version,      constructor:jQuery,      ...  };  ...  init=jQuery.fn.init=function(selector, context){          if(typeof selector==&quot;string&quot;){          ...      }else if(selector.nodeType){          ...      }else if(jQuery.isFunction(selector)){          ...      }    return jQuery.makeArray(selector,this );          //=&gt;返回的是一个类数组  }  init.prototype=jQuery.fn;  ...  window.jQuery=window.$=jQuery;</code></pre><blockquote><p>当我们在JS中执行：$()或jQuery()，都是在创建一个JQ类的实例（$===jQuery），这些实例都是一个类数组（我们把这个类数组称之为JQ对象），JQ的实例可以使用JQ原型上提供的公有的属性和方法。<br>我们之所以把$()称之为JQ的选择器，因为执行这个方法可以传递一个selector参数进去，通过selector我们可以获取到需要操作的DOM元素集合（JQ类数组集合）；传递的第二个参数context它是当前获取元素的上下文（不传递默认是document，如果传递，我们传递一个JS元素对象即可）但是把它叫做JQ选择器有点笼统，因为传递的selector支持三种格式：</p></blockquote><ul><li>传递的是个字符串，就是我们所谓的选择器，能够通过选择器获取到元素</li><li>传递的是个元素对象，它的意思是把JS原生对象转换为JQ对象</li><li>传递的是个函数，它代表等DOM结构加载完成在执行对应的JS代码（类似于window.onload</li></ul><pre><code>$===jQuery  //=&gt;true  $()===jQuery() //=&gt;false 不同实例  $() instanceof jQuery //=&gt;true  var $example=$(); //=&gt;我们用JQ选择器获取的值，一般都是用以$开头的变量名来存储（以后看见变量名是以$开头的，我们就知道是JQ获取的实例[JQ对象]）</code></pre><blockquote><p>第一个参数[selector]传递的是一个字符串，就是通过选择器获取需要的元素集合（获取的结果怎么着都是类数组集合：获取多个元素也就是索引多点，获取一个元素也就是只有索引0，一个都没获取到就是一个空的类数组集合[而不是null]）,一般CSS或者CSS3中支持的选择器，JQ都支持。</p></blockquote><pre><code>//=&gt;基本选择器  $(&apos;#xxx&apos;)    $(&apos;.xxx&apos;)    $(&apos;xxx&apos;)    $(&apos;*&apos;)    $(&apos;.xxx,#xxx&apos;)  //=&gt;后代选择器  $(&apos;.box a&apos;)  $(&apos;.box&gt;a&apos;)  //$(&apos;.box~a&apos;)  //$(&apos;.box+a&apos;) 不常用  //=&gt;伪类选择器   $(&apos;.box:contains(xxx)&apos;) 包含某某某内容的  $(&apos;a:first&apos;)  $(&apos;a:last&apos;)  $(&apos;a:eq(1)&apos;) 索引为1的  $(&apos;a:gt(1)&apos;) 索引大于1的  $(&apos;a:lt(10)&apos;) 索引小于10的  $(&apos;a:not()&apos;) 不包含什么的  $(&apos;a:not(:gt(5))&apos;) 获取所有的a，但是不包含索引大于5的（前六个）  ...</code></pre><p><strong>JQ对象和原生JS对象转换</strong></p><ul><li>JQ对象：通过$()获取的JQ实例(类数组)</li><li><p>原生JS对象：通过ES中提供的属性或者方法获取的JS元素对象(nodeType===1)</p></li><li><p>把JQ对象转换为原生JS对象:</p></li></ul><pre><code>var oBox=document.getElementById(&apos;box&apos;);  //=&gt;原生JS对象//oBox.addClass();  //=&gt;报错：oBox不是JQ对象，不能使用JQ原型上的方法  var $box=$(oBox); //=&gt;把原生JS对象转换为JQ对象  $box.addClass(&apos;bg&apos;);</code></pre><ul><li>把JQ对象转换为原生JS对象</li></ul><pre><code>var $body=$(&apos;body&apos;);  //$body.className   //=&gt;undefined，因为className是JS原生内置的属性，JQ对象不能直接的用  //$body[索引]：在集合中获取指定索引的内容（获取的内容就是原生JS对象）  //$body.get(索引)：等价于 $body[索引]，获取指定索引位置的元素（原生JS对象）//$body.eq(索引)：获取指定索引位置的元素对象（获取的结果还是一个新的JQ对象）</code></pre><p><strong>selector是一个方法</strong></p><pre><code>$(function(){        //=&gt;当页面中的DOM结构加载完成，就会执行回调函数中的JS代码    //=&gt;类似于window.onload：等到页面中的DOM结构以及资源文件都加载完成才会执行对应的JS代码});$(document).ready(function(){        //=&gt;这种写法和上面的写法一模一样});</code></pre><p>和window.onload不太一样  </p><blockquote><p>$(function(){}) 可一在同一个页面中使用多次，多次都生效（所以在使用JQ完成代码的时候，我们一般都会把代码放在回调函数中：首先不仅是等到结构加载完在执行，而且还形成了一个闭包）<br>原理：利用了DOM二级事件绑定(可以执行多次)，监听的是DOMContentLoaded事件(DOM结构加载完成就会触发执行)</p><p>window.onload本身就是资源都加载完成才会执行，使用的是DOM零级事件绑定，在同一个页面中只能使用一次<br>window.onload=function()…<br>window.onload=function()…<br>只能留最后一个，最后一次赋值替换了原有赋值</p></blockquote><h2 id="JQ即是一个类也是一个对象"><a href="#JQ即是一个类也是一个对象" class="headerlink" title="JQ即是一个类也是一个对象"></a>JQ即是一个类也是一个对象</h2><blockquote><pre><code>jQuery.prototype上设置了很多的属性和方法，这些是供JQ实例（DOM集合或者DOM元素）使用的属性和方法:addClasscssremoveClassattr…jQuery也是一个普通的对象，在对象上也有一些自己的属性和方法（和实例没有任何的关系）,这些都是工具类的方法:ajaxisFunctionunique…</code></pre></blockquote><p><strong>jQuery.prototype</strong></p><blockquote><pre><code>$(&apos;#box&apos;).index()：获取当前元素的索引（是在自己兄弟元素中的索引，它有几个哥哥，索引就是几）$(&apos;body&apos;).data(key,value)只传递key是获取如果传递了value是设置我们通过这个方法可以获取到在HTML结构上设置的data-xxx的自定义属性值//&lt;body data-index=&apos;12&apos;&gt;&lt;/body&gt;//$(&apos;body&apos;).data(&apos;index&apos;) =&gt;12$(&apos;#box&apos;).attr()：设置或者批量设置或者获取当前元素的自定义属性(内置属性也可以)叫做removeAttr$(&apos;#box&apos;).prop()：和attr一样也是操作元素属性的，但是prop一般都操作表单元素的内置或者自定义属性 removePropaddClass：增加样式类removeClass：移除样式类toggleClass：当前样式类有就是移除，没有就是增加hasClass：验证是否存在某个样式类名$(&apos;#box&apos;).html([val])：不传val就是获取内容，传递val就是设置内容，等价于原生的innerHTML。$(&apos;input&apos;).val([val])：表单元素value值的操作(设置或者获取)css：设置或者批量设置或者获取元素的样式（获取的结果没有去单位）offset()：获取距离BODY的偏移position()：获取距离父级参照物的偏移scrollTop/scrollLeft([val])：获取或者设置当前元素卷去的高度或者宽度height/width([val])innerWidth/innerHeight()：等价于clientWidth/clientHeightouterWidth/outerHeight()：等价于offsetWidth/offsetHeight$(&apos;#box&apos;).on(&apos;click&apos;,function...)：JQ中的事件绑定...$(&apos;#box&apos;).remove()：把当前盒子在容器中移除$(&apos;#box&apos;).clone(true)：把当前盒子深度克隆一份filterchildrenfind...</code></pre></blockquote><p><strong>写在对象上的方法</strong></p><blockquote><p>var j=$.noConflict()：如果当前项目中引入了两个类库，都是使用$操作的，为了防止$使用权的冲突，JQ做了一个处理，可以让我们转让$的使用权；此处返回的值j就是代表原始$的变量，以后可以使用j()执行（使用jQuery()执行也可以）<br>var j=$.noConflict(true)：深度转让，把jQuery和$的使用权都转让了，此时只能使用j()执行了<br>$.ajax()：帮助我们发送ajax请求<br>…</p></blockquote><p><strong>筛选方法</strong></p><pre><code>var $links=$(&apos;a&apos;);  $links.filter(&apos;.bg&apos;);   //=&gt;首先获取所有的A，在所有的A中把具备样式类为bg的获取到（二次筛选）  $(&apos;#box&apos;).children(&apos;a&apos;);  //=&gt;首先获取#box所有的子元素，在所有子元素中筛选出标签名为a的元素集合 &lt;=&gt; $(&apos;#box&gt;a&apos;)  $(&apos;#box&apos;).find(&apos;.bg&apos;);   //=&gt;首先获取#box后代中所有的元素，在所有的元素中筛选出样式类名中具备bg的元素集合 &lt;=&gt;   $(&apos;#box .bg&apos;)  //prev：获取上一个哥哥  $(&apos;#box&apos;).prev(&apos;a&apos;)  //prevAll：所有的哥哥  //next：下一个弟弟  //nextAll：所有的弟弟  //siblings：所有的兄弟  //parent：父亲元素  //parents：所有的祖先元素（一直到html为止）  ...</code></pre><p><strong>each</strong></p><p>JQ中的each有三种:</p><ul><li>写在原型上的each：遍历JQ对象中的每一项</li><li>写在对象上的each：工具方法，可以用来遍历数组、类数组、对象等</li><li>内置的each其实也是调用原型上的each处理的，只不过JQ在处理的时候会内部自己调用</li></ul><pre><code>//=&gt;内置EACH$(&apos;a&apos;).addClass(&apos;select&apos;);   //=&gt;我们获取的A可能有很多个，执行一次addClass，相当于给每个获取的A都增加了一个叫做select的样式类（JQ中大部分方法在执行的时候，都会把获取的JQ集合中的每一项调用each进行遍历，把需要操作的任务对每一个遍历的元素进行操作）$(&apos;a&apos;).css(&apos;width&apos;);   //=&gt;获取的时候只返回第一个元素的样式（设置走内置EACH批量处理，获取只处理第一个）  //=&gt;原型上的EACH$(&apos;a&apos;).each(function(index,item){      //=&gt;传递参数的顺序和数组内置的forEach顺序相反：ary.forEach(function(item,index)  {...});      //=&gt;获取的A有多少个，回调函数被触发执行多少次：index当前遍历这一项的索引 item是当前遍历这一项的内容      //=&gt;this -&gt; item (原生JS对象) 方法中的this是当前遍历的这一项      //=&gt;$(this) 也是当前遍历这一项，但是属于JQ对象});      //=&gt;JQ对象上提供的工具方法：each$.each([数组/类数组],   function(index,item) {      //=&gt;this:item});  $.each([对象],function(key,value){          //=&gt;this:value      //=&gt;JQ也是采用for in循环用来遍历对象的，这样的话就存在可能把公有属性和方法遍历到的问题      if([对象].hasOwnProperty(key)){     }  });</code></pre><p><strong>extend</strong></p><ul><li>$.extend()：把方法扩展到JQ对象上，这个操作一般是用来完善类库的</li><li>$.fn.extend()：把方法扩展到JQ的原型上，供JQ的实例（DOM集合）使用，这个操作一般是用来写JQ插件的</li></ul><pre><code>//=&gt;扩展工具方法，用来完善类库$.extend({       aa:function(){}  });  $.aa();  //=&gt;扩展到原型上供实例调用的  $.fn.extend({      bb:function(){              //=&gt;this:操作当前这个方法的JQ实例（JQ对像），此处不需要再$(this)转换为JQ对像      }   });  $(&apos;xxx&apos;).bb();</code></pre><p><strong>animate</strong></p><p>JQ中提供了元素运动的动画库:</p><blockquote><pre><code>stop：结束当前元素正在运行的动画，继续执行下一个新动画（一般我们实现动画,stop方法基本上必然执行）finish：和stop类似，finish需要让元素立即运动到上一个动画的目标位置，从目标位置执行下一个动画，而stop是从上一个动画停止的位置执行下一个动画animate([target],[duration],[effect],[callBack])：[target] 对象[duration] MS[effect] linear、ease、ease-in、ease-out、ease-in-out[callBack] 回调函数，动画结束做的事情show(1000/‘fast’/‘slow’)hidetogglefadeInfadeOutfadeToggleslideUpslideDownslideToggle…</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JQ的版本和下载&quot;&gt;&lt;a href=&quot;#JQ的版本和下载&quot; class=&quot;headerlink&quot; title=&quot;JQ的版本和下载&quot;&gt;&lt;/a&gt;JQ的版本和下载&lt;/h2&gt;&lt;p&gt;jQuery (JQ) 的版本&lt;br&gt;1.x：兼容IE6~8浏览器，是目前PC端开发常用的类
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
      <category term="jQuery" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/jQuery/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>buffer基础知识</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/19/buffer%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/19/buffer基础知识/</id>
    <published>2017-11-19T08:22:33.756Z</published>
    <updated>2017-11-22T09:34:08.455Z</updated>
    
    <content type="html"><![CDATA[<p>Buffer 类是一个全局变量类型，用来直接处理2进制数据的，JS语言自身只有字符串数据类型，没有二进制数据类型，而在处理TCP和文件流的时候，必须要处理二进制数据，NodeJS提供Buffer对象来对二进制数据的操作。<br><a id="more"></a></p><h2 id="创建Buffer实例"><a href="#创建Buffer实例" class="headerlink" title="创建Buffer实例"></a>创建Buffer实例</h2><p>使用Buffer.from(), Buffer.alloc(), Buffer.allocUnsafe()等方法来创建一个Buffer实例，6.0版本以前直接使用构造函数创建的方法new Buffer()已被丢弃，不推荐使用，因为有可能会造成内存泄漏。</p><p><strong>Buffer.from(value,[…])</strong></p><p>Buffer.from(value,[…])在转换到时候分为四种情况：<br>1、第一，value为16进制数组，将数组转化为buffer，如果不是16进制，则会进行转换，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var buf = Buffer.from([2,9,7,8,17]);  </div><div class="line">console.log(buf);//&lt;Buffer 02 09 07 08 11&gt;</div></pre></td></tr></table></figure><p>2、value为字符串，则转换字符串为buffer，该方法会使用buffer池，代码如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var buf = Buffer.from(&apos;hello&apos;);  </div><div class="line">console.log(buf);//&lt;Buffer 68 65 6c 6c 6f&gt;</div></pre></td></tr></table></figure><p>3、value为buffer实例，则将value拷贝至新的buffer中，这里只是值的拷贝，不会共享内存，代码如下；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var buf1 = Buffer.from(&apos;hello&apos;);  </div><div class="line">var buf2=  Buffer.from(buf1);  </div><div class="line">console.log(buf1);//&lt;Buffer 68 65 6c 6c 6f&gt;  </div><div class="line">console.log(buf2);//&lt;Buffer 68 65 6c 6c 6f&gt;  </div><div class="line">buf2[0]=0x56;  </div><div class="line">console.log(buf1);//&lt;Buffer 68 65 6c 6c 6f&gt;  </div><div class="line">console.log(buf2);//&lt;Buffer 56 65 6c 6c 6f&gt;</div></pre></td></tr></table></figure><p>4、value为arrayBuffer时，还有两个可选参数（value,byteOffset，length），byteOffset指定从arrayBuffer开始复制的位置，length复制的长度，代码如下；  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = new Uint8Array(2);  </div><div class="line">arr[0] = 69;  </div><div class="line">arr[1] = 67;  </div><div class="line">var buf = Buffer.from(arr.buffer,0,2);  </div><div class="line">console.log(buf);//&lt;Buffer 45 43&gt;</div></pre></td></tr></table></figure><p>注意:如果引用的是arr.buffer，则新创建的buffer， buf与arr共享内存,任意改变buf和arr另一个随之改变，代码验证如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var arr = new Uint8Array(2);  </div><div class="line">arr[0] = 69;  </div><div class="line">arr[1] = 67;  </div><div class="line">var buf = Buffer.from(arr.buffer);  </div><div class="line">console.log(buf);//&lt;Buffer 45 43&gt;  </div><div class="line">console.log(arr);//Uint8Array [ 69, 67 ]  </div><div class="line">buf[0]=123;  </div><div class="line">console.log(buf);//&lt;Buffer 7b 43&gt;  </div><div class="line">console.log(arr);//Uint8Array [ 123, 67 ]  </div><div class="line">arr[0]=88;  </div><div class="line">console.log(buf);//&lt;Buffer 58 43&gt;  </div><div class="line">console.log(arr);//Uint8Array [ 88, 67 ]</div></pre></td></tr></table></figure><p><strong>Buffer.alloc(size, fill, encoding)</strong></p><p>Buffer.alloc(size, fill, encoding)，参数含义如下：</p><blockquote><pre><code>size，指定buffer的长度，但不能超过buffer.kMaxLength，若不是数字则报错fill，指定初始化buffer的值，默认为0encoding，如果fill是字符串，则该参数指定fill的编码</code></pre></blockquote><p>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var buf1=Buffer.alloc(5);  </div><div class="line">console.log(buf1);//-&gt;&lt;Buffer 00 00 00 00 00&gt;  </div><div class="line">var buf2=Buffer.alloc(5,&apos;hello&apos;,&apos;base64&apos;);  </div><div class="line">console.log(buf2);//-&gt;&lt;Buffer 85 e9 65 85 e9&gt;  </div><div class="line">var buf3=Buffer.alloc(5,&apos;hello&apos;).toString();  </div><div class="line">console.log(buf3);//-&gt;hello  </div><div class="line">var buf4=Buffer.alloc(5,&apos;hello&apos;);  </div><div class="line">console.log(buf4);//-&gt;&lt;Buffer 68 65 6c 6c 6f&gt;</div></pre></td></tr></table></figure><p><strong>Buffer.allocUnsafe(size)</strong><br>Buffer.allocUnsafe(size),size参数指定buffer的大小，该方法返回一个没有初始化的buffer，因此可能还保留有敏感的数据，造成信息的泄漏，建议使用buffer.fill(0)函数初始化buffer，该方法与Buffer.alloc(size, fill)是不一样的，有可能使用8KB池。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var buf1=Buffer.allocUnsafe(5);  </div><div class="line">console.log(buf1);//-&gt;&lt;Buffer 02 00 00 00 bf&gt;  </div><div class="line">buf1.fill(0);  </div><div class="line">console.log(buf1);//-&gt;&lt;Buffer 00 00 00 00 00&gt;</div></pre></td></tr></table></figure><p><strong>Buffer.allocUnsafeSlow(size)</strong><br>Buffer.allocUnsafeSlow(size)，参数含义同上，该方法不会使用Buffer池，容易造成内存的浪费；代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var buf1=Buffer.allocUnsafeSlow(5);  </div><div class="line">console.log(buf1);//-&gt;&lt;Buffer 48 37 4b 64 bc&gt;  </div><div class="line">buf1.fill(0);  </div><div class="line">console.log(buf1);//-&gt;&lt;Buffer 00 00 00 00 00&gt;</div></pre></td></tr></table></figure><h2 id="buffer解码"><a href="#buffer解码" class="headerlink" title="buffer解码"></a>buffer解码</h2><p>使用buf.toString([encoding[, start[, end]]])方法将buffer转换成字符串，encoding指定字符编码，默认为’utf8’，start开始位置，end结束位置（不包括），目前encoding只支持’ascii,utf8,utf16le,ucs2,base64,latin1,binary,hex’，使用如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var buf = Buffer.from(&apos;hello&apos;);  </div><div class="line">console.log(buf.toString(&apos;base64&apos;));//aGVsbG8=  </div><div class="line">console.log(buf.toString(&apos;utf8&apos;));//hello  </div><div class="line">console.log(buf.toString(&apos;utf8&apos;,2,6));//llo  </div><div class="line">console.log(buf.toString(&apos;hex&apos;));//68656c6c6f</div></pre></td></tr></table></figure><h2 id="buffer拼接、复制、填充、分割"><a href="#buffer拼接、复制、填充、分割" class="headerlink" title="buffer拼接、复制、填充、分割"></a>buffer拼接、复制、填充、分割</h2><p><strong>‘填充’</strong></p><p>方法buf.fill(value[, offset[, end]][, encoding])使用指定的值填充buffer，参数offset指定填充的起始位置，end为结束位置，使用如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(Buffer.allocUnsafe(5).fill(&apos;a&apos;,0,5,&apos;base64&apos;));//&lt;Buffer 78 d3 d0 75 68&gt;  </div><div class="line">console.log(Buffer.allocUnsafe(5).fill(&apos;a&apos;,0,5,&apos;utf8&apos;));//&lt;Buffer 61 61 61 61 61&gt;  </div><div class="line">console.log(Buffer.allocUnsafe(5).fill(&apos;a&apos;).toString(&apos;utf8&apos;));//aaaaa  </div><div class="line">console.log(Buffer.allocUnsafe(5).fill(&apos;a&apos;,2,5).toString(&apos;utf8&apos;));// aaa</div></pre></td></tr></table></figure><p><strong>拼接</strong></p><p>方法Buffer.concat(list[, totalLength])将多个buffer合并在一起，并返回一个新的buffer实例，参数totalLength为指定的buffers的长度总和，如果不提供该值，函数内部会循环去获取每一个buffer的长度，然后进行拼接，因此为了速度，最好指定一个总长度，使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function bufferInjoin(buffArr)&#123;  </div><div class="line">    var len = 0;  </div><div class="line">    buffArr.forEach(function(buff,index,arr)&#123;  </div><div class="line">        len+=buff.length;  </div><div class="line">    &#125;);  </div><div class="line">    var buffer = Buffer.concat(buffArr,len);  </div><div class="line">    return buffer;  </div><div class="line">&#125;  </div><div class="line">var buff = bufferInjoin([Buffer.from(&apos;hehe&apos;),Buffer.allocUnsafe(5).fill(&apos;a&apos;)]);  </div><div class="line">console.log(buff);//&lt;Buffer 68 65 68 65 61 61 61 61 61&gt;  </div><div class="line">console.log(buff.length);//9  </div><div class="line">console.log(buff.toString());//heheaaaaa</div></pre></td></tr></table></figure><p><strong>复制</strong><br>方法buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])可以实现buf到target的复制，参数含义如下：  </p><ul><li>target，复制目标</li><li>targetStart，复制目标开始被覆盖的位置</li><li>sourceStart，复制源开始复制的位置</li><li>sourceEnd，复制源复制结束的位置</li></ul><p>使用如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const buf1 = Buffer.from(&apos;hello world!&apos;);  </div><div class="line">const buf2 = Buffer.allocUnsafe(5).fill(&apos;x&apos;);  </div><div class="line">buf1.copy(buf2,0,0,5);  </div><div class="line">console.log(buf2.toString());//hello</div></pre></td></tr></table></figure></p><p><strong>分割</strong><br>方法buf.slice([start[, end]])可以分割buffer，返回一个新的buffer，但是仍然是引用原buffer，因此改变原buffer数据，该新buffer也会跟着改变，如果参数start，end为负数，则先要加上buffer的长度再进行计算，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const buf1 = Buffer.from(&apos;hello world.&apos;);  </div><div class="line">const buf2 = buf1.slice(0);  </div><div class="line">console.log(buf2);//&lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64 2e&gt;  </div><div class="line">buf2[0] = 88;  </div><div class="line">console.log(buf1);//&lt;Buffer 58 65 6c 6c 6f 20 77 6f 72 6c 64 2e&gt;  </div><div class="line">const buf3 = buf1.slice(-6,-1);  </div><div class="line">console.log(buf3.toString());//world</div></pre></td></tr></table></figure><h2 id="buffer读写"><a href="#buffer读写" class="headerlink" title="buffer读写"></a>buffer读写</h2><blockquote><pre><code>buf.write(string[, offset[, length]][, encoding])，向buffer写入字符串</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var buf=Buffer.alloc(10);  </div><div class="line">buf.write(&quot;hello&quot;,2,7,&apos;utf8&apos;);  </div><div class="line">console.log(buf);//-&gt;&lt;Buffer 00 00 68 65 6c 6c 6f 00 00 00&gt;  </div><div class="line">console.log(buf.read());//-&gt;&lt;Buffer 00 00 68 65 6c 6c 6f 00 00 00&gt;</div></pre></td></tr></table></figure><blockquote><pre><code>buffer写操作通过write开头的写api来完成，主要有以下这些：</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">buf.write(string[, offset[, length]][, encoding])，向buffer写入字符串  </div><div class="line">buf.writeDoubleBE(value, offset[, noAssert])写入64位浮点型数字，大端对齐  </div><div class="line">buf.writeDoubleLE(value, offset[, noAssert])，写入64位浮点型数字，小端对齐  </div><div class="line">buf.writeFloatBE(value, offset[, noAssert])，写入32位浮点型数字，大端对齐  </div><div class="line">buf.writeFloatLE(value, offset[, noAssert])，写入32位浮点型数字，小端对齐  </div><div class="line">buf.writeInt8(value, offset[, noAssert])，写入有符号8位整型数字  </div><div class="line">buf.writeInt16BE(value, offset[, noAssert])，写入有符号16位整型数字，大端对齐  </div><div class="line">buf.writeInt16LE(value, offset[, noAssert])，写入有符号16位整型数字，小端对齐  </div><div class="line">buf.writeInt32BE(value, offset[, noAssert])，写入有符号32位整型数字，大端对齐  </div><div class="line">buf.writeInt32LE(value, offset[, noAssert])，写入有符号32位整型数字，小端对齐  </div><div class="line">buf.writeIntBE(value, offset, byteLength[, noAssert])，以下便不再累述  </div><div class="line">buf.writeIntLE(value, offset, byteLength[, noAssert])  </div><div class="line">buf.writeUInt8(value, offset[, noAssert])  </div><div class="line">buf.writeUInt16BE(value, offset[, noAssert])  </div><div class="line">buf.writeUInt16LE(value, offset[, noAssert])  </div><div class="line">buf.writeUInt32BE(value, offset[, noAssert])  </div><div class="line">buf.writeUInt32LE(value, offset[, noAssert])  </div><div class="line">buf.writeUIntBE(value, offset, byteLength[, noAssert])  </div><div class="line">buf.writeUIntLE(value, offset, byteLength[, noAssert])</div></pre></td></tr></table></figure><blockquote><pre><code>buffer写操作通过read开头的写api来完成，主要有以下这些：</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">buf.readDoubleBE(offset[, noAssert])  </div><div class="line">buf.readDoubleLE(offset[, noAssert])  </div><div class="line">buf.readFloatBE(offset[, noAssert])   </div><div class="line">buf.readFloatLE(offset[, noAssert])  </div><div class="line">buf.readInt8(offset[, noAssert])  </div><div class="line">buf.readInt16BE(offset[, noAssert])  </div><div class="line">buf.readInt16LE(offset[, noAssert])  </div><div class="line">buf.readInt32BE(offset[, noAssert])  </div><div class="line">buf.readInt32LE(offset[, noAssert])  </div><div class="line">buf.readIntBE(offset, byteLength[, noAssert])  </div><div class="line">buf.readIntLE(offset, byteLength[, noAssert])  </div><div class="line">buf.readUInt8(offset[, noAssert])  </div><div class="line">buf.readUInt16BE(offset[, noAssert])  </div><div class="line">buf.readUInt16LE(offset[, noAssert])  </div><div class="line">buf.readUInt32BE(offset[, noAssert])  </div><div class="line">buf.readUInt32LE(offset[, noAssert])  </div><div class="line">buf.readUIntBE(offset, byteLength[, noAssert])  </div><div class="line">buf.readUIntLE(offset, byteLength[, noAssert])</div></pre></td></tr></table></figure><p>使用如下所示,以32无符号整型为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const buf = Buffer.allocUnsafe(8);   </div><div class="line">buf.writeUInt32BE(0x12345678,0);  </div><div class="line">console.log(buf);//-&gt;&lt;Buffer 12 34 56 78 51 00 00 00&gt;  </div><div class="line">const data = buf.readUInt32BE(0);  </div><div class="line">console.log(data.toString(16));//-&gt;12345678</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Buffer 类是一个全局变量类型，用来直接处理2进制数据的，JS语言自身只有字符串数据类型，没有二进制数据类型，而在处理TCP和文件流的时候，必须要处理二进制数据，NodeJS提供Buffer对象来对二进制数据的操作。&lt;br&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>events模块</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/19/events%E6%A8%A1%E5%9D%97/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/19/events模块/</id>
    <published>2017-11-19T00:14:02.335Z</published>
    <updated>2017-11-19T02:14:56.803Z</updated>
    
    <content type="html"><![CDATA[<p>Nodejs的大部分核心API都是基于异步事件驱动设计的，所有可以分发事件的对象都是EventEmitter类的实例。<br><a id="more"></a></p><h2 id="监听和执行"><a href="#监听和执行" class="headerlink" title="监听和执行"></a>监听和执行</h2><p>EventEmitter实例可以使用on或addListener监听事件，当触发事件的时候，用emit()方法来执行on或addListener里面绑定的方法。看下面代码；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var EventEmitter=require(&apos;events&apos;);  </div><div class="line">var util=require(&apos;util&apos;);  </div><div class="line">function Bell(name)&#123;  </div><div class="line">    this.name=name;  </div><div class="line">&#125;  </div><div class="line">util.inherits(Bell,EventEmitter); //-&gt;Bell继承EventEmitter类  </div><div class="line">var jingleBell=new Bell(&apos;jingle&apos;);  </div><div class="line">jingleBell.on(&apos;ring&apos;,function()&#123;  </div><div class="line">    console.log(&apos;你好世界&apos;);  </div><div class="line">&#125;);  </div><div class="line">jingleBell.addListener(&apos;drop&apos;,drop);  </div><div class="line">function drop() &#123;  </div><div class="line">    console.log(&apos;你上天吧&apos;);  </div><div class="line">&#125;  </div><div class="line">jingleBell.emit(&apos;ring&apos;);//-&gt;你好世界   </div><div class="line">jingleBell.emit(&apos;drop&apos;);//-&gt;你上天吧</div></pre></td></tr></table></figure><h2 id="通过emit向监听函数里面传递参数"><a href="#通过emit向监听函数里面传递参数" class="headerlink" title="通过emit向监听函数里面传递参数"></a>通过emit向监听函数里面传递参数</h2><p>看下面这段代码；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var EventEmitter=require(&apos;events&apos;);  </div><div class="line">var util=require(&apos;util&apos;);  </div><div class="line">function Bell(name)&#123;  </div><div class="line">    this.name=name;  </div><div class="line">&#125;  </div><div class="line">util.inherits(Bell,EventEmitter);  </div><div class="line">var jingleBell=new Bell(&apos;jingle&apos;);  </div><div class="line">jingleBell.on(&apos;ring&apos;,function(who,position)&#123;  </div><div class="line">    console.log(who+&apos;你好世界&apos;+position);  </div><div class="line">&#125;);  </div><div class="line">jingleBell.addListener(&apos;drop&apos;,drop);  </div><div class="line">function drop(who) &#123;  </div><div class="line">    console.log(who+&apos;你上天吧&apos;);  </div><div class="line">&#125;  </div><div class="line">jingleBell.emit(&apos;ring&apos;,&quot;哈哈&quot;,&quot;中国&quot;);//-&gt;哈哈你好世界中国  </div><div class="line">jingleBell.emit(&apos;drop&apos;,&apos;小明&apos;);//-&gt;小明你上天吧</div></pre></td></tr></table></figure><blockquote><pre><code>通过上面代码可以看出，emit后面可以向监听函数里面传递参数；</code></pre></blockquote><h2 id="一次性事件监听"><a href="#一次性事件监听" class="headerlink" title="一次性事件监听"></a>一次性事件监听</h2><p>EventEmiter可以使用once监听某个事件，则该事件处理程序只会触发一次，之后emit该事件都会被忽略，因为监听程序被注销了，用代码验证如下；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var EventEmitter=require(&apos;events&apos;);  </div><div class="line">var util=require(&apos;util&apos;);  </div><div class="line">    this.name=name;  </div><div class="line">&#125;  </div><div class="line">util.inherits(Bell,EventEmitter);  </div><div class="line">var jingleBell=new Bell(&apos;jingle&apos;);  </div><div class="line">jingleBell.once(&apos;ring&apos;,function(who,position)&#123;  </div><div class="line">    console.log(who+&apos;你好世界&apos;+position);  </div><div class="line">&#125;);  </div><div class="line">jingleBell.addListener(&apos;drop&apos;,drop);  </div><div class="line">function drop(who) &#123;  </div><div class="line">    console.log(who+&apos;你上天吧&apos;);  </div><div class="line">&#125;  </div><div class="line">jingleBell.emit(&apos;ring&apos;,&quot;哈哈&quot;,&quot;中国&quot;);  </div><div class="line">jingleBell.emit(&apos;ring&apos;,&quot;哈哈&quot;,&quot;美国&quot;);  </div><div class="line">jingleBell.emit(&apos;drop&apos;,&apos;校长&apos;);  </div><div class="line">jingleBell.emit(&apos;drop&apos;,&quot;同学&quot;);</div></pre></td></tr></table></figure><p>最后输出结果如图所示；</p><p><img src="http://oyh928sxz.bkt.clouddn.com/once%E4%BA%8B%E4%BB%B6.png" alt=""></p><h2 id="移除事件绑定"><a href="#移除事件绑定" class="headerlink" title="移除事件绑定"></a>移除事件绑定</h2><p>类似DOM事件监听，EventEmiter也可以移除事件绑定，利用removeListener(eventName,listener)方法解除某个事件的绑定，因此回调函数listener必须是实名函数，不能是匿名函数，要不然找不到该函数，就不能移除，因为函数是引用型类型，就算函数体是一样，也不是同一个函数；用代码验证；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ar EventEmitter=require(&apos;events&apos;);  </div><div class="line">var util=require(&apos;util&apos;);  </div><div class="line">function Bell(name)&#123;  </div><div class="line">    this.name=name;  </div><div class="line">&#125;  </div><div class="line">util.inherits(Bell,EventEmitter);  </div><div class="line">var jingleBell=new Bell(&apos;jingle&apos;);  </div><div class="line">jingleBell.on(&apos;ring&apos;,function(who,position)&#123;  </div><div class="line">    console.log(who+&apos;你好世界&apos;+position);  </div><div class="line">&#125;);  </div><div class="line">jingleBell.removeListener(&apos;ring&apos;,function(who,position)&#123;  </div><div class="line">    console.log(who+&apos;你好世界&apos;+position);  </div><div class="line">&#125;);  </div><div class="line">jingleBell.addListener(&apos;drop&apos;,drop);  </div><div class="line">jingleBell.removeListener(&apos;drop&apos;,drop);  </div><div class="line">function drop(who) &#123;  </div><div class="line">    console.log(who+&apos;你上天吧&apos;);  </div><div class="line">&#125;  </div><div class="line">jingleBell.emit(&apos;ring&apos;,&quot;哈哈&quot;,&quot;中国&quot;);//-&gt;控制台输出&quot;哈哈你好世界中国&quot;  </div><div class="line">jingleBell.emit(&apos;drop&apos;,&apos;校长&apos;);//-&gt;控制台什么都没有输出</div></pre></td></tr></table></figure><blockquote><pre><code>通过上面的代码可以得出结论在移除事件绑定的时候必须要是实名函数；</code></pre></blockquote><h2 id="获取事件监听数量和监听函数"><a href="#获取事件监听数量和监听函数" class="headerlink" title="获取事件监听数量和监听函数"></a>获取事件监听数量和监听函数</h2><blockquote><pre><code>用listenerCount（事件类型）方法可以得出某种事件类型所监听函数的数量，用listeners（事件类型）方法可以得到该事件类型监听的所有函数。</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var EventEmitter=require(&apos;events&apos;);  </div><div class="line">var util=require(&apos;util&apos;);  </div><div class="line">function Bell(name)&#123;  </div><div class="line">    this.name=name;  </div><div class="line">&#125;  </div><div class="line">util.inherits(Bell,EventEmitter);  </div><div class="line">var jingleBell=new Bell(&apos;jingle&apos;);  </div><div class="line">jingleBell.on(&apos;ring&apos;,function(who,position)&#123;  </div><div class="line">    console.log(who+&apos;你好世界&apos;+position);  </div><div class="line">&#125;);  </div><div class="line">jingleBell.on(&apos;ring&apos;,fly);  </div><div class="line">function fly()&#123;&#125;  </div><div class="line">console.log(&quot;EventEmitter实例的ring事件绑定了%d个回调函数&quot;,jingleBell.listenerCount(&apos;ring&apos;));  </div><div class="line">console.log(&quot;他们是：&quot;+jingleBell.listeners(&apos;ring&apos;));</div></pre></td></tr></table></figure><p>执行结果如图所示：<br><img src="http://oyh928sxz.bkt.clouddn.com/%E7%9B%91%E5%90%AC%E6%95%B0%E5%92%8C%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0.png" alt=""></p><h2 id="获取和设置最大监听数量"><a href="#获取和设置最大监听数量" class="headerlink" title="获取和设置最大监听数量"></a>获取和设置最大监听数量</h2><p>nodejs对同一事件的监听数量建议不宜超过10个，这个可以查看EventEmitter.defaultMaxListeners属性便可得知，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var EventEmitter=require(&apos;events&apos;);     </div><div class="line">console.log(EventEmitter.defaultMaxListeners);  //-&gt;10</div></pre></td></tr></table></figure><p>通过getMaxListeners()方法获取最大监听数量以及setMaxListeners(n)方法设置最大监听数量,代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var EventEmitter=require(&apos;events&apos;);  </div><div class="line">var eve=new EventEmitter();  </div><div class="line">eve.setMaxListeners(5);  </div><div class="line">console.log(eve.getMaxListeners());//-&gt;5</div></pre></td></tr></table></figure><blockquote><pre><code>注意:getMaxListeners()和setMaxListeners(n)是扩展在EventEmitter类的原型上的，&gt;因此需要创建一个他的实例之后才能调用它。</code></pre></blockquote><p>下面的是setMaxListeners的源码的一部份：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) &#123;  </div><div class="line">  if (typeof n !== &apos;number&apos; || n &lt; 0 || isNaN(n))  </div><div class="line">    throw new TypeError(&apos;&quot;n&quot; argument must be a positive number&apos;);  </div><div class="line">  this._maxListeners = n;  </div><div class="line">  return this;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nodejs的大部分核心API都是基于异步事件驱动设计的，所有可以分发事件的对象都是EventEmitter类的实例。&lt;br&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>process.nextTick、setTimeout、setImmediate、异步ID的优先级问题</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/18/process.nextTick%E3%80%81setTimeout%E3%80%81setImmediate%E3%80%81%E5%BC%82%E6%AD%A5ID%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/18/process.nextTick、setTimeout、setImmediate、异步ID的优先级问题/</id>
    <published>2017-11-18T11:06:42.373Z</published>
    <updated>2017-11-18T11:12:47.295Z</updated>
    
    <content type="html"><![CDATA[<p>上述的几种方法里面传递的函数都是异步执行的，但是他们执行的时候是有顺序的。<br><a id="more"></a></p><p><strong>process.nextTick(callback)</strong><br>功能：在事件循环的下一次循环中调用 callback 回调函数。效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时；与setTimeout(interval, 0) 函数的功能类似，但它的效率高多了。</p><p>通过下面的代码来比较它们的上述几种情况的优先级；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var fs=require(&apos;fs&apos;);  </div><div class="line">fs.readFile(&apos;1.js&apos;,function(err,data)&#123;  </div><div class="line">    console.log(&quot;a:  readFile&quot;)  </div><div class="line">&#125;);  </div><div class="line">console.log(&apos;a客人&apos;);  </div><div class="line">setTimeout(function () &#123;  </div><div class="line">    console.log(&apos;a:  setTimeout&apos;);  </div><div class="line">&#125;,0);  </div><div class="line">process.nextTick(function () &#123;  </div><div class="line">    console.log(&apos;a:  nextTick1&apos;);  </div><div class="line">&#125;);  </div><div class="line">setImmediate(function () &#123;  </div><div class="line">    console.log(&apos;a:  setImmediate&apos;);  </div><div class="line">&#125;);  </div><div class="line">console.log(&apos;b厨师&apos;);  </div><div class="line">console.log(&apos;c厨师&apos;);</div></pre></td></tr></table></figure><p>最后在控制台中输出结果如图所示：<br><img src="http://oyh928sxz.bkt.clouddn.com/%E4%BC%98%E5%85%88%E7%BA%A71.png" alt=""></p><blockquote><pre><code>得出简单的结论:他们的优先级顺序是nexttick&gt;setTimeout&gt;setImmediate&gt;异步IO</code></pre></blockquote><p>但是这里还是不能够得出看出直接比较出nexttick和setTimeout的优先级顺序，于是看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var fs=require(&apos;fs&apos;);  </div><div class="line">fs.readFile(&apos;1.js&apos;,function(err,data)&#123;  </div><div class="line">    console.log(&quot;a:  readFile&quot;)  </div><div class="line">&#125;);  </div><div class="line">console.log(&apos;a客人&apos;);  </div><div class="line">setTimeout(function () &#123;  </div><div class="line">    console.log(&apos;a:  setTimeout&apos;);  </div><div class="line">&#125;,0);  </div><div class="line">process.nextTick(function () &#123;  </div><div class="line">    console.log(&apos;a:  nextTick1&apos;);    </div><div class="line">process.nextTick(function () &#123;  </div><div class="line">        console.log(&apos;a:  nextTick2&apos;);  </div><div class="line">    &#125;);  </div><div class="line">    process.nextTick(function () &#123;  </div><div class="line">        console.log(&apos;a:  nextTick3&apos;);  </div><div class="line">    &#125;);  </div><div class="line">&#125;);    </div><div class="line">setImmediate(function () &#123;  </div><div class="line">    console.log(&apos;a:  setImmediate&apos;);  </div><div class="line">&#125;);  </div><div class="line">console.log(&apos;b厨师&apos;);  </div><div class="line">console.log(&apos;c厨师&apos;);</div></pre></td></tr></table></figure><p>最后输出的结果如图所示：</p><p><img src="http://oyh928sxz.bkt.clouddn.com/%E4%BC%98%E5%85%88%E7%BA%A72.png" alt=""></p><blockquote><pre><code>得出结论:他们的优先级顺序是nexttick&gt;setTimeout&gt;setImmediate&gt;异步IO</code></pre></blockquote><p>注意：nexttick相当于是放在当前队列的最后一个执行，而setTimeout、setImmediate、异步IO都是在另一个队列中执行，因此nexttick永远比他们先执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上述的几种方法里面传递的函数都是异步执行的，但是他们执行的时候是有顺序的。&lt;br&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>node中this</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/18/node%E4%B8%ADthis/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/18/node中this/</id>
    <published>2017-11-18T08:49:43.058Z</published>
    <updated>2017-11-18T14:25:28.398Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs中的this和在浏览器中javascript中的this是不一样的。<br><a id="more"></a><br><strong>在全局中的this</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(this); //-&gt;&#123;&#125;  </div><div class="line">this.num =1;  </div><div class="line">console.log(this.num); //-&gt;1  </div><div class="line">console.log(global.num); //-&gt;undefined</div></pre></td></tr></table></figure></p><p>全局中的this默认是一个空对象。并且在全局中this与global对象没有任何的关系。那么全局中的this到底是什么了。看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name=&quot;aba&quot;;    </div><div class="line">exports.name=name;   </div><div class="line">console.log(this);//-&gt;this-&gt;&#123; name: &apos;aba&apos; &#125;</div></pre></td></tr></table></figure><blockquote><pre><code>全局中this会指向module.exports。  </code></pre></blockquote><p><strong>在函数中的this</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;  </div><div class="line">  this.num = 1;</div><div class="line">&#125;  </div><div class="line">fn();  </div><div class="line">console.log(this); /-&gt;&#123;&#125;    </div><div class="line">console.log(this.num); //-&gt;undefined    </div><div class="line">console.log(global.num); //-&gt;1</div></pre></td></tr></table></figure><blockquote><pre><code>总结:在函数中this指向的是global对象，和全局中的this不是同一个对象，简单来说，你在函  数中通过this定义的变量就是相当于给global添加了一个属性，此时与全局中的this已经没有关系了。但是可以用call、apply、bind方法改变this指向。</code></pre></blockquote><p>如果还对这个结论表示怀疑，那么下面这段代码足以证明:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;   </div><div class="line">  function fn2()&#123;  </div><div class="line">    this.age = 18;   </div><div class="line">  &#125;  </div><div class="line">  fn2();  </div><div class="line">  console.log(this); //-&gt;global  </div><div class="line">  console.log(this.age); //-&gt;18  </div><div class="line">  console.log(global.age); //-&gt;18  </div><div class="line">&#125;</div><div class="line">fn();</div></pre></td></tr></table></figure><blockquote><pre><code>所以总结出:函数中this指向就是global</code></pre></blockquote><p><strong>构造函数中的this</strong></p><p>看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;  </div><div class="line">  this.num = 100;  </div><div class="line">&#125;  </div><div class="line">var fn = new Fn();  </div><div class="line">console.log(fn.num); //-&gt;100  </div><div class="line">console.log(global.num); //-&gt;undefined</div></pre></td></tr></table></figure><blockquote><pre><code>在构造函数中this指向的是它的实例，而不是global。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs中的this和在浏览器中javascript中的this是不一样的。&lt;br&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式从基础到实战</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/12/正则表达式从基础到实战/</id>
    <published>2017-11-12T14:32:11.573Z</published>
    <updated>2017-11-12T14:51:25.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是正则？"><a href="#什么是正则？" class="headerlink" title="什么是正则？"></a>什么是正则？</h2><blockquote><p>   正则就是一个规则，用来处理字符串的规则<br><a id="more"></a><br>   1、正则匹配<br>编写一个规则，验证某个字符串是否符合这个规则，正则匹配使用的是 test 方法<br>2、正则捕获<br>编写一个规则，在一个字符串中把符合规则的内容都获取到，正则捕获使用的方法：正则的exec方法、字符串中的split、replace、match等方法都支持正则</p></blockquote><h2 id="正则的元字符和修饰符"><a href="#正则的元字符和修饰符" class="headerlink" title="正则的元字符和修饰符"></a>正则的元字符和修饰符</h2><blockquote><pre><code>修饰符`g(global)：全局匹配i(ignoreCase)：忽略大小写匹配m(multiline)：多行匹配`元字符`[量词元字符]+：让前面的元字符出现一到多次?：出现零到一次*：出现零到多次{n}：出现n次{n,}：出现n到多次{n,m}：出现n到m次[特殊意义的元字符]\：转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义字符转换为普通的字符）.：除了\n（换行符）以外的任意字符\d：匹配一个0~9之间的数字   \D：匹配任意一个非0~9之间的数字（大写字母和小写字母的组合正好是反向的）\w：匹配一个 `0~9或字母或_` 之间的字符\s：匹配一个任意空白字符\b：匹配一个边界符x|y：匹配x或者y中的一个[a-z]：匹配a-z中的任意一个字符[^a-z]：和上面的相反，匹配任意一个非a-z的字符[xyz]：匹配x或者y或者z中的一个字符[^xyz]：匹配除了xyz以外的任意字符()：正则的小分组，匹配一个小分组（小分组可以理解为大正则中的一个小正则）^：以某一个元字符开始$：以某一个元字符结束?:：只匹配不捕获?=：正向预查?!：负向预查</code></pre></blockquote><h2 id="元字符详细解读"><a href="#元字符详细解读" class="headerlink" title="元字符详细解读"></a>元字符详细解读</h2><p><strong>^ $</strong></p><blockquote><pre><code>var reg = /\d+/; //=&gt;包含某某某即可，这里说明包含1到多个数字即可var str = &apos;珠峰2017培训2018&apos;;reg.test(str) =&gt;truereg=/^\d+/;reg.test(str) =&gt;falsereg=/^\d+$/;//=&gt;只能是某某某的,这里说明只能是1到多个数字reg.test(&apos;2017&apos;); =&gt;truereg.test(&apos;2017珠峰2018&apos;); =&gt;falsereg.test(&apos;2&apos;); =&gt;true ^或者$只是一个修饰或者声明，不会占据字符串的位置</code></pre></blockquote><p>\</p><blockquote><pre><code>var reg = /^2.3$/;reg.test(&apos;2.3&apos;); =&gt;truereg.test(&apos;2+3&apos;); =&gt;true 点在正则中的意思：匹配除了\n以外的任意字符，而不是单纯的小数点reg = /^2\.3$/;reg.test(&apos;2.3&apos;); =&gt;truereg.test(&apos;2+3&apos;); =&gt;false 使用转义字符把点转换为本身小数点的意思</code></pre></blockquote><p><strong>x|y</strong></p><blockquote><pre><code>var reg = /^18|19$/;//=&gt;18 19 189 119 819 181 1819 ... 很多都符合这个规则/* * 18或者19 * 以1开头 以9结尾 中间是8或者1  * 以18开头或者以19结尾即可  =&gt;&apos;18珠峰&apos; &apos;珠峰19&apos;... */var reg = /^(18|19)$/;//=&gt;此时只有18或者19符合我们的规则了</code></pre></blockquote><p><strong>( )</strong></p><blockquote><pre><code>正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体）；在正则中我们可以使用小括号改变一些默认的优先级；    小分组还有第二个作用：分组引用  小分组的第三个作用：分组捕获       //=&gt;分组引用：\1 或者 \2 ...出现和第N个分组一模一样的内容var reg = /^([a-z])([a-z])\2([a-z])$/;//=&gt; 符合的字符串：foot、book、week、attr、http... </code></pre></blockquote><p><strong>[ ]</strong></p><blockquote><pre><code>[xyz] [^xyz] [a-z] [^a-z]//=&gt;\w：数组字母下划线中的任意一个字符</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> var reg = /^[a-zA-Z0-9_]$/; //=&gt;等价于\w  </div><div class="line"> var reg = /^[.?+&amp;]+$/; //=&gt;里面的四个元字符都是本身含义，例如：点就是小数点了  </div><div class="line">不是所谓的任意字符…  </div><div class="line"> //=&gt;需求：描述样式类名的规则（数字、字母、下划线、-），并且不能以-开头  </div><div class="line"> //var reg = /^[\w-]+  </div><div class="line"> //=&gt;没有处理以-开头的情况  </div><div class="line">var reg = /^\w[\w-]*$/;</div></pre></td></tr></table></figure><p><strong>例子</strong></p><blockquote><pre><code>//=&gt;需求：验证18~65之间的年龄//var reg = /^[18-65]$/; //=&gt;1或者8~6或者5中的任意一个字符,中括号中出现的18不是数字18，而是1或者8，当前正则是非法的：因为不能设置8~6这种范围//=&gt;分三个阶段处理：// 18 或者 19   /(18|19)/// 20 ~ 59     /([2-5]\d)/// 60 ~ 65     /(6[0-5])/var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/; </code></pre></blockquote><h2 id="常用的正则表达式编写"><a href="#常用的正则表达式编写" class="headerlink" title="常用的正则表达式编写"></a>常用的正则表达式编写</h2><p><strong>验证是否为有效数字</strong></p><ul><li>可能是正数，可能是负数  12 -12</li><li>整数或者小数 0 12 0.2 12.5 -12.3</li><li>只要出现小数点，后面至少要跟一位数字</li><li>小数点前面必须有数字</li><li>-? 负号可有可无</li><li>(\d|([1-9]\d+))</li><li>\d 一位数可以是任何值</li><li>([1-9]\d+) 多位数不能以零开头</li><li>(.\d+)? 小数部分可有可无，有的话点后面必须跟一位数字</li></ul><blockquote><pre><code>var reg = /^-?(\d|([1-9]\d+))(\.\d+)?$/;</code></pre></blockquote><p><strong>手机号码</strong></p><ul><li>11位数字</li><li>1开头<blockquote><pre><code>var reg = /^1\d{10}$/;</code></pre></blockquote></li></ul><p><strong>用户名：真实姓名</strong></p><ul><li>//=&gt;/^[\u4E00-\u9FA5]$/ 中文汉字的正则<blockquote><pre><code>var reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10})?$/;</code></pre></blockquote></li></ul><p><strong>邮箱</strong></p><blockquote><pre><code>var reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;</code></pre></blockquote><ul><li>以数字字母下划线开头</li><li>@前面可以是 数字、字母、下划线、-、. 这些符号</li><li>不能把 -和. 连续出现，出现一次后面必须跟数字字母下划线</li><li></li><li>@后面的部分支持</li><li>企业邮箱</li><li>.com.cn 多域名情况</li><li>/// [A-Za-z0-9]+// ((.|-)[A-Za-z0-9]+)*// .[A-Za-z0-9]+// @163.com.cn// @zhu-feng-pei-xun.com.cn</li></ul><p><strong>身份证号码</strong></p><ul><li>18位</li><li>前17位必须是数字</li><li>最后一位可以是数字或者X(X代表数字10)  </li><li>130828199012040617</li><li>前六位：省市县 130828</li><li>接下来八位 出生年+月+日</li><li>倒数第二位数字 奇数代表男 偶数代表女</li><li>//=&gt;这样写不仅可以匹配，而且以后捕获的时候，不仅可以把大正则匹配的结果捕获到，里面每一个小分组(小正则)匹配的结果也可以单独的捕获到 “分组捕获”//=&gt;年 1950~2017//=&gt;第一段 1950~1999//=&gt;第二段 2000~2017//==&gt; 00~09//==&gt; 10~17//  /^((19[5-9]\d)|(20((0\d)|(1[0-7]))))$/</li></ul><blockquote><pre><code>var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;</code></pre></blockquote><h2 id="正则捕获"><a href="#正则捕获" class="headerlink" title="正则捕获"></a>正则捕获</h2><blockquote><p>把当前字符串中符合正则的字符捕获到RegExp.prototype：exec 实现正则捕获的方法</p><pre><code>var str = &apos;珠峰培训2017扬帆起航2018&apos;;var reg = /\d+/;</code></pre></blockquote><ul><li>reg.exec(str);</li><li>当正则捕获的时候：</li><li>1、先去验证当前字符串和正则是否匹配，如果不匹配返回的结果是null（没有捕获到任何的内容）</li><li>2、如果匹配，从字符串最左边开始，向右查找到匹配的内容，并且把匹配的内容返回 </li><li>exec捕获到结果的格式：</li><li>-&gt; 获取的结果是一个数组</li><li>-&gt; 数组中的第一项是当前本次大正则在字符串中匹配到的结果</li><li>-&gt; index：记录了当前本次捕获到结果的起始索引</li><li>-&gt; input：当前正则操作的原始字符串</li><li>-&gt; 如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组，本次匹配到的结果（通过exec可以把分组中的内容捕获到）</li><li>执行一次exec只能把符合正则规则条件中的一个内容捕获都，如果还有其它符合规则的，需要在次执行exec才有可能捕获到</li></ul><p><strong>正则捕获存在懒惰性</strong></p><blockquote><p>   执行一次exec捕获到第一个符合规则的内容，第二次执行exec，捕获到的依然是第一个匹配的内容，后面匹配的内容不管执行多少次exec都无法捕获到</p><p>   解决正则捕获的懒惰性：<br>在正则的末尾加修饰符g（全局匹配）</p></blockquote><ul><li>//=&gt;正则为什么会存在懒惰性?/*</li><li>正则本身有一个属性：lastIndex（下一次正则在字符串中匹配查找的开始索引）</li><li>默认值：0，从字符串第一个字符开始查找匹配的内容</li><li>默认不管指定多少遍exec方法,正则的lastIndex值都不会变（也就是第二次以后查找的时候还是从第一个字符找，所以找到的结果永远都是第一个匹配的内容）</li><li>而且当我们手动把 lastIndex 进行修改的时候，不会起到任何的作用</li><li>///=&gt;为什么加修饰符g就解决了懒惰性?/* </li><li>加了修饰符g，每一次exec结束后，浏览器默认会把lastIndex值进行修改，下一次从上一次结束的位置开始查找，所以可以得到后面匹配的内容了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var reg = /\d+/g;  </div><div class="line">var str = &apos;珠峰培训2017杨帆起航2018&apos;;  </div><div class="line">console.log(reg.lastIndex);//=&gt;0  </div><div class="line">console.log(reg.exec(str)[0]);//=&gt;&apos;2017&apos;  </div><div class="line">console.log(reg.lastIndex);//=&gt;8  </div><div class="line">console.log(reg.exec(str)[0]);//=&gt;&apos;2018&apos;  </div><div class="line">console.log(reg.lastIndex);//=&gt;16  </div><div class="line">console.log(reg.exec(str));//=&gt;null  </div><div class="line">console.log(reg.lastIndex);//=&gt;0  </div><div class="line">console.log(reg.exec(str)[0]);//=&gt;&apos;2017&apos;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">exec有自己的局限性：执行一次exec只能捕获到一个和正则匹配的结果（即使加了修饰符g），如果需要都捕获到，我们需要执行N次exec方法才可以</div><div class="line"></div><div class="line">下面封装的myExecAll方法，目的是执行一次这个方法，可以把当前正则匹配到的全部内容都捕获到</div><div class="line">```javascript  </div><div class="line">RegExp.prototype.myExecAll = function myExecAll() &#123;  </div><div class="line">var str = arguments[0] || ‘’,  </div><div class="line">result = [];  </div><div class="line">//=&gt;首先判断THIS是否加了全局修饰符G,如果没有加,为了防止下面执行出现死循环,我们只让其执行一次EXEC即可,把执行一次的结果直接的返回  </div><div class="line">if (!this.global) &#123;  </div><div class="line">return this.exec(str);  </div><div class="line">&#125;  </div><div class="line">var ary = this.exec(str);  </div><div class="line">while (ary) &#123;  </div><div class="line">result.push(ary[0]);  </div><div class="line">ary = this.exec(str);  </div><div class="line">&#125;  </div><div class="line">return result;  </div><div class="line">&#125;;  </div><div class="line">var reg = /\d+/g;  </div><div class="line">console.log(reg.myExecAll(‘珠峰2017培训2018杨帆2019起航2020’));</div></pre></td></tr></table></figure><h2 id="使用字符串方法match实现捕获"><a href="#使用字符串方法match实现捕获" class="headerlink" title="使用字符串方法match实现捕获"></a>使用字符串方法match实现捕获</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var reg = /\d+/g;  </div><div class="line">var str = &apos;珠峰2017培训2018杨帆2019起航2020&apos;;  </div><div class="line">str.match(reg); //=&gt;[&quot;2017&quot;, &quot;2018&quot;, &quot;2019&quot;, &quot;2020&quot;]</div></pre></td></tr></table></figure><blockquote><p>使用字符串match捕获：<br>1、如果正则加了修饰符g，执行一次match会把所有正则匹配的内容捕获到<br>2、如果没有加修饰符g，执行一次match只能把第一个匹配的结果捕获到<br>局限性：<br>在加了修饰符g的情况下，执行match方法只能把大正则匹配的内容捕获到，对于小分组捕获的内容方法给其自动忽略了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var str = ‘my name is &#123;0&#125;,i am &#123;1&#125; years old~，2017’;  </div><div class="line">//=&gt;需求：把&#123;n&#125;整体捕获到，而且还要把括号中的数字也获取到  </div><div class="line">var reg = /&#123;(\d+)&#125;/g;  </div><div class="line">// str.match(reg);//=&gt;[“&#123;0&#125;”, “&#123;1&#125;”]  </div><div class="line">//=&gt;想要获取小分组中的内容，我们只能使用EXEC处理了  </div><div class="line">function fn(reg,str)&#123;  </div><div class="line">var ary=reg.exec(str),  </div><div class="line">result=[];  </div><div class="line">while(ary)&#123;  </div><div class="line">result.push(ary);  </div><div class="line">ary=reg.exec(str);  </div><div class="line">&#125;  </div><div class="line">return result;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="使用test也可以实现正则的捕获"><a href="#使用test也可以实现正则的捕获" class="headerlink" title="使用test也可以实现正则的捕获"></a>使用test也可以实现正则的捕获</h2><p>不管是正则的匹配还是正则的捕获，在处理时候的原理是没区别的：从字符串的第一个字符向后查找，找到符合正则规则的字符，如果可以找到，说明正则和字符串匹配（test检测返回true、exec捕获返回捕获的内容），如果找到末尾都没有匹配的，说明正则和字符串不匹配（test检测返回false、exec捕获返回null）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//=&gt;如果当前字符串和正则是匹配的，我们进行捕获  </div><div class="line">var reg = /&#123;(\d+)&#125;/g;  </div><div class="line">var str = ‘my name is &#123;0&#125;~~’;  </div><div class="line">if (reg.test(str)) &#123;  </div><div class="line">//=&gt;reg.test(str) : true  </div><div class="line">console.log(reg.lastIndex);//=&gt;14  </div><div class="line">console.log(reg.exec(str));//=&gt;null  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">var reg = /&#123;(\d+)&#125;/;  </div><div class="line">var str = ‘my name is &#123;0&#125;~~’;  </div><div class="line">if (reg.test(str)) &#123;  </div><div class="line">//=&gt;reg.test(str) : true  </div><div class="line">console.log(reg.lastIndex);//=&gt;0  </div><div class="line">console.log(reg.exec(str));//=&gt;[‘&#123;0&#125;’,’0’…]  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用test不仅可以找到匹配的内容，也能像exec一样把找到的内容获取到<br>test返回结果是 true/false，所以靠返回结果肯定不行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var reg = /&#123;(\d+)&#125;/g;  </div><div class="line">var str = ‘my name is &#123;0&#125;,i am &#123;1&#125; years old‘;  </div><div class="line">reg.test(str);//=&gt;true  </div><div class="line">console.log(RegExp.$1);//=&gt;0 获取到当前本次匹配内容中第一个小分组捕获的内容  </div><div class="line"></div><div class="line">reg.test(str);//=&gt;true  </div><div class="line">console.log(RegExp.$1);//=&gt;1 TEST可以实现捕获,但是每一次只能获取到当前本次匹配结果中,第N个分组捕获的内容 $1第一个分组 $2第二个分组 …</div></pre></td></tr></table></figure><h2 id="所有支持正则的方法都可以实现正则的捕获（一般都是字符串方法）"><a href="#所有支持正则的方法都可以实现正则的捕获（一般都是字符串方法）" class="headerlink" title="所有支持正则的方法都可以实现正则的捕获（一般都是字符串方法）"></a>所有支持正则的方法都可以实现正则的捕获（一般都是字符串方法）</h2><p>字符串中常用的支持正则的方法：match、split、replace；</p><p><strong>split</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var str = ‘name=珠峰&amp;age=8&amp;lx=teacher’;  </div><div class="line">str.split(/&amp;|=/); //=&gt;[“name”, “珠峰”, “age”, “8”, “lx”, “teacher”]  </div><div class="line">str.split(/(&amp;|=)/); //=&gt;[“name”, “=”, “珠峰”, “&amp;”, “age”, “=”, “8”, “&amp;”, “lx”, “=”, “teacher”]  </div><div class="line">//=&gt;在使用split进行字符串拆分的时候，如果正则中包含小分组，会把小分组中的内容都捕获到，放在最后的数组中  </div><div class="line">//=&gt;本案例中的小括号仅仅是为了实现 改变默认的优先级 问题，但是我们不想把分组中的内容捕获到 =&gt; “只想匹配不想捕获” 我们可以使用 (?:)   </div><div class="line">str.split(/(?:&amp;|=)/); //=&gt;[“name”, “珠峰”, “age”, “8”, “lx”, “teacher”]  </div><div class="line">//=&gt;只匹配不捕获：  </div><div class="line">//在当前一个分组中加了 ?: ，在正则检测匹配的时候，小分组可以起到自己应有的作用（例如：改变优先级…），但是在捕获的时候，遇到带?:的小分组，浏览器不会把当前这个分组中匹配的内容，单独去捕获了    </div><div class="line">var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d)(\d|X)$/;  </div><div class="line">reg.exec(‘130828199012040617’); //=&gt;[“130828199012040617”, “130828”, “1990”, “12”, “04”, “06”, “1”, “7”…]  </div><div class="line">var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(?:\d&#123;2&#125;)(\d)(?:\d|X)$/;  </div><div class="line">reg.exec(‘130828199012040617’);//=&gt; [“130828199012040617”, “130828”, “1990”, “12”, “04”, “1”…]  </div><div class="line">var reg = /^-?(\d|([1-9]\d+))(.\d+)?$/;//=&gt;计算是第几个分组的时候，我们从左向右找 ( 即可）</div></pre></td></tr></table></figure><p><strong>replace</strong></p><p>replace：字符串中原有字符的替换；str.replace(old,new)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var str = ‘珠峰2017珠峰2018’;  </div><div class="line">str = str.replace(‘珠峰’,’珠峰培训’);  </div><div class="line">str = str.replace(‘珠峰’,’珠峰培训’);  </div><div class="line">//=&gt;’珠峰培训培训2017珠峰2018’ 没有实现我们希望的效果  </div><div class="line"></div><div class="line">//=&gt;在不使用正则的情况下，执行一次replace只能替换一个原有字符，第二次执行replace，还是从字符串的开始位置查找，把最新找到的字符替换为新字符（类似于正则捕获时候的懒惰性：每一次执行都是从字符串最开始的位置查找）真实项目中，replace一般都是和正则搭配在一起使用的</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str = &apos;珠峰2017珠峰2018&apos;;        </div><div class="line">str = str.replace(/珠峰/g,&apos;珠峰培训&apos;);//=&gt;&quot;珠峰培训2017珠峰培训2018&quot;</div></pre></td></tr></table></figure><blockquote><p> replace原理：</p><p>1、当replace方法执行，第一项传递一个正则<br>正则不加g：把当前字符串中第一个和正则匹配的结果捕获到，替换成新的字符<br>正则加g：把当前字符串中所有和正则匹配的内容都分别的捕获到，而且每一次捕获，都会把当前捕获的内容替换为新字符</p><p>2、当replace方法执行，第二个参数传递的是一个函数（回调函数）<br>首先用正则到字符串中进行查找匹配，匹配到一个符合规则的，就把传递的函数执行一次<br>不仅执行这个函数，而且还把正则本次捕获的结果（和执行exec捕获的结果一样：数组、大正则匹配、小分组匹配 都有）当做实参传递给这个函数（这样就可以在函数中获取这些值：而这些值就是正则每一次捕获的结果 ）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var str = &apos;my name is &#123;0&#125;,i am &#123;1&#125; years old,i can &#123;2&#125;!&apos;;  </div><div class="line">var reg = /\&#123;(\d+)\&#125;/g;  </div><div class="line">str.replace(reg, function () &#123;      </div><div class="line">     //=&gt;传递的函数一共被执行三次  </div><div class="line">    //=&gt;console.log(arguments) 每一次匹配捕获到结果,不仅把这个方法执行了,而且还会把当前捕获的结果当做实参传递给这个函数(ARG)  </div><div class="line">    /*  </div><div class="line">     * 第一次执行函数，获取的是ARG类数组  </div><div class="line">     *  0:&apos;&#123;0&#125;&apos; 本次大正则匹配的结果  </div><div class="line">     *  1:&apos;0&apos;   本次第一个小分组匹配的结果  </div><div class="line">     *  2:11    本次大正则匹配结果在字符串中的索引 index  </div><div class="line">     *  3:&apos;my nam...&apos; 原始字符串 input  </div><div class="line">     *</div><div class="line">     * 和每一次执行exec实现捕获的结果非常类似  </div><div class="line">     */  </div><div class="line">    //return xxx;  </div><div class="line">    //=&gt;每一次执行函数，函数中RETURN的结果，都相当于把本次大正则匹配的内容替换掉（原始字符串不变）    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是正则？&quot;&gt;&lt;a href=&quot;#什么是正则？&quot; class=&quot;headerlink&quot; title=&quot;什么是正则？&quot;&gt;&lt;/a&gt;什么是正则？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;   正则就是一个规则，用来处理字符串的规则&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
      <category term="正则" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/%E6%AD%A3%E5%88%99/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
      <category term="正则" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>字符串String的常用方法</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/12/%E5%AD%97%E7%AC%A6%E4%B8%B2String%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/12/字符串String的常用方法/</id>
    <published>2017-11-12T13:14:29.594Z</published>
    <updated>2017-11-12T14:37:09.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="charAt-索引-获取指定索引位置的字符"><a href="#charAt-索引-获取指定索引位置的字符" class="headerlink" title="charAt(索引)获取指定索引位置的字符"></a>charAt(索引)获取指定索引位置的字符</h2><p>charCodeAt（索引）获取指定索引位置的字符串对应的ASCII值<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;  </div><div class="line">console.log(str.charAt(8));//-&gt;h  </div><div class="line">console.log(str.charCodeAt(8));//-&gt;104</div></pre></td></tr></table></figure></p><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p><strong>1、substr</strong><br>substr(n,m) 从索引n开始截取m个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;  </div><div class="line">console.log(str.substr(0,5));//-&gt;www.f</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;  </div><div class="line">console.log(str.substr(5,2));//-&gt;an</div></pre></td></tr></table></figure><p><strong>2、substring</strong><br>substring(n,m) 从索引n开始，找到索引m处(不包含m),将找到的字符返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;</div><div class="line">console.log(str.substring(0,5));//-&gt;www.f</div></pre></td></tr></table></figure><p><strong>3、slice</strong><br>slice(n,m) 从索引n开始，找到索引m处(不包含m),将找到的字符返回。并且slice支持以负数作为索引，原理是str.length+负数索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;  </div><div class="line">console.log(str.slice(0,5));//-&gt;www.f</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;</div><div class="line">console.log(str.slice(-5,-1));//-&gt;ng.c</div></pre></td></tr></table></figure><blockquote><pre><code>上面的这三个方法都是如果只写了一个n,没有m:代表截取到末尾位置</code></pre></blockquote><h2 id="查找字符的索引"><a href="#查找字符的索引" class="headerlink" title="查找字符的索引"></a>查找字符的索引</h2><p><strong>indexOf/lastIndexOf</strong></p><blockquote><pre><code>indexOf(字符)：获取指定字符在字符串中第一次出现的位置  lastIndexOf(字符)：获取指定字符在字符串中最后一次出现的索引位置这两个方法都是如果没有这个字符，返回的是-1，基于这个理念我们经常用这个两个方法判断字符串中是否包含某个字符,里面还可以放多个字符，必须连着包含才会输出对应索引、否则返回-1</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;  </div><div class="line">console.log(str.indexOf(&quot;.&quot;));//-&gt;3  </div><div class="line">console.log(str.lastIndexOf(&quot;.&quot;));//-&gt;16  </div><div class="line">console.log(str.indexOf(&quot;。&quot;));//-&gt;-1  </div><div class="line">console.log(str.lastIndexOf(&quot;。&quot;));//-&gt;-1  </div><div class="line">console.log(str.lastIndexOf(&quot;www。&quot;));//-&gt;-1</div></pre></td></tr></table></figure><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><blockquote><pre><code>toUpperCase:将所有字母转换为大写toLowerCase：将字母转换为小写</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;  </div><div class="line">console.log(str.toUpperCase());//-&gt;WWW.FANZHANXIANG.CN  </div><div class="line">console.log(str.toLowerCase());//-&gt;www.fanzhanxiang.cn</div></pre></td></tr></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>replace(要替换的老字符，替换的新字符)；在不使用正则的情况下，每一次调用方法只能替换一次。一般情况下替换我们都是使用正则处理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;  </div><div class="line">console.log(str.replace(&quot;.cn&quot;,&quot;.com&quot;));//-&gt;www.fanzhanxiang.com</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;   </div><div class="line">console.log(str.replace(&quot;w&quot;,&quot;W&quot;));//-&gt;Www.fanzhanxiang.cn，只替换了一次</div></pre></td></tr></table></figure><h2 id="将字符串按照指定的分隔符拆分成数组"><a href="#将字符串按照指定的分隔符拆分成数组" class="headerlink" title="将字符串按照指定的分隔符拆分成数组"></a>将字符串按照指定的分隔符拆分成数组</h2><p>split(分隔符)：将字符串按照指定的分隔符拆分成数组 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str=&apos;1+2+3+4+5+5&apos;;  </div><div class="line">console.log(str.split(&quot;+&quot;));//-&gt;[ &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;5&apos; ]  </div><div class="line">console.log(str.split(&quot;&quot;));//-&gt;[ &apos;1&apos;, &apos;+&apos;, &apos;2&apos;, &apos;+&apos;, &apos;3&apos;, &apos;+&apos;, &apos;4&apos;, &apos;+&apos;, &apos;5&apos;, &apos;+&apos;, &apos;5&apos; ]  </div><div class="line">console.log(str.split(&quot; &quot;));//-&gt;[ &apos;1+2+3+4+5+5&apos; ]</div></pre></td></tr></table></figure><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>match()方法用于从字符串中查找指定的值，本方法类似于indexOf()和lastindexOf()，不同的是它返回的是指定的值，而不是指定值在字符串中的位置。是一个数组，并且只能查找一次，索引为0的这项是查找到的值，index是这项值的索引，input是原字符串。indexOf()和lastindexOf()方法返回位置数字 如果找不到返回-1。注意区分大小写 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str=&apos;www.fanzhanxiang.cn&apos;;  </div><div class="line">console.log(str.match(&quot;w&quot;));//-&gt;[ &apos;w&apos;, index: 0, input: &apos;www.fanzhanxiang.cn&apos; ]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;charAt-索引-获取指定索引位置的字符&quot;&gt;&lt;a href=&quot;#charAt-索引-获取指定索引位置的字符&quot; class=&quot;headerlink&quot; title=&quot;charAt(索引)获取指定索引位置的字符&quot;&gt;&lt;/a&gt;charAt(索引)获取指定索引位置的字符&lt;/h2&gt;&lt;p&gt;charCodeAt（索引）获取指定索引位置的字符串对应的ASCII值&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组的常用方法</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/12/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/12/数组中的常用方法/</id>
    <published>2017-11-12T11:38:13.101Z</published>
    <updated>2017-11-12T14:37:03.334Z</updated>
    
    <content type="html"><![CDATA[<p>下面的数组的方法中都是按照下面的四个维度去详细解读：<br><a id="more"></a></p><blockquote><pre><code>1、这个数组方法的作用2、需要传那些参数3、是否有返回值、返回值是什么4、通过这个方法是否对原来的数组产生了影响。</code></pre></blockquote><h2 id="关于数组的增加、修改、删除"><a href="#关于数组的增加、修改、删除" class="headerlink" title="关于数组的增加、修改、删除"></a>关于数组的增加、修改、删除</h2><p><strong>1、push</strong></p><blockquote><pre><code>作用：向数组的末尾增加新的内容传递的参数:想要向原来数组增加的内容,而且可以传递多个值，统一向末尾增加多项返回值是:新增加后数组的长度对原来数组的影响:原来数组已经发生了改变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45];      </div><div class="line">var res=ary.push(100,200,300);</div><div class="line">console.log(res,ary);//-&gt;7 [ 12, 23, 34, 45, 100, 200, 300 ]</div></pre></td></tr></table></figure><p><strong>2、pop</strong></p><blockquote><pre><code>作用：删除数组最后一项内容传递的参数:不需要传递参数返回值是:被删除的那一项内容对原来数组的影响:原来数组已经发生了改变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45];  </div><div class="line">var res=ary.pop();  </div><div class="line">console.log(res,ary);//-&gt;45 [ 12, 23, 34 ]</div></pre></td></tr></table></figure><p><strong>3、shift</strong></p><blockquote><pre><code>作用：删除数组第一项内容传递的参数:不需要传递参数返回值是:被删除的那一项内容对原来数组的影响:原来数组已经发生了改变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45];</div><div class="line">var res=ary.shift();</div><div class="line">console.log(res,ary);//-&gt;12 [ 23, 34, 45 ]</div></pre></td></tr></table></figure><p><strong>4、unshift</strong></p><blockquote><pre><code>作用：向数组开头增加一项传递的参数:需要向数组开头增加的内容，可传递多个参数返回值是:数组的长度对原来数组的影响:原来数组已经发生了改变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45];  </div><div class="line">var res=ary.unshift(100,100,200);  </div><div class="line">console.log(res,ary);//-&gt;7 [ 100, 100, 200, 12, 23, 34, 45 ]</div></pre></td></tr></table></figure><p><strong>5、spilce</strong></p><p>能实现删除、修改、增加，下面依次写一下这三个方法</p><p><strong>删除</strong></p><blockquote><pre><code>作用：ary.splice(n,m),从索引n开始删除，删除m个元素，里面不传递参数则是一项都没有删除，返回空数组传递的参数:n,m返回值是:把删除的内容以一个新的数组返回对原来数组的影响:原来数组已经发生了改变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45,23,34];  </div><div class="line">var res=ary.splice(2,3);  </div><div class="line">console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 34 ]</div></pre></td></tr></table></figure><p>注意:ary.splice(n);//表示从索引n开始删除到末尾</p><p><strong>修改</strong></p><blockquote><pre><code>作用：ary.splice(n,m，x),从索引n开始删除，删除m个元素,用x替换删除的部分传递的参数:n,m,x返回值是:把删除的内容以一个新的数组返回对原来数组的影响:原来数组已经发生了改变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45,23,34];</div><div class="line">var res=ary.splice(2,3,1000);</div><div class="line">console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 1000, 34 ]</div></pre></td></tr></table></figure><p><strong>增加</strong></p><blockquote><pre><code>作用：ary.splice(n,0，x),从索引n开始删除，一个都不删除,用x增加到索引n是前面传递的参数:n,m,x返回值是:空数组对原来数组的影响:原来数组已经发生了改变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45,23,34];  </div><div class="line">var res=ary.splice(2,0,1000);  </div><div class="line">console.log(res,ary);//-&gt;[] [ 12, 23, 1000, 34, 45, 23, 34 ]</div></pre></td></tr></table></figure><h2 id="关于数组的截取和拼接"><a href="#关于数组的截取和拼接" class="headerlink" title="关于数组的截取和拼接"></a>关于数组的截取和拼接</h2><p><strong>1、slice</strong></p><blockquote><pre><code>作用：实现数组的截取，在原来的数组中截取某一部分传递的参数:slice(n,m) 从索引n开始，找到索引为m处（不包含m）返回值是:截取到的数组对原来数组的影响:原来的数组不变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45,23,34];  </div><div class="line">var res=ary.slice(2,5);  </div><div class="line">console.log(res,ary);//-&gt;[ 34, 45, 23 ] [ 12, 23, 34, 45, 23, 34 ]</div></pre></td></tr></table></figure><p>注意ary.slice(n),表示从索引n开始一直找到数组的末尾，返回截取到的数组</p><p><strong>2、concat</strong></p><blockquote><pre><code>作用：把两个数组拼接到一起，原来的数组不改变传递的参数:要拼接的数组，可传递的多个数组返回值是:拼接后的新数组对原来数组的影响:原来的数组不变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary1=[12,23,34,45,23,34];  </div><div class="line">var ary2=[100,200];  </div><div class="line">var res=ary1.concat(ary2,ary2);  </div><div class="line">console.log(res,ary1,ary2);//-&gt;[ 12, 23, 34, 45, 23, 34, 100, 200, 100, 200 ] [ 12, 23, 34, 45, 23, 34 ] [ 100, 200 ]</div></pre></td></tr></table></figure><p>注意ary1.concat（）,相当于把ary1克隆一份一模一样的数组.</p><h2 id="把数组转化为字符串"><a href="#把数组转化为字符串" class="headerlink" title="把数组转化为字符串"></a>把数组转化为字符串</h2><p><strong>1、toString</strong></p><blockquote><pre><code>作用：把数组转化为字符串传递的参数:没有参数返回值是:转化后的字符串对原来数组的影响:原来的数组不变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45,23,34];  </div><div class="line">var res=ary.toString();  </div><div class="line">console.log(res,ary);//-&gt;12,23,34,45,23,34 [ 12, 23, 34, 45, 23, 34 ]</div></pre></td></tr></table></figure><p><strong>2、join</strong></p><blockquote><pre><code>作用：按照每一个分隔符把数组中的每一项拼接成一个字符串传递的参数:要分隔的分隔符返回值是:分隔后的结果对原来数组的影响:原来的数组不变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45,23,34];  </div><div class="line">var res=ary.join(&quot;@&quot;);  </div><div class="line">console.log(res,ary);//-&gt;12@23@34@45@23@34 [ 12, 23, 34, 45, 23, 34 ]</div></pre></td></tr></table></figure><p>扩展：eval-&gt;JS中把字符串变为JS表达式执行的一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(eval(&apos;12+12+34&apos;));//-&gt;58</div></pre></td></tr></table></figure><h2 id="数组的排序和排列"><a href="#数组的排序和排列" class="headerlink" title="数组的排序和排列"></a>数组的排序和排列</h2><p><strong>1、reverse</strong></p><blockquote><pre><code>作用：把数组倒过来排列传递的参数:不需要传递参数返回值是:倒过来排序后的数组对原来数组的影响:原来的数组也倒过来排列</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,34,45,23,34];  </div><div class="line">var res=ary.reverse();  </div><div class="line">console.log(res,ary);//-&gt;[ 34, 23, 45, 34, 23, 12 ] [ 34, 23, 45, 34, 23, 12 ]</div></pre></td></tr></table></figure><p><strong>2、sort</strong></p><blockquote><pre><code>作用：给数组进行排序传递的参数:直接写ary.sort()只能处理10以内的数字进行排序返回值是:排序后的数组对原来数组的影响:原数组改变</code></pre></blockquote><p>直接写ary.sort()只能处理10以内的数组，比如下面这个数组。<br>原因：因为它是按照UNICODE编码的值进行排序的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,340,45,23,34];  </div><div class="line">var res=ary.sort();  </div><div class="line">console.log(res,ary);//-&gt;[ 12, 23, 23, 34, 340, 45 ] [ 12, 23, 23, 34, 340, 45 ]</div></pre></td></tr></table></figure><p>sort（）里面传递相应参数可以对所有的进行排序，里面函数返回的值是（a-b）时是有小到大，返回”b-a”时是由大到小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,340,45,23,34]; </div><div class="line">var res=ary.sort(function (a,b) &#123;  </div><div class="line">    return a-b;  </div><div class="line">&#125;);  </div><div class="line">console.log(res,ary);//-&gt;[ 12, 23, 23, 34, 45, 340 ] [ 12, 23, 23, 34, 45, 340 ]</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,340,45,23,34];  </div><div class="line">var res=ary.sort(function (a,b) &#123;  </div><div class="line">    return b-a;  </div><div class="line">&#125;);  </div><div class="line">console.log(res,ary);//-&gt;[ 340, 45, 34, 23, 23, 12 ] [ 340, 45, 34, 23, 23, 12 ]</div></pre></td></tr></table></figure><h2 id="只有在标准浏览器中兼容的方法，在IE6-8下不兼容的"><a href="#只有在标准浏览器中兼容的方法，在IE6-8下不兼容的" class="headerlink" title="只有在标准浏览器中兼容的方法，在IE6-8下不兼容的"></a>只有在标准浏览器中兼容的方法，在IE6-8下不兼容的</h2><p>注意:字符串中也有两个方法是兼容所有浏览器的，而数组这两个方法是不兼容的。</p><p><strong>1、indexOf/lastIndexOf</strong></p><blockquote><pre><code>作用：当前内容在数组中第一次/最后一次出现的索引，如果数组中没有这一项，返回结果&gt;是-1，如果有这一项，索引是几就返回几传递的参数:要查找的数字返回值是:0或-1对原来数组的影响:不变</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,340,45,23,34];  </div><div class="line">var res=ary.indexOf(12);  </div><div class="line">console.log(res,ary);//-&gt;0 [ 12, 23, 340, 45, 23, 34 ]</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,340,45,23,34];   </div><div class="line">var res=ary.indexOf(1000);  </div><div class="line">console.log(res,ary);//-&gt;-1 [ 12, 23, 340, 45, 23, 34 ]</div></pre></td></tr></table></figure><p>应用:可以用它的返回值来验证当前内容在数组中是否存在，看它的返回值是不是-1；</p><p><strong>2、forEach/map</strong></p><p>参考这篇文章:<br><a href="http://www.fanzhanxiang.cn/2017/11/05/forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB/" target="_blank" rel="external">http://www.fanzhanxiang.cn/2017/11/05/forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB/</a></p><blockquote><pre><code>作用：都是用来遍历数组中的每一项的传递的参数:看例子返回值是:前面的博文中有写这两个方法对原来数组的影响:参考前面的一篇博文</code></pre></blockquote><p>用法:数组中有几项我们的函数就执行几次；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var ary=[12,23,340,45,23,34];  </div><div class="line">var res=ary.forEach(function(item,index)&#123;  </div><div class="line">    console.log(item,index);//依次输出：12 0 、 23 1、  340 2 、 45 3 、 23 4 、 34 5  </div><div class="line">&#125;);  </div><div class="line">console.log(res,ary);//-&gt;undefined [ 12, 23, 340, 45, 23, 34 ]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面的数组的方法中都是按照下面的四个维度去详细解读：&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>npm ERR publish 403,nodejs发布包流程</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/08/npm%20ERR%20publish%20403,nodejs%E5%8F%91%E5%B8%83%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/08/npm ERR publish 403,nodejs发布包流程/</id>
    <published>2017-11-08T04:58:00.266Z</published>
    <updated>2017-11-18T07:46:13.282Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs学习体验之发布包，发布环境如下：1:win10系统,2:已安装nodejs.<br><a id="more"></a><br>具体操作步骤如下：<br><strong>编写模块</strong></p><p>1）新建文件夹，比如：node</p><p>2) 该文件夹下新建js文件，比如：index.js,js里面的内容可以随便写</p><p><strong>初始化包描述文件</strong></p><p>进入node文件夹之后按住shift的同时按住鼠标右键，选择在此处打开命令窗口有的电脑也可以是在”此处打开Powershell窗口，然后进入”<br>执行下列命令、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure><p>之后连续点击enter键，帮助你生成package.json文件。<br>这是我的文件的内容.name这个属性在按enter键的时候需要注意是要自己填的，也可以在生成package.json之后再改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;fanzhanxiang&quot;,  </div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,  </div><div class="line">  &quot;description&quot;: &quot;&quot;,  </div><div class="line">  &quot;main&quot;: &quot;index.js&quot;,  </div><div class="line">  &quot;scripts&quot;: &#123;  </div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  </div><div class="line">  &quot;author&quot;: &quot;&quot;,  </div><div class="line">  &quot;license&quot;: &quot;ISC&quot;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注册包仓库账号</strong><br>执行这个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm adduser</div></pre></td></tr></table></figure><p>输入这个命令会有提示输入用户名，密码，邮箱等资料</p><p>这和去官方源仓库<a href="https://www.npmjs.com/注册是一样的" target="_blank" rel="external">https://www.npmjs.com/注册是一样的</a></p><p><strong>上传包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm publish</div></pre></td></tr></table></figure><p>如果上传成功会提示</p><p><strong>+fanzhanxiang@1.0.0 </strong><br>否则上传失败</p><p>这个时候去<a href="https://www.npmjs.com/登陆仓库账号就可以看到自己的包啦。" target="_blank" rel="external">https://www.npmjs.com/登陆仓库账号就可以看到自己的包啦。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs学习体验之发布包，发布环境如下：1:win10系统,2:已安装nodejs.&lt;br&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>call、apply、bind的区别</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/07/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/07/call、apply、bind的区别/</id>
    <published>2017-11-07T07:11:49.455Z</published>
    <updated>2017-11-07T07:28:04.278Z</updated>
    
    <content type="html"><![CDATA[<p>apply和call的作用是一模一样的，都是用来改变方法下的this关键字并且把方法执行，并且在”严格模式”下和非严格模式下对于第一个参数书null和undefined这种情况也是一样的。当在JS开始的时候在最前面加一句代码叫:”<strong>use strict</strong>“表示告诉当前当前浏览器，接下来的JS代码将按照严格模式编写<br><a id="more"></a><br><strong>严格模式</strong></p><blockquote><pre><code>在非严格模式下，函数定义的形参和arguments是存在映射关系的，一个变另一个也跟着变,  但是在严格模式下这个是没有映射关系的。并且在严格模式下禁止我们使用arguments.callee和arguments.callee.caller;</code></pre></blockquote><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    &apos;use strict&apos;;//告诉当前当前浏览器，接下来的JS代码将按照严格模式编写</div><div class="line">    var obj=&#123;name:&quot;ABC&quot;&#125;;</div><div class="line">    function fn(num1,num2) &#123;</div><div class="line">        console.log(num1+num2);</div><div class="line">        console.log(this);</div><div class="line">    &#125;</div><div class="line">    //fn(100,200);//this是Window num1=100，num2=200</div><div class="line">    //fn.call(100,200);//this-&gt;100 num1=200 num2=undefined</div><div class="line">    //fn.call(obj,100,200);//this-&gt;obj num1=100 num2=200</div><div class="line">    /*fn.call();//this-&gt;window  在严格模式下 this-&gt;undefined</div><div class="line">    fn.call(null);//this-&gt;window  在严格模式下this-&gt;null</div><div class="line">    fn.call(undefined);//this-&gt;window  在严格模式下this-undefined</div><div class="line">    */</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><blockquote><pre><code>我们发现严格模式下的this相对于非严格模式的this主要区别在于：对于JS代码没有写执行主体去情况下，非严格模式默认是在Window执行的，所以this指向的是Window;但是在严格模式下没有写执行主体，this指向是undefined.</code></pre></blockquote><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">   var obj=&#123;name:&quot;ABC&quot;&#125;;</div><div class="line">   function fn(num1,num2) &#123;</div><div class="line">        console.log(num1+num2);</div><div class="line">        console.log(this);</div><div class="line">    &#125;</div><div class="line">   //fn.call(obj,100,200);//-&gt;这行代码和下面这行代码的作用相同</div><div class="line">   fn.apply(obj,[100,200]);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p><strong>和call的区别</strong></p><blockquote><p>call在给fn传递参数的时候是一个一个传递的，而apply不是一个个传，而是要把fn传递的参数值统一放在一个数组中进行操作，但是也相当于一个个的给fn的形参赋值.</p></blockquote><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>这个方法在IE6-8上不兼容-&gt;和call和apply方法类似，都是用来改变this关键字的。但是这个方法是一个预处理的效果，事先把this变为我们想要的结果，并且把函数中的参数值也准备好。以后用到了直接执行即可。</p><p>用代码表示为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">   var obj=&#123;name:&quot;ABC&quot;&#125;;</div><div class="line">   function fn(num1,num2) &#123;</div><div class="line">        console.log(num1+num2,this);</div><div class="line">    &#125;</div><div class="line">   //fn.call(obj,100,200);//-&gt;已经执行了，会输出值&quot;300,&#123;name:&quot;ABC&quot;&#125;&quot;;</div><div class="line">   fn.bind(obj,100,200);//仅仅是改变了fn中的this为obj,传递参数值，并没有执行fn这个方法</div><div class="line">   var tempFn=fn.bind(obj,1,2)//-&gt;&quot;3,&#123;name:&quot;ABC&quot;&#125;&quot;;这时候fn就执行了,这就是bind的作用</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>bind的还有一个作用是事先固定值的功能，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">   function fn(num1,num2) &#123;</div><div class="line">        console.log(num1+num2，this);</div><div class="line">    &#125;</div><div class="line">   fn.bind(this,100);//-&gt;这里bind的作用不是改变this问题，this还是Window，但是这里是先  在函数里面固定的传入第一个参数值num1,第二个参数值在执行的时候可以在后面再传递进去。比如下  面这行代码</div><div class="line">   var tempFn=fn.bind(this,100);</div><div class="line">   tempFn(2);//-&gt;这里相当于传递进来了第二个参数num2，输出值为&quot;3,window&quot;,这里的作用并没有改变this值。如果不传递第二个参数的话第二个参数默认是undefined</div><div class="line">   tenpFn();//-&gt;&quot;NaN,window&quot;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>bind体现了JS中的<strong>预处理</strong>思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要是用到了，直接的执行即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;apply和call的作用是一模一样的，都是用来改变方法下的this关键字并且把方法执行，并且在”严格模式”下和非严格模式下对于第一个参数书null和undefined这种情况也是一样的。当在JS开始的时候在最前面加一句代码叫:”&lt;strong&gt;use strict&lt;/strong&gt;“表示告诉当前当前浏览器，接下来的JS代码将按照严格模式编写&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 部署到 Github Pages 文件夹大小写问题</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/06/Hexo%20%E9%83%A8%E7%BD%B2%E5%88%B0Github%20Pages%20%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/06/Hexo 部署到Github Pages 文件夹大小写问题/</id>
    <published>2017-11-06T13:08:59.989Z</published>
    <updated>2017-11-06T13:17:16.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p>使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404问题。<br><a id="more"></a></p><p>譬如 Hexo 生成了一个 javascript  js文件夹，但是我后来把它改成了 javascript Js，即 j 的首字母大写了。Hexo会生成正确，但部署到 Github 上却老是不正确。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>进入到博客项目中 .deploy_git文件夹，这个文件夹在 “博客目录-&gt;.deploy_git-&gt;git”下，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false，如图所示，这是我已经修改过的，原来是true。</li></ul><p><img src="http://oyh928sxz.bkt.clouddn.com/hexo.png" alt=""></p><ul><li>删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步是清空你的 github.io 项目中所有文件。在博客项目中，执行下面命令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd .deploy_git  </div><div class="line">it rm -rf *  </div><div class="line">git commit -m &apos;clean all file&apos;  </div><div class="line">git push</div></pre></td></tr></table></figure><ul><li>使用 Hexo 再次生成及部署，在上面命令执行完之后执行下面命令,问题解决。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ..  </div><div class="line">hexo clean  </div><div class="line">hexo deploy -generate</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题简介&quot;&gt;&lt;a href=&quot;#问题简介&quot; class=&quot;headerlink&quot; title=&quot;问题简介&quot;&gt;&lt;/a&gt;问题简介&lt;/h2&gt;&lt;p&gt;使用 Hexo 部署博客到 Github Pages 时经常会遇到文件夹大小写问题导致的 404问题。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>本地存储</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/本地存储/</id>
    <published>2017-11-05T08:05:46.393Z</published>
    <updated>2017-11-05T08:12:30.060Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JS中的本地存储:</strong></p><p>使用JS向浏览器向浏览器某一个位置中存储一些内容，浏览器即使关闭了，存储了信息也不会销毁，当在重新打开浏览器的时候我们依然可以获取到上一次存储的信息。<br><a id="more"></a></p><h2 id="一、本地存储的方案"><a href="#一、本地存储的方案" class="headerlink" title="一、本地存储的方案"></a>一、本地存储的方案</h2><p><strong>传统:</strong></p><blockquote><pre><code>1、cookie:把信息存储到客户端的浏览器中（但是项目服务器端也是可以获取COOKIE的）2、session:把信息存储到服务器上的（服务器存储）</code></pre></blockquote><p><strong>HTML5:webStorage</strong></p><blockquote><pre><code>1、localStorage:永久存储到客户端本地2、sessionStorage:信息会话存储，回话窗口存在信息也存在，会话窗口关闭信息也消失了</code></pre></blockquote><p>打开谷歌控制台，按F12可以Application中可以看到这些相应的窗口:如图所示<br><img src="http://oyh928sxz.bkt.clouddn.com/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.png" alt=""></p><h2 id="COOKIE-localStorage-sessionStorage三者之间的用法以及区别"><a href="#COOKIE-localStorage-sessionStorage三者之间的用法以及区别" class="headerlink" title="COOKIE localStorage sessionStorage三者之间的用法以及区别"></a>COOKIE localStorage sessionStorage三者之间的用法以及区别</h2><p><strong>webStorage</strong></p><p>localStorage和sessionStorage的用法是一样的：<br>setItem([key],[value]):向客户端的本地存储一条记录，存储的[value]值需要使字符串格式的，如果编写的不是字符串，浏览器也会默认转化为字符串然后进行存储;存储的[key]是不会重复的，如果之前有的话，把存储的信息值重新进行修改；</p><blockquote><pre><code>1、getItem([key]):获取之前存储的值2、removeItem([key]):移除key对应的那条记录3、clear():把当前源下所有的存储记录都移除掉4、localStorage.length:获取存储的记录条数5、localStorage.key(0):获取索引为0这一项的key是什么</code></pre></blockquote><p>用代码表示为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;7&quot;   </div><div class="line">localStorage.setItem(&apos;age&apos;,JSON.stringify(&#123;name:&apos;abc&apos;&#125;));   </div><div class="line">console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;&#123;&quot;name&quot;:&quot;abc&quot;&#125;&quot;  </div><div class="line">localStorage.removeItem(&apos;age&apos;);  </div><div class="line">localStorage.clear();  </div><div class="line">console.log(localStorage.length);//-&gt;0  </div><div class="line">console.log(localStorage.key(0));//-&gt;&apos;null&apos;</div></pre></td></tr></table></figure><p>下面是执行下面这段代码之后存储在控制台里面看到的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(localStorage.getItem(&apos;age&apos;));//-&gt;&quot;7&quot;</div></pre></td></tr></table></figure><p><img src="http://oyh928sxz.bkt.clouddn.com/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A81.png" alt=""></p><p><strong>localStorage和sessionStorage的区别:</strong></p><blockquote><pre><code>1、localStorage属于永久存储到本地，不管是刷新页面还是关掉页面或者关掉浏览器，存储的内容都不会消失，只有我们手动删除才会消失（不管是杀毒软件还是浏览器自带的清除历史记录的功能都不能把localStorage存储的内容移除掉）;  2、sessionStorage属于临时会话存储，只要当前的页面不关闭，信息就可以存储下来，但是页面一旦关闭,存储的信息就会自动关闭（F5刷新只是把当前的DOM机构等进行重新渲染，会话并没有关闭）</code></pre></blockquote><p><strong>cookie</strong></p><p>cookie和locaStorage的区别:</p><blockquote><pre><code>1、cookie兼容所有浏览器，但是localStorage不兼容IE6-82、cookie存储内容的大小是有限制的，一般同源下只能存储4KB内容;localStorage存储的内容大小也有限制，一般同源下只能存储5MB;3、cookie存储的内容是有过期时间的，而localStorage是永久存储到本地，使用杀毒软件或者清除垃圾的功能都可能把存储的cookie给删除掉4、用户可能出于安全的角度禁用cookie(无痕浏览)，但是不能禁用localStorage.</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JS中的本地存储:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用JS向浏览器向浏览器某一个位置中存储一些内容，浏览器即使关闭了，存储了信息也不会销毁，当在重新打开浏览器的时候我们依然可以获取到上一次存储的信息。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组的forEach和map方法解读</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/forEach和map方法解读/</id>
    <published>2017-11-05T02:45:03.800Z</published>
    <updated>2017-11-05T02:45:03.810Z</updated>
    
    <content type="html"><![CDATA[<p>forEach和map方法都是用来遍历数组中的每一项的;<br><a id="more"></a></p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><blockquote><pre><code>1、数组中有几项，那我们传递进去的匿名函数就需要执行几次2、每一次执行匿名函数的时候，还给其浏览器给其默认传递了三个参数值：数组中的当前项 item，当前项的索引index，原始数组input。3、理论上我们的方法是没有返回值的，仅仅遍历数组中的每一项不对原来的数据进行修改，但是我们可以通过数组的索引来修改原来的数组。</code></pre></blockquote><p>执行下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">    var ary=[12,23,34,45,43];</div><div class="line">    var res=ary.forEach(function (item,index,input) &#123;</div><div class="line">        console.log(arguments);</div><div class="line">        input[index]=item*10;</div><div class="line">    &#125;);</div><div class="line">    console.log(res);//-&gt;undefined</div><div class="line">    console.log(ary);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>控制台中返回结果如图所示:<br><img src="http://oyh928sxz.bkt.clouddn.com/forEach.png" alt=""></p><p>原因：执行了5函数，输出了5次arguments,并且函数在遍历的时候是从索引0开始依次遍历的。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的回调函数中支持return返回值，return的后面是啥，相当于把数组中的这这一项改变为啥(但是并不影响原来的数组，只是相当于把原来的数组克隆一份，把克隆的这一份数组中的对应项改变了)。</p><p>用代码表示为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">        var ary=[12,23,34,45,43];</div><div class="line">    var res=ary.map(function (item, index, input) &#123;</div><div class="line">        return item*10;</div><div class="line">    &#125;);</div><div class="line">    console.log(res);//-&gt; [120, 230, 340, 450, 430]</div><div class="line">    console.log(ary);//-&gt;[12, 23, 34, 45, 43]</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>不管是forEach还是map都支持第二个参数，第二个参数的意识是把匿名函数中的this进行修改为第二个参数值。</p><p>代码表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">     var obj=&#123;name:&quot;abc&quot;&#125;;</div><div class="line">    var ary=[12,23,34,45,43];</div><div class="line"></div><div class="line">    ary.forEach(function (item, index) &#123;</div><div class="line">        console.log(this);</div><div class="line">    &#125;);</div><div class="line">    ary.forEach(function (item, index) &#123;</div><div class="line">        console.log(this);</div><div class="line">    &#125;,obj);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>在控制台中输出的结果如图所示:</p><p><img src="http://oyh928sxz.bkt.clouddn.com/map%E6%88%96forEach%E4%B8%AD%E7%9A%84this%E9%97%AE%E9%A2%98.png" alt=""></p><p>证实了上面的结论。</p><blockquote><pre><code>不管是forEach还是map在IE6-8下都不兼容</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;forEach和map方法都是用来遍历数组中的每一项的;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的同步和异步编程</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/JS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/05/JS的同步和异步编程/</id>
    <published>2017-11-05T01:28:49.752Z</published>
    <updated>2017-11-05T01:30:59.997Z</updated>
    
    <content type="html"><![CDATA[<p>JS中的两种编程思想：同步、异步。<br><a id="more"></a></p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步编程:上一件事情没有完成，继续做上一件事情，只有上一件事情完成了，才会做下一件事情(JS大部分都是同步编程的)。如下面代码：（1）、（2）分别代表第一次和第二次输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">for(var i=0;i&lt;100000;i++)&#123;</div><div class="line">      if(i===99999)&#123;</div><div class="line">           console.log(&quot;循环结束了~~&quot;)//-&gt;(1)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(&quot;ok&quot;);//-&gt;(2)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:for循环就是同步编程的，只有循环结束后，才会执行下面的代码,因此会先输出前面的，再输出后面的。</p><p>再比如下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">while (1)&#123;</div><div class="line"></div><div class="line"> &#125;</div><div class="line">    console.log(&quot;ok&quot;);//-&gt;不会有结果输出，并且浏览器还会崩溃</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:因为上面的循环是死循环，循环永远不会结束,JS不会跳过上面那段循环来执行下面的循环。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>解读：首先规划要做一件事情，但是不是立马去执行这件事情，需要等一定的时间，这样的话我们不会继续等着它执行，而是继续执行下面的操作，”只有下面的事情都处理完成了”.只有当下面的事情都处理完成了，才会返回头处理之前的事情；如果下面的事情没有处理完成，不管之前的事情有没有处理完成，都踏踏实实的给我等着。在JS中异步编程只有四种情况：定时器都是异步编程的、所有事件绑定都是异步编程的、AJAX读取数据的时候，我们一般设定为异步编程、回调函数也是异步编程的。</p><p>比如下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">var n=0;</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">          n++;</div><div class="line">          console.log(n);//-&gt;1(2)</div><div class="line">       &#125;,1000);</div><div class="line">       console.log(n);//-&gt;0(1)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:定时器是异步编程的，在1000ms之后再执行定时器中的方法，因此会先输出0，再输出1。</p><p><strong>关于浏览器的最小等待事件问题</strong></p><p>比如下面的这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">var n=0;</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">        n++;</div><div class="line">        console.log(n);//-&gt;1(2)</div><div class="line">    &#125;,0);</div><div class="line">    console.log(n);//-&gt;0(1)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:每一个浏览器对于定时器的等待时间都有一个最小值：谷歌大概:5~6ms,IE大概:13~14ms,如果设置的等待时间小于这个值，不起作用，还是需要等到最小时间才执行；尤其是写0也不是立即执行；</p><p><strong>定时器设置的等待时间不一定就是最后执行的时间</strong></p><p>看下面的这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">    var n=0;</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">        n++;</div><div class="line">        console.log(n);//-&gt;不执行</div><div class="line">    &#125;,0);</div><div class="line">    console.log(n);//-&gt;0(1)</div><div class="line"></div><div class="line">    while (1)&#123;</div><div class="line">        n++;//-&gt;死循环</div><div class="line">    &#125;</div><div class="line">    console.log(n);//-&gt;不执行</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因:执行到while的时候出现了死循环，因此定时器里面的方法永远不会执行。</p><p><strong>定时器是谁先到先执行谁</strong></p><p>如下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;  </div><div class="line">       var n=0;</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">        n+=2;</div><div class="line">        console.log(n);//-&gt;7(4)</div><div class="line">    &#125;,20);</div><div class="line">    window.setTimeout(function()&#123;</div><div class="line">        n+=5;</div><div class="line">        console.log(n);//-&gt;5(3)</div><div class="line">    &#125;,5);</div><div class="line">    console.log(n);//-&gt;0(1)</div><div class="line">    for(var i=0;i&lt;10000000;i++)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    console.log(n);//-&gt;0(2)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>原因：JS在执行的时候会有一个类似于设置闹钟的那种机制的任务队列，不是之前设置的闹钟就之前叫，而是不管是什么时候设置的，谁的时间先到了就谁先叫。如图所示。</p><p><img src="http://oyh928sxz.bkt.clouddn.com/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.png" alt=""></p><blockquote><pre><code>上面仅仅是讲了定时器这一种异步编程思想，所有事件绑定、AJAX读取数据的时候、回调函数这几种的原理也和定时器的一样</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS中的两种编程思想：同步、异步。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据类型检测的四种方式</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/JavaScript%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%98%AF%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/JavaScript中数据类型检测是四种方式/</id>
    <published>2017-11-04T12:09:27.663Z</published>
    <updated>2017-11-05T01:02:17.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、typeof-用来检测数据类型的运算符"><a href="#一、typeof-用来检测数据类型的运算符" class="headerlink" title="一、typeof 用来检测数据类型的运算符"></a>一、typeof 用来检测数据类型的运算符</h2><p>使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串包含了对应的数据类型，例<br><a id="more"></a><br>如:’number’、’string’、’boolean’、’undefined’、’function’、’object’。<br><strong>局限性</strong>：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeof null-&gt;&quot;object&quot;</div></pre></td></tr></table></figure><p>不能具体细分是数组还是正则，还是对象中其他的值，因为使用typeof检测数据类型，对于对象数据类型中的左右的值，最后返回的结果都是”object”</p><h2 id="二、instanceof-检测某一个实例是否属于这个类"><a href="#二、instanceof-检测某一个实例是否属于这个类" class="headerlink" title="二、instanceof 检测某一个实例是否属于这个类"></a>二、instanceof 检测某一个实例是否属于这个类</h2><p>优点：它可以用来检测是数组还是正则了。<br>局限性：对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定的区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这类的实例，对于字面量创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散型，导致了可以使用JS原型上的方法。如下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">console.log(1 instanceof Number);//-&gt;控制台输出false     </div><div class="line">console.log(new Number(1) instanceof Number);//-&gt;控制台输出true  </div><div class="line"> var ary=[];  </div><div class="line">   function fn() &#123;</div><div class="line">       </div><div class="line">   &#125;  </div><div class="line">   console.log(ary instanceof Array)//-&gt;控制台输出true  </div><div class="line">   console.log(ary instanceof Object)//-&gt;控制台输出true  </div><div class="line">   console.log(fn instanceof Function)//-&gt;控制台输出true  </div><div class="line">   console.log(ary instanceof Object)//-&gt;控制台输出true</div></pre></td></tr></table></figure><p>因此，它会产生以下影响：</p><blockquote><pre><code>1、不能用来检测和处理字面量方式创建出来的基本数据类型值。2、instanceof的特性：只要在当前实例的原型链上，我们用其检测出来的结果都是true。3、在类的原型继承中，我们最后检测出来的结果未必准确。只要它的原型链上有这个类，最后用这方法检测出来的结果都是true。</code></pre></blockquote><h2 id="三、constructor-构造函数-作用和instanceof非常相似"><a href="#三、constructor-构造函数-作用和instanceof非常相似" class="headerlink" title="三、constructor: 构造函数 作用和instanceof非常相似"></a>三、constructor: 构造函数 作用和instanceof非常相似</h2><p>有如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj=[],num=1，reg=/^$/;   </div><div class="line">console.log(obj.constructor===Array);//-&gt;true  </div><div class="line">console.log(obj.constructor===RegExp);//-&gt;false  </div><div class="line">console.log(num.constructor===Number);//-&gt;true  </div><div class="line">console.log(reg.constructor===RegExp);//-&gt;true  </div><div class="line">console.log(reg.constructor===Object);//-&gt;false</div></pre></td></tr></table></figure></p><p>优点:可以看出和instanceof相比，constructor可以处理基本数据类型的检测。<br>不同:constructor和instanceof不一样的地方在于，constructor在检测的时候先在私有属性上找，找到之后就不会往后面找了，所以在用来检测Object的时候，一般情况下是检测不了的。<br>局限性：我们可以把类的原型进行重写，在进行的重写过程中，很有可能之前contructor给覆盖掉了，这样检测出来的结果就是不准确的。</p><blockquote><pre><code>扩展：对于特殊的数据类型null和undefined,他们的所属类是Null和Undefined,但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。</code></pre></blockquote><h2 id="四、Object-prototype-toString-call"><a href="#四、Object-prototype-toString-call" class="headerlink" title="四、Object.prototype.toString.call()"></a>四、Object.prototype.toString.call()</h2><p>这是最准确检测数据类型的方法；</p><p>解读：首先获取Object原型上toString方法，让方法执行，并且改变方法中的this关键字的指向。先看一下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot;</div><div class="line">console.log((128).toString(2/8/10));-&gt;把数字转化为二进制/八进制/十进制，Number原型上的toString方法支持把数字转化为相的进制。  </div><div class="line">console.log((1).__proto__.__proto__.toString());//-&gt;&quot;[object Object]&quot;  </div><div class="line">console.log(&quot;zhufeng&quot;.toString());//-&gt;也是转为为字符串，但是不支持进制  </div><div class="line">console.log(&#123;&quot;name&quot;: &quot;abc&quot;&#125;.toString());//-&gt;&quot;[object Object]&quot;  </div><div class="line">console.log(Math.toString())//-&gt;&quot;[object Math]&quot;</div></pre></td></tr></table></figure><p>通常情况下对toString的理解：</p><blockquote><pre><code>对于Number、String、Boolean、Array、RegExp、Date、Function原型上的toString()方法都是把当前的数据类型转换为字符串类型（他们的作用仅仅是用来转换为字符串Object.prototype.toString并不是用来转换为字符串的。Object.prototype.toString它的作用是返回当前方法的执行主体（方法中this）所属类的详细信息。var obj={name:&quot;xyz&quot;};//-&gt;&quot;[object Object]&quot;console.log(obj.toString());//-&gt;toString中的this是obj,返回的是obj所属类的信息-&quot;[object Object]&quot;第一个object代表当前实例是对象数据类型的(这个是固定)，第二个Object,代表的是obj是object这个类的一个实例。</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var ary=[];   </div><div class="line"> console.log(Object.prototype.toString.call(ary));//-&gt;&quot;[object Array]&quot;;   </div><div class="line"> console.log(Object.prototype.toString.call(/^$/));//-&gt;&quot;[object RegExp]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(1));//-&gt;&quot;[object Number]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(&quot;dsas&quot;));//-&gt;&quot;[object String]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(true));//-&gt;&quot;[object Boolean]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(null));//-&gt;&quot;[object Null]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(undefined));//-&gt;&quot;[object Undefined]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(function () &#123;&#125;));//-&gt;&quot;[object Function]&quot;;  </div><div class="line"> console.log((&#123;&#125;).toString.call(new Date));//-&gt;&quot;[object Date]&quot;;  </div><div class="line"> console.log((1).toString());//-&gt;Number.prototype.toString(),转化为字符串 &quot;1&quot;</div></pre></td></tr></table></figure><blockquote><pre><code>从上面代码可以总结春：Object.prototype.toString并不是用来转换为字符串的，返回的是obj所属类的信息息-&quot;[object &quot;参数2&quot;]&quot;第一个object代表当前实例是对象数据类型的(这个是固定)，第二个参数，“参数2”,代表的是检测的这个所属的类。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、typeof-用来检测数据类型的运算符&quot;&gt;&lt;a href=&quot;#一、typeof-用来检测数据类型的运算符&quot; class=&quot;headerlink&quot; title=&quot;一、typeof 用来检测数据类型的运算符&quot;&gt;&lt;/a&gt;一、typeof 用来检测数据类型的运算符&lt;/h2&gt;&lt;p&gt;使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串包含了对应的数据类型，例&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中检测兼容的三种方式</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/JS%E6%A3%80%E6%B5%8B%E5%85%BC%E5%AE%B9%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/JS检测兼容的三种方式/</id>
    <published>2017-11-04T11:57:38.077Z</published>
    <updated>2017-11-04T12:10:53.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、使用try、catch来处理兼容"><a href="#一、使用try、catch来处理兼容" class="headerlink" title="一、使用try、catch来处理兼容"></a>一、使用try、catch来处理兼容</h2><p>前提：必须保证try中的代码在不兼容浏览器中执行的时候报错，这样的话我们才可以用catch捕获到异常的信息，进行其它的处理，示例代码如下面所示。<br>缺点：不管是什么浏览器，都需要把try中的代码都需要把try中的代码执行一遍，如果当前是IE7。window.getComputedStyle本身是不兼容的，但是我们也要把它先执行一遍，报错了再把curEle.currentStyle执行一遍（消耗性能），因此使用try处理兼容只有在万不得已的情况下才使用它。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;</div><div class="line">    function getCss(curEle,attr) &#123;//-&gt;curEle指的是操作的元素，attr指的是元素属性</div><div class="line">        var val=null;</div><div class="line">        try&#123;</div><div class="line">            val=window.getComputedStyle(curEle,null)[attr];</div><div class="line">        &#125;catch(e)&#123;</div><div class="line">            val=curEle.currentStyle[attr];</div><div class="line">        &#125;</div><div class="line">        return val;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="二、判断当期浏览器中是否存在这个属性和方法"><a href="#二、判断当期浏览器中是否存在这个属性和方法" class="headerlink" title="二、判断当期浏览器中是否存在这个属性和方法"></a>二、判断当期浏览器中是否存在这个属性和方法</h2><p>判断当期浏览器中是否存在这个属性和方法，存在就兼容，不存在就不兼容。代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;</div><div class="line">    function getCss(curEle,attr) &#123;</div><div class="line">        var val = null;</div><div class="line">        if (getComputedStyle in window) &#123;//-&gt;如果返回结果是true，说明Window下有getComputedStyle，代表兼容</div><div class="line">            val = window.getComputedStyle(curEle, null)[attr];</div><div class="line">        &#125; else &#123;</div><div class="line">            val = curEle.currentStyle[attr];</div><div class="line">        &#125;</div><div class="line">        return val;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="三、通过检测浏览器版本和类型来处理兼容"><a href="#三、通过检测浏览器版本和类型来处理兼容" class="headerlink" title="三、通过检测浏览器版本和类型来处理兼容"></a>三、通过检测浏览器版本和类型来处理兼容</h2><p>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  &lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;</div><div class="line">    function getCss(curEle,attr) &#123;</div><div class="line">        var val = null;</div><div class="line">        if (/MSIE(6|7|8)/.test(navigator.userAgent)) &#123;//-&gt;说明是IE6-8浏览器</div><div class="line">            val = curEle.currentStyle[attr];</div><div class="line">        &#125; else &#123;</div><div class="line">            val = window.getComputedStyle(curEle, null)[attr];</div><div class="line">        &#125;</div><div class="line">        return val;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、使用try、catch来处理兼容&quot;&gt;&lt;a href=&quot;#一、使用try、catch来处理兼容&quot; class=&quot;headerlink&quot; title=&quot;一、使用try、catch来处理兼容&quot;&gt;&lt;/a&gt;一、使用try、catch来处理兼容&lt;/h2&gt;&lt;p&gt;前提：必须保证try中的代码在不兼容浏览器中执行的时候报错，这样的话我们才可以用catch捕获到异常的信息，进行其它的处理，示例代码如下面所示。&lt;br&gt;缺点：不管是什么浏览器，都需要把try中的代码都需要把try中的代码执行一遍，如果当前是IE7。window.getComputedStyle本身是不兼容的，但是我们也要把它先执行一遍，报错了再把curEle.currentStyle执行一遍（消耗性能），因此使用try处理兼容只有在万不得已的情况下才使用它。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中常用的六种继承方式</title>
    <link href="https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/fanzhanxiang/fanzhanxiang.github.io/2017/11/04/常用的六种继承方式/</id>
    <published>2017-11-04T06:05:20.860Z</published>
    <updated>2017-11-04T12:21:14.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><p><strong>可枚举和不可枚举</strong>：<br>我们在JavaScript中使用for..in遍历对象的时候，会发现下面的情况：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;;</div><div class="line">    Object.prototype.aaa = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    for(var key in obj)&#123;</div><div class="line">console.log(key)</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>最后在谷歌的控制台中会输出:</p><blockquote><pre><code>nameageaaa</code></pre></blockquote><p>这说明在使用for..in 遍历对象的时候默认会把自己私有的和它所属类的原型上扩展的属性和方法都可以遍历到，但是一般情况下，我们遍历对象只需要遍历私有的即可，我们可以使用以下的判断进行处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;;</div><div class="line">    Object.prototype.aaa = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    for(var key in obj)&#123;</div><div class="line">             if(obj.propertyIsEnumerable(key))&#123;</div><div class="line">console.log(key)</div><div class="line">             &#125;</div><div class="line">     &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false，下面为大家介绍下其具体的使用：propertyIsEnumerable()是用来检测属性是否属于某个对象的,如果检测到了,返回true,否则返回false</p><blockquote><pre><code>1、这个属性必须属于实例的,并且不属于原型. 2、这个属性必须是可枚举的,也就是自定义的属性,可以通过for..in循环出来的</code></pre></blockquote><p>只有符合上面这两个要求，才会返回true。因为在使用for…in遍历对象对象的时候，在前面加一个这个方法来判断一下，原型上的自己定义的属性就不会被遍历出来了。</p><p>也可以用下面的方法来只遍历出对象中的私有属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var obj = &#123;name: &quot;zhuFen&quot;, age: 7&#125;;</div><div class="line">    Object.prototype.aaa = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    for(var key in obj)&#123;</div><div class="line">             if(obj.hasOwnProperty(key))&#123;</div><div class="line">console.log(key)</div><div class="line">             &#125;</div><div class="line">     &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。只遍历出私有私有属性，而不会遍历出原型链上的属性。</p><p>加上这两个判断之后，控制台中会输出同样的结果，结果是：</p><blockquote><pre><code>nameage</code></pre></blockquote><p><strong>Object.create(proObj)</strong>:创建一个新的对象，但是还要把proObj作为这个对象的原型，在IE6-8不兼容（ECMAScript5），用下面的代码解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var obj = &#123;</div><div class="line">        getX: function () &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    var obj2 = Object.create(obj);</div><div class="line">    obj.getY = function () &#123;</div><div class="line">        console.log(2)</div><div class="line">    &#125;;</div><div class="line">    obj2.getY();</div><div class="line">    console.log(obj2);</div><div class="line">    console.log(obj);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>最谷歌控制台中输出的结果如图所示:<br><img src="http://oyh928sxz.bkt.clouddn.com/Object.create%28%29.png" alt=""><br>2是执行 obj2.getY();输出的结果，中间的这个是obj2，最后这个是obj，可以看出，通过执行Object.create(obj)这个方法，创建出来了obj2这个对象，并且把，并且还把obj作为这个对象的原型。可以看出，在obj2和Object这个基类之间多了一个原型链。而这一级的对象就是obj。</p><p><strong>原型继承</strong></p><blockquote><p>   1、 原型继承是”JS”中最常用的一种继承方式,子类B想要继承父类A中的所有的属性和方法（私有<br>   +公有），只需要让B.prototype=new A,即可。<br>   2、 原型继承的特点：它是把父类私有的+公有的都继承到了子类的原型上（子类公有的）;<br>   3、核心:原型链继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是B和A之间增加了原型链的链接看，以后B的实例n想要用A中的getX方法，需要一级级的查找来使用。代码就这样表示</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    function B()&#123;</div><div class="line">        this.y=200;</div><div class="line">    &#125;</div><div class="line">    B.prototype=new A;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="二、call继承"><a href="#二、call继承" class="headerlink" title="二、call继承"></a>二、call继承</h2><p>call继承的最终结果是把父类私有的属性和方法克隆一份一模一样的，作为子类私有的属性和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    A.prototype.getX=function()&#123;</div><div class="line">        console.log(this.x);</div><div class="line">    &#125;;</div><div class="line">    function B()&#123;</div><div class="line">         A.call(this);</div><div class="line">    &#125;</div><div class="line">    var n=new B;</div><div class="line">    console.log(n.x);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>最后在控制台中最终会输出100，为什么了？new B是创建B这个类的一个实例，在函数B中的this就是这个实例，这里表示的就是n,A.call(this)指的是把函数A中的this变为函数B中的this，而new B之后函数B中的this是n，所以最后在控制台中输出的是100。</p><h2 id="三、冒充对象继承"><a href="#三、冒充对象继承" class="headerlink" title="三、冒充对象继承"></a>三、冒充对象继承</h2><p>冒充对象继承：把父类私有的+公有的克隆一份一模一样给子类私有的。代码用下面的来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    A.prototype.getX=function()&#123;</div><div class="line">        console.log(this.x);</div><div class="line">    &#125;;</div><div class="line">    function B() &#123;</div><div class="line">        var temp=new A;</div><div class="line">        for(var key in temp)&#123;</div><div class="line">            this[key]=temp[key];</div><div class="line">        &#125;</div><div class="line">        temp=null;</div><div class="line">    &#125;</div><div class="line">    var n=new B;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="四、混合模式继承"><a href="#四、混合模式继承" class="headerlink" title="四、混合模式继承"></a>四、混合模式继承</h2><p>混合模式继承：指的是原型继承+call继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    A.prototype.getX=function()&#123;</div><div class="line">        console.log(this.x);</div><div class="line">    &#125;;</div><div class="line">    function B() &#123;</div><div class="line">        A.call(this);</div><div class="line">    &#125;</div><div class="line">    B.prototype=new A;</div><div class="line">    B.prototype.constructor=B;</div><div class="line">    var n=new B;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>这种继承方式会让父类私有的和公有的都会在子类公有的上面有一份，但是在原型链查找的时候会先查找私有属性，所以也不影响整体。优点是父级私有属性都放在子类的私有上了。</p><h2 id="五、寄生组合式继承"><a href="#五、寄生组合式继承" class="headerlink" title="五、寄生组合式继承"></a>五、寄生组合式继承</h2><p>父类公有的给子类公有的，父类私有的给子类私有的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function A()&#123;</div><div class="line">        this.x=100;</div><div class="line">    &#125;</div><div class="line">    A.prototype.getX=function()&#123;</div><div class="line">        console.log(this.x);</div><div class="line">    &#125;;</div><div class="line">    function B() &#123;</div><div class="line">        A.call(this);</div><div class="line">    &#125;</div><div class="line">    B.prototype=Object.create(A.prototype);//这句代码的含义是把B的原型的地址换成了A的原型的地址。</div><div class="line">    B.prototype.constructor=B;</div><div class="line">    var n=new B;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h2 id="六、中间类继承法-gt-IE下不兼容"><a href="#六、中间类继承法-gt-IE下不兼容" class="headerlink" title="六、中间类继承法-&gt;IE下不兼容"></a>六、中间类继承法-&gt;IE下不兼容</h2><p>这段代码是一个数组，在去掉一个最大值和最小值之后求它的平均值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function avgFn() &#123;</div><div class="line">        Array.prototype.sort.call(arguments,function (a,b) &#123;</div><div class="line">            return a-b;</div><div class="line">        &#125;);</div><div class="line">        Array.prototype.pop.call(arguments);</div><div class="line">        Array.prototype.shift.call(arguments);</div><div class="line">        return (eval(Array.prototype.join.call(arguments,&quot;+&quot;))/arguments.length).toFixed(2);</div><div class="line">    &#125;</div><div class="line">    console.log(avgFn(10,20,30,34,44))//-&gt;结果是28</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>使用中间类继承法：代码入下面所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    function avgFn() &#123;</div><div class="line">       arguments.__proto__= Array.prototype;</div><div class="line">        arguments.sort(function(a,b)&#123;</div><div class="line">            return a-b;</div><div class="line">        &#125;);</div><div class="line">        arguments.pop();</div><div class="line">        arguments.shift();</div><div class="line">        return eval(arguments.join(&quot;+&quot;))/arguments.length;</div><div class="line">    &#125;</div><div class="line">    console.log(avgFn(10,20,30,34,44))//-&gt;结果是28</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>这就是直接借用原型链的机制来形成的一种继承方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、原型链继承&quot;&gt;&lt;a href=&quot;#一、原型链继承&quot; class=&quot;headerlink&quot; title=&quot;一、原型链继承&quot;&gt;&lt;/a&gt;一、原型链继承&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;可枚举和不可枚举&lt;/strong&gt;：&lt;br&gt;我们在JavaScript中使用for..in遍历对象的时候，会发现下面的情况：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/fanzhanxiang/fanzhanxiang.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
